From e46b8757c750e5b5befe7ded26f25cfd0d49720f Mon Sep 17 00:00:00 2001
From: kelson8 <kelson@kelsoncraft.net>
Date: Sat, 15 Mar 2025 23:17:16 -0400
Subject: [PATCH 097/101] Add VEHICLE_MODS preprocessor from Extended Vice
 project. Add items from IMPROVED_VEHICLES, and IMPROVED_VEHICLES2 in Extended
 Vice project. These don't work so I have disabled it for now in the config.
 Fix up movement and controls by adding missing parts to
 IMPROVED_MENU_AND_INPUT. Add mod garage test, once I fix this it should work.
 Update librw submodule.

---
 src/control/CarCtrl.cpp                |   12 +
 src/control/Garages.cpp                |  442 +++
 src/control/Garages.h                  |   45 +-
 src/control/Replay.cpp                 |   12 +
 src/control/Replay.h                   |    6 +
 src/control/Script.cpp                 |    6 +
 src/core/Cam.cpp                       |    7 +
 src/core/Camera.cpp                    |   29 +-
 src/core/ControllerConfig.cpp          |    6 +
 src/core/FileLoader.cpp                |   32 +
 src/core/MenuScreensCustom.cpp         |    7 +-
 src/core/Pad.cpp                       |   55 +
 src/core/Pad.h                         |    8 +
 src/core/Pools.cpp                     |    6 +
 src/core/Streaming.cpp                 |    9 +
 src/core/common.h                      |   27 +
 src/core/config.h                      |  174 +-
 src/core/re3.cpp                       |    7 +
 src/extras/custompipes.cpp             |    9 +
 src/extras/debug/debug_functions.cpp   | 1045 +++++-
 src/extras/debugmenu.cpp               |  132 +-
 src/extras/functions/ini_functions.cpp |   52 +-
 src/modelinfo/ModelIndices.h           |   54 +
 src/modelinfo/ModelInfo.cpp            |    6 +
 src/modelinfo/VehicleModelInfo.cpp     |  352 +-
 src/modelinfo/VehicleModelInfo.h       |   95 +-
 src/peds/PedIK.h                       |    4 +
 src/renderer/Coronas.cpp               |    4 +
 src/renderer/Hud.cpp                   |   61 +-
 src/renderer/Particle.cpp              |   42 +
 src/renderer/ParticleType.h            |   13 +
 src/renderer/Weather.cpp               |   12 +
 src/vehicles/Automobile.cpp            | 4181 +++++++++++++++++++++---
 src/vehicles/Automobile.h              |   69 +-
 src/vehicles/Bike.cpp                  |  830 ++++-
 src/vehicles/Bike.h                    |   20 +
 src/vehicles/Boat.cpp                  |   12 +
 src/vehicles/CarGen.cpp                |    6 +
 src/vehicles/Transmission.cpp          |   16 +-
 src/vehicles/Transmission.h            |    5 +
 src/vehicles/Vehicle.cpp               |   30 +
 src/vehicles/Vehicle.h                 |   70 +
 src/weapons/BulletInfo.cpp             |    6 +
 src/weapons/Weapon.cpp                 |  103 +
 src/weapons/Weapon.h                   |    5 +
 vendor/librw                           |    2 +-
 46 files changed, 7447 insertions(+), 679 deletions(-)

diff --git a/src/control/CarCtrl.cpp b/src/control/CarCtrl.cpp
index 7a85e831..c5daaa16 100644
--- a/src/control/CarCtrl.cpp
+++ b/src/control/CarCtrl.cpp
@@ -358,6 +358,11 @@ CCarCtrl::GenerateOneRandomCar()
 	pVehicle->AutoPilot.m_nCurrentRouteNode = curNodeId;
 	pVehicle->AutoPilot.m_nNextRouteNode = nextNodeId;
 
+#ifdef VEHICLE_MODS // TrySetRandomCarMod for vehicle in traffic
+	if (pVehicle->IsCar())
+		((CAutomobile*)pVehicle)->TrySetRandomCarMod();
+#endif
+
 	switch (carClass) {
 	case COPS:
 		pVehicle->AutoPilot.m_nTempAction = TEMPACT_NONE;
@@ -644,7 +649,14 @@ CCarCtrl::GenerateOneRandomCar()
 		delete pVehicle;
 		return;
 	}
+
+#ifdef IMPROVED_VEHICLES // More colors
+	pVehicleModel->AvoidSameVehicleColour(&pVehicle->m_currentColour1, &pVehicle->m_currentColour2, &pVehicle->m_currentColour3, &pVehicle->m_currentColour4);
+#else
 	pVehicleModel->AvoidSameVehicleColour(&pVehicle->m_currentColour1, &pVehicle->m_currentColour2);
+#endif
+
+
 	CWorld::Add(pVehicle);
 	if (carClass == COPS || carClass == COPS_BOAT)
 		CCarAI::AddPoliceCarOccupants(pVehicle);
diff --git a/src/control/Garages.cpp b/src/control/Garages.cpp
index 496410cf..88b0ba98 100644
--- a/src/control/Garages.cpp
+++ b/src/control/Garages.cpp
@@ -26,6 +26,10 @@
 #include "VarConsole.h"
 #include "SaveBuf.h"
 
+#ifdef VEHICLE_MODS // mod garage
+#include "debugmenu.h"
+#endif
+
 #define ROTATED_DOOR_OPEN_SPEED (0.015f)
 #define ROTATED_DOOR_CLOSE_SPEED (0.02f)
 #define DEFAULT_DOOR_OPEN_SPEED (0.035f)
@@ -67,6 +71,11 @@
 #define TIME_TO_CRUSH_CAR (3000)
 #define TIME_TO_PROCESS_KEEPCAR_GARAGE (2000)
 
+#ifdef VEHICLE_MODS // mod garage
+#define TIME_TO_ENTER_EXIT_INTO_MOD_GARAGE (1500)
+#endif
+
+
 // Respray stuff
 #define FREE_RESPRAY_HEALTH_THRESHOLD (970.0f)
 #define NUM_PARTICLES_IN_RESPRAY (200)
@@ -130,6 +139,14 @@ int32 hGarages = AEHANDLE_NONE;
 CGarage CGarages::aGarages[NUM_GARAGES];
 bool CGarages::bCamShouldBeOutisde;
 
+#ifdef VEHICLE_MODS // mod garage
+bool CGarages::bPlayerInModGarage;
+bool CGarages::bPlayerShouldBeLeaveModGarage;
+
+void DebugMenuPopulate(void);
+void VehicleModMenuPopulate(void);
+#endif
+
 #ifndef MASTER
 bool bPrintNearestObject;
 #endif
@@ -165,6 +182,35 @@ void CGarages::Init(void)
 	hGarages = DMAudio.CreateEntity(AUDIOTYPE_GARAGE, (void*)1);
 	if (hGarages >= 0)
 		DMAudio.SetEntityStatus(hGarages, TRUE);
+
+#ifdef VEHICLE_MODS // mod garage
+	if (bPlayerInModGarage) {
+		DebugMenuShutdown();
+		DebugMenuPopulate();
+	}
+	bPlayerInModGarage = false;
+	bPlayerShouldBeLeaveModGarage = false;
+	
+		/*AddOne(-7.55f, -1268.164f, 9.322f,
+			   -7.55f, -1276.632f, // depth
+			   2.64f, -1268.164f, 14.4f,
+			   GARAGE_MOD, 0);
+	
+		AddOne(-879.02f, -102.29f, 9.992f,
+			   -875.38f, -95.03f, // depth
+			   -869.66f, -107.04f, 15.58f,
+			   GARAGE_MOD, 0);
+	
+		AddOne(-901.501f, -1268.791f, 10.542f,
+			   -891.122f, -1265.274f, // depth
+			   -897.072f, -1258.488f, 17.467f,
+			   GARAGE_MOD, 0);
+	
+		AddOne(328.419f, 441.153f, 10.014f,
+			   325.326f, 450.675f, // depth
+			   318.205f, 444.41f, 16.657f,
+			   GARAGE_MOD, 0);*/
+	#endif
 }
 
 /// <summary>
@@ -216,6 +262,11 @@ void CGarages::Update(void)
 		aGarages[GarageToBeTidied].TidyUpGarageClose();
 	else
 		aGarages[GarageToBeTidied].TidyUpGarage();
+
+#ifdef VEHICLE_MODS
+	if (bPlayerInModGarage && (FindPlayerPed()->DyingOrDead() || FindPlayerPed()->m_pArrestingCop))
+		bPlayerShouldBeLeaveModGarage = true;
+#endif
 }
 
 /// <summary>
@@ -328,6 +379,11 @@ int16 CGarages::AddOne(float X1, float Y1, float Z1, float X2, float Y2, float X
 	case GARAGE_BOMBSHOP2:
 	case GARAGE_BOMBSHOP3:
 	case GARAGE_RESPRAY:
+
+#ifdef VEHICLE_MODS // mod garage
+	case GARAGE_MOD:
+#endif
+
 		pGarage->m_eGarageState = GS_OPENED;
 		pGarage->m_fDoorPos = pGarage->m_fDoorHeight;
 		break;
@@ -516,8 +572,22 @@ void CGarage::Update()
 						((CAutomobile*)(FindPlayerVehicle()))->m_fFireBlowUpTimer = 0.0f;
 						// This makes it to where the car doesn't get repaired when going in a safe house on here and gta 3.
 						((CAutomobile*)(FindPlayerVehicle()))->Fix();
+
+#ifdef VEHICLE_MODS // when mod garage is fully closed, fix lights
+						for (int32 i = 0; i < 4; i++)
+							((CAutomobile*)FindPlayerVehicle())->Damage.SetWheelStatus(i, WHEEL_STATUS_OK);
+
+						//for (int32 frameID = CAR_HEADLIGHT_L; frameID < NUM_CAR_NODES; frameID++)
+							//((CAutomobile*)FindPlayerVehicle())->SetFrameLightStatus((eCarNodes)frameID, LIGHT_STATUS_OK);
+#endif
+
 					}
 					else {
+#ifdef VEHICLE_MODS // when mod garage is fully closed, fix lights
+						for (int32 frameID = BIKE_HEADLIGHT_L; frameID < BIKE_NUM_NODES; frameID++)
+							((CBike*)FindPlayerVehicle())->SetFrameLightStatus((eBikeNodes)frameID, LIGHT_STATUS_OK);
+#endif
+
 						((CBike*)(FindPlayerVehicle()))->m_fFireBlowUpTimer = 0.0f;
 						((CBike*)(FindPlayerVehicle()))->Fix();
 					}
@@ -533,6 +603,25 @@ void CGarage::Update()
 #else
 					if (!((CAutomobile*)(FindPlayerVehicle()))->bFixedColour) {
 #endif
+
+#ifdef IMPROVED_VEHICLES // More colors
+						uint8 colour1, colour2, colour3, colour4;
+						uint16 attempt;
+						FindPlayerVehicle()->GetModelInfo()->ChooseVehicleColour(colour1, colour2, colour3, colour4);
+						for (attempt = 0; attempt < 10; attempt++) {
+							if (colour1 != FindPlayerVehicle()->m_currentColour1 || colour2 != FindPlayerVehicle()->m_currentColour2 ||
+								colour3 != FindPlayerVehicle()->m_currentColour3 || colour4 != FindPlayerVehicle()->m_currentColour4) {
+
+								break;
+							}
+							FindPlayerVehicle()->GetModelInfo()->ChooseVehicleColour(colour1, colour2, colour3, colour4);
+						}
+						bChangedColour = (attempt < 10);
+						FindPlayerVehicle()->m_currentColour1 = colour1;
+						FindPlayerVehicle()->m_currentColour2 = colour2;
+						FindPlayerVehicle()->m_currentColour3 = colour3;
+						FindPlayerVehicle()->m_currentColour4 = colour4;
+#else
 						uint8 colour1, colour2;
 						uint16 attempt;
 						FindPlayerVehicle()->GetModelInfo()->ChooseVehicleColour(colour1, colour2);
@@ -544,6 +633,15 @@ void CGarage::Update()
 						bChangedColour = (attempt < 10);
 						FindPlayerVehicle()->m_currentColour1 = colour1;
 						FindPlayerVehicle()->m_currentColour2 = colour2;
+#endif
+					
+#ifdef VEHICLE_MODS // Repainting also paints the spoiler
+						if (FindPlayerVehicle()->IsCar()) {
+							((CAutomobile*)FindPlayerVehicle())->m_nSpoilerColor = colour1;
+							((CAutomobile*)FindPlayerVehicle())->m_nTempSpoilerColor = colour1;
+						}
+#endif
+
 						if (bChangedColour) {
 							for (int i = 0; i < NUM_PARTICLES_IN_RESPRAY; i++) {
 								CVector pos;
@@ -1151,6 +1249,134 @@ void CGarage::Update()
 			break;
 		}
 		break;
+
+#ifdef VEHICLE_MODS // mod garage
+		case GARAGE_MOD:
+			switch (m_eGarageState) {
+			case GS_OPENED:
+				if (IsStaticPlayerCarEntirelyInside()) {
+					if (CountCarsWithCenterPointWithinGarage(FindPlayerVehicle()) > 0) {
+						CGarages::TriggerMessage("GA_22", -1, 4000, -1); // Just one car!
+						m_eGarageState = GS_OPENEDCONTAINSCAR;
+						DMAudio.PlayFrontEndSound(SOUND_GARAGE_BAD_VEHICLE, 1);
+					} else if (CGarages::IsCarModifiable(FindPlayerVehicle())) {
+						if (CWorld::Players[CWorld::PlayerInFocus].m_nMoney >= RESPRAY_PRICE || CGarages::RespraysAreFree) {
+							m_eGarageState = GS_CLOSING;
+							CPad::GetPad(0)->SetDisablePlayerControls(PLAYERCONTROL_GARAGE);
+							FindPlayerPed()->m_pWanted->m_bIgnoredByCops = true;
+						} else {
+							CGarages::TriggerMessage("GA_3", -1, 4000, -1); // No more freebies. $100 to respray!
+							m_eGarageState = GS_OPENEDCONTAINSCAR;
+							DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+						}
+					} else {
+						CGarages::TriggerMessage("GA_1", -1, 4000, -1); // Whoa! I don't touch nothing THAT hot!
+						m_eGarageState = GS_OPENEDCONTAINSCAR;
+						DMAudio.PlayFrontEndSound(SOUND_GARAGE_BAD_VEHICLE, 1);
+					}
+				}
+				if (FindPlayerVehicle()) {
+					if (CalcDistToGarageRectangleSquared(FindPlayerVehicle()->GetPosition().x, FindPlayerVehicle()->GetPosition().y) < SQR(DISTANCE_TO_ACTIVATE_GARAGE))
+						CWorld::CallOffChaseForArea(
+							m_fInfX - DISTANCE_TO_CALL_OFF_CHASE,
+							m_fInfY - DISTANCE_TO_CALL_OFF_CHASE,
+							m_fSupX + DISTANCE_TO_CALL_OFF_CHASE,
+							m_fSupY + DISTANCE_TO_CALL_OFF_CHASE);
+				}
+				break;
+			case GS_CLOSING:
+				if (FindPlayerVehicle())
+					ThrowCarsNearDoorOutOfGarage(FindPlayerVehicle());
+				m_fDoorPos = Max(0.0f, m_fDoorPos - (m_bRotatedDoor ? ROTATED_DOOR_CLOSE_SPEED : DEFAULT_DOOR_CLOSE_SPEED) * CTimer::GetTimeStep());
+				if (m_fDoorPos == 0.0f) {
+					m_eGarageState = GS_FULLYCLOSED;
+					m_nTimeToStartAction = CTimer::GetTimeInMilliseconds() + TIME_TO_ENTER_EXIT_INTO_MOD_GARAGE;
+					DMAudio.PlayOneShot(hGarages, SOUND_GARAGE_DOOR_CLOSED, 1.0f);
+					TheCamera.SetFadeColour(0, 0, 0);
+					TheCamera.Fade(1.0f, 0);
+					CStats::CheckPointReachedSuccessfully();
+				}
+				UpdateDoorsHeight();
+				if (FindPlayerVehicle() && FindPlayerVehicle()->IsCar())
+					((CAutomobile*)(FindPlayerVehicle()))->m_fFireBlowUpTimer = 0.0f;
+				CWorld::CallOffChaseForArea(
+					m_fInfX - DISTANCE_TO_CALL_OFF_CHASE,
+					m_fInfY - DISTANCE_TO_CALL_OFF_CHASE,
+					m_fSupX + DISTANCE_TO_CALL_OFF_CHASE,
+					m_fSupY + DISTANCE_TO_CALL_OFF_CHASE);
+	
+				break;
+			case GS_FULLYCLOSED: 
+			{
+				if (CTimer::GetTimeInMilliseconds() > m_nTimeToStartAction && !CGarages::bPlayerInModGarage && !CGarages::bPlayerShouldBeLeaveModGarage) {
+					TheCamera.Fade(1.0f, 1);
+	
+					CVehicle* veh = FindPlayerVehicle();
+	
+					if (veh->m_fHealth < 1000.0f)
+						CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - 100);
+	
+					veh->m_fHealth = 1000.0f;
+					if (veh->IsCar()) {
+						((CAutomobile*)(veh))->m_fFireBlowUpTimer = 0.0f;
+						((CAutomobile*)(veh))->Fix();
+	
+						for (int32 i = 0; i < 4; i++)
+							((CAutomobile*)veh)->Damage.SetWheelStatus(i, WHEEL_STATUS_OK);
+	
+						//for (int32 frameID = CAR_HEADLIGHT_L; frameID < NUM_CAR_NODES; frameID++)
+							//((CAutomobile*)veh)->SetFrameLightStatus((eCarNodes)frameID, LIGHT_STATUS_OK);
+					} else {
+						for (int32 frameID = BIKE_HEADLIGHT_L; frameID < BIKE_NUM_NODES; frameID++)
+							((CBike*)veh)->SetFrameLightStatus((eBikeNodes)frameID, LIGHT_STATUS_OK);
+	
+						((CBike*)(veh))->m_fFireBlowUpTimer = 0.0f;
+						((CBike*)(veh))->Fix();
+					}
+	
+					if (veh && (veh->IsCar() || veh->IsBike())) {
+						veh->SetHeading(m_pDoor1->GetRight().Heading() + DEGTORAD(180.0f));
+						CVector vehPos = m_pDoor1->GetPosition() + m_pDoor1->GetRight() * 5.0f;
+						veh->SetPosition(vehPos.x, vehPos.y, veh->GetPosition().z);
+					}
+	
+					CVector camPos = FindPlayerVehicle()->GetPosition();
+					CVector camOffset = FindPlayerVehicle()->GetForward() * 4.0f + FindPlayerVehicle()->GetRight() * 3.0f + FindPlayerVehicle()->GetUp() * 1.0f;
+					TheCamera.SetCamPositionForFixedMode(camPos + camOffset, CVector(0.0f, 0.0f, 0.0f));
+					TheCamera.TakeControl(FindPlayerVehicle(), CCam::MODE_FIXED, JUMP_CUT, CAMCONTROL_SCRIPT);
+	
+					CGarages::ActivateModGarage();
+				}
+	
+				if (CGarages::bPlayerShouldBeLeaveModGarage) {
+					m_eGarageState = GS_OPENING;
+					CGarages::LeaveModGarage();
+				}
+	
+				CWorld::CallOffChaseForArea(
+					m_fInfX - DISTANCE_TO_CALL_OFF_CHASE,
+					m_fInfY - DISTANCE_TO_CALL_OFF_CHASE,
+					m_fSupX + DISTANCE_TO_CALL_OFF_CHASE,
+					m_fSupY + DISTANCE_TO_CALL_OFF_CHASE);
+				break;
+			}
+			case GS_OPENING:
+				m_fDoorPos = Min(m_fDoorHeight, m_fDoorPos + (m_bRotatedDoor ? ROTATED_DOOR_OPEN_SPEED : DEFAULT_DOOR_OPEN_SPEED) * CTimer::GetTimeStep());
+				if (m_fDoorPos == m_fDoorHeight) {
+					m_eGarageState = GS_OPENEDCONTAINSCAR;
+					DMAudio.PlayOneShot(hGarages, SOUND_GARAGE_DOOR_OPENED, 1.0f);
+				}
+				UpdateDoorsHeight();
+				break;
+			case GS_OPENEDCONTAINSCAR:
+				if (IsPlayerOutsideGarage())
+					m_eGarageState = GS_OPENED;
+				break;
+			default:
+				break;
+			}
+			break;
+#endif
 	//case GARAGE_COLLECTORSITEMS:
 	//case GARAGE_60SECONDS:
 	case GARAGE_FOR_SCRIPT_TO_OPEN_FOR_CAR:
@@ -1631,6 +1857,116 @@ bool CGarages::IsCarSprayable(CVehicle * pVehicle)
 
 }
 
+#ifdef VEHICLE_MODS // mod garage
+bool CGarages::IsCarModifiable(CVehicle* pVehicle)
+{
+	if (pVehicle->IsRealHeli() || pVehicle->IsBoat())
+		return false;
+
+#ifdef EX_VCPD_WINTERGREEN
+	if (pVehicle->GetModelIndex() == MI_POLWINTERGREEN)
+		return false;
+#endif
+
+	switch (pVehicle->GetModelIndex()) {
+		case MI_FIRETRUCK:
+		case MI_AMBULAN:
+		case MI_POLICE:
+		case MI_ENFORCER:
+		case MI_BUS:
+		case MI_RHINO:
+		case MI_BARRACKS:
+		case MI_DODO:
+		case MI_COACH:
+		case MI_FBIRANCH:
+			return false;
+	}
+	return true;
+}
+
+bool CGarages::IsCarTintable(CVehicle* pVehicle)
+{
+	if (!IsCarModifiable(pVehicle))
+		return false;
+
+	switch (pVehicle->GetModelIndex()) {
+		case MI_CABBIE:
+		case MI_TOPFUN:
+		case MI_PONY:
+		case MI_GANGBUR:
+		case MI_MRWHOOP:
+		case MI_RUMPO:
+		case MI_SECURICA:
+		case MI_BENSON:
+		case MI_BOXVILLE:
+		case MI_MULE:
+		case MI_SPAND:
+		case MI_KAUFMAN:
+		case MI_BLOODRA:
+		case MI_BLOODRB:
+		case MI_HOTRINA:
+		case MI_HOTRINB:
+		case MI_HOTRING:
+		case MI_SANDKING:
+			return false;
+	}
+	return true;
+}
+
+void CGarages::TryChangeCameraInModGarage(const char* menuName)
+{
+	if (FindPlayerVehicle()->IsBike())
+		return;
+
+	if (strstr(menuName, "Window tint") || strstr(menuName, "Supercharger") || strstr(menuName, "Suspension") || strstr(menuName, "Paint") || strstr(menuName, "Exit")) {
+		CVector camPos = FindPlayerVehicle()->GetPosition();
+		CVector camOffset = FindPlayerVehicle()->GetForward() * 4.0f + FindPlayerVehicle()->GetRight() * 3.0f + FindPlayerVehicle()->GetUp() * 1.0f;
+		TheCamera.SetCamPositionForFixedMode(camPos + camOffset, CVector(0.0f, 0.0f, 0.0f));
+		TheCamera.TakeControl(FindPlayerVehicle(), CCam::MODE_FIXED, JUMP_CUT, CAMCONTROL_SCRIPT);
+	} else if (strstr(menuName, "Spoiler")) {
+		CVector camPos = FindPlayerVehicle()->GetPosition();
+		CVector camOffset = -FindPlayerVehicle()->GetRight() * 4.0f + FindPlayerVehicle()->GetUp() * 2.0f;
+		TheCamera.SetCamPositionForFixedMode(camPos + camOffset, CVector(0.0f, 0.0f, 0.0f));
+		TheCamera.TakeControl(FindPlayerVehicle(), CCam::MODE_FIXED, JUMP_CUT, CAMCONTROL_SCRIPT);
+	} else if (strstr(menuName, "Side skirts") || strstr(menuName, "Wheels")) {
+		CVector camPos = FindPlayerVehicle()->GetPosition();
+		CVector camOffset = FindPlayerVehicle()->GetForward() * 2.0f - FindPlayerVehicle()->GetRight() * 3.5f;
+		TheCamera.SetCamPositionForFixedMode(camPos + camOffset, CVector(0.0f, 0.0f, 0.0f));
+		TheCamera.TakeControl(FindPlayerVehicle(), CCam::MODE_FIXED, JUMP_CUT, CAMCONTROL_SCRIPT);
+	} else if (strstr(menuName, "Scoop") || strstr(menuName, "Vents")) {
+		CVector camPos = FindPlayerVehicle()->GetPosition();
+		CVector camOffset = FindPlayerVehicle()->GetForward() * 4.0f + FindPlayerVehicle()->GetUp() * 1.5f;
+		TheCamera.SetCamPositionForFixedMode(camPos + camOffset, CVector(0.0f, 0.0f, 0.0f));
+		TheCamera.TakeControl(FindPlayerVehicle(), CCam::MODE_FIXED, JUMP_CUT, CAMCONTROL_SCRIPT);
+	}
+}
+
+void CGarages::ActivateModGarage()
+{
+	CGarages::bPlayerInModGarage = true;
+
+	DebugMenuShutdown();
+	VehicleModMenuPopulate();
+	DebugMenuInit();
+}
+
+void CGarages::LeaveModGarage()
+{
+	CGarages::bPlayerInModGarage = false;
+	CGarages::bPlayerShouldBeLeaveModGarage = false;
+
+	CPad::GetPad(0)->SetEnablePlayerControls(PLAYERCONTROL_GARAGE);
+	FindPlayerPed()->m_pWanted->m_bIgnoredByCops = false;
+	FindPlayerVehicle()->m_nDoorLock = CARLOCK_UNLOCKED;
+
+	TheCamera.Restore();
+
+	DebugMenuShutdown();
+	DebugMenuPopulate();
+	DebugMenuInit();
+}
+#endif
+
 void CGarage::UpdateDoorsHeight()
 {
 	RefreshDoorPointers(false);
@@ -1673,6 +2009,12 @@ void CGarage::BuildRotatedDoorMatrix(CEntity * pDoor, float fPosition)
 void CGarage::UpdateCrusherAngle()
 {
 	RefreshDoorPointers(false);
+
+#ifdef VEHICLE_MODS // fix for crash while loading a save
+	if (!m_pDoor2)
+		return;
+#endif
+
 	m_pDoor2->GetMatrix().SetRotateXOnly(TWOPI - m_fDoorPos);
 	m_pDoor2->GetMatrix().UpdateRW();
 	m_pDoor2->UpdateRwFrame();
@@ -2130,15 +2472,42 @@ void CStoredCar::StoreCar(CVehicle* pVehicle)
 	m_vecAngle = pVehicle->GetForward();
 	m_nPrimaryColor = pVehicle->m_currentColour1;
 	m_nSecondaryColor = pVehicle->m_currentColour2;
+
+#ifdef IMPROVED_VEHICLES // More colors
+	m_nTertiaryColor = pVehicle->m_currentColour3;
+	m_nQuaternaryColor = pVehicle->m_currentColour4;
+#endif
+
 	m_nRadioStation = pVehicle->m_nRadioStation;
 	m_nVariationA = pVehicle->m_aExtras[0];
 	m_nVariationB = pVehicle->m_aExtras[1];
+
+#ifdef VEHICLE_MODS // Save/Load
+	m_nArmorLevel = pVehicle->m_nArmorLevel;
+	m_fAddEngineAcceleration = pVehicle->m_fAddEngineAcceleration;
+	if (pVehicle->IsCar()) {
+		m_nWindowTintLevel = ((CAutomobile*)pVehicle)->m_nWindowTintLevel;
+		m_nAddSuspensionForceLevel = ((CAutomobile*)pVehicle)->m_nAddSuspensionForceLevel;
+		m_nRimsColor = ((CAutomobile*)pVehicle)->m_nRimsColor;
+		m_nSpoilerColor = ((CAutomobile*)pVehicle)->m_nSpoilerColor;
+		m_fAddBrakeDeceleration = ((CAutomobile*)pVehicle)->m_fAddBrakeDeceleration;
+		for (int upgradeID = 0; upgradeID < NUM_UPGRADES; upgradeID++)
+			m_nUpgradeModelIndex[upgradeID] = ((CAutomobile*)pVehicle)->m_aUpgrades[upgradeID].m_nUpgradeModelIndex;
+	}
+#endif
+
 	m_nFlags = 0;
 	if (pVehicle->bBulletProof) m_nFlags |= FLAG_BULLETPROOF;
 	if (pVehicle->bFireProof) m_nFlags |= FLAG_FIREPROOF;
 	if (pVehicle->bExplosionProof) m_nFlags |= FLAG_EXPLOSIONPROOF;
 	if (pVehicle->bCollisionProof) m_nFlags |= FLAG_COLLISIONPROOF;
 	if (pVehicle->bMeleeProof) m_nFlags |= FLAG_MELEEPROOF;
+
+#ifdef VEHICLE_MODS // Save/Load
+	if (pVehicle->bTyresDontBurst) m_nFlags |= FLAG_BULLETPROOFTYRES;
+	if (pVehicle->IsCar() && ((CAutomobile*)pVehicle)->bHasHydraulics) m_nFlags |= FLAG_HYDRAULICS;
+#endif
+
 	if (pVehicle->IsCar() || pVehicle->IsBike())
 		m_nCarBombType = ((CAutomobile*)pVehicle)->m_bombType; // NB: cast to CAutomobile is original behaviour
 }
@@ -2179,7 +2548,42 @@ CVehicle* CStoredCar::RestoreCar()
 	pVehicle->pDriver = nil;
 	pVehicle->m_currentColour1 = m_nPrimaryColor;
 	pVehicle->m_currentColour2 = m_nSecondaryColor;
+
+#ifdef IMPROVED_VEHICLES // More colors
+	pVehicle->m_currentColour3 = m_nTertiaryColor;
+	pVehicle->m_currentColour4 = m_nQuaternaryColor;
+#endif
+
 	pVehicle->m_nRadioStation = m_nRadioStation;
+
+#if defined VEHICLE_MODS && defined IMPROVED_VEHICLES // Save/Load
+	pVehicle->m_nTempColor1 = m_nPrimaryColor;
+	pVehicle->m_nTempColor2 = m_nSecondaryColor;
+	pVehicle->m_nTempColor3 = m_nTertiaryColor;
+	pVehicle->m_nTempColor4 = m_nQuaternaryColor;
+	pVehicle->m_nArmorLevel = m_nArmorLevel;
+	pVehicle->m_fAddEngineAcceleration = m_fAddEngineAcceleration;
+	if (pVehicle->IsCar()) {
+		((CAutomobile*)pVehicle)->m_nWindowTintLevel = m_nWindowTintLevel;
+		((CAutomobile*)pVehicle)->m_nTempWindowTintLevel = m_nWindowTintLevel;
+		((CAutomobile*)pVehicle)->m_nAddSuspensionForceLevel = m_nAddSuspensionForceLevel;
+		((CAutomobile*)pVehicle)->m_nTempAddSuspensionForceLevel = m_nAddSuspensionForceLevel;
+		((CAutomobile*)pVehicle)->m_nRimsColor = m_nRimsColor;
+		((CAutomobile*)pVehicle)->m_nTempRimsColor = m_nRimsColor;
+		((CAutomobile*)pVehicle)->m_nSpoilerColor = m_nSpoilerColor;
+		((CAutomobile*)pVehicle)->m_nTempSpoilerColor = m_nSpoilerColor;
+		((CAutomobile*)pVehicle)->m_fAddBrakeDeceleration = m_fAddBrakeDeceleration;
+		for (int upgradeID = 0; upgradeID < NUM_UPGRADES; upgradeID++) {
+			((CAutomobile*)pVehicle)->m_aUpgrades[upgradeID].m_nUpgradeModelIndex = m_nUpgradeModelIndex[upgradeID];
+			((CAutomobile*)pVehicle)->m_aUpgrades[upgradeID].m_nTempUpgradeModelIndex = m_nUpgradeModelIndex[upgradeID];
+			if (upgradeID == UPGRADE_WHEELS)
+				((CAutomobile*)pVehicle)->SetWheels(m_nUpgradeModelIndex[upgradeID]);
+			else
+				((CAutomobile*)pVehicle)->SetUpgrade(m_nUpgradeModelIndex[upgradeID], false);
+		}
+	}
+#endif
+
 	pVehicle->bFreebies = false;
 	if (pVehicle->IsCar())
 	{
@@ -2196,6 +2600,12 @@ CVehicle* CStoredCar::RestoreCar()
 	if (m_nFlags & FLAG_EXPLOSIONPROOF) pVehicle->bExplosionProof = true;
 	if (m_nFlags & FLAG_COLLISIONPROOF) pVehicle->bCollisionProof = true;
 	if (m_nFlags & FLAG_MELEEPROOF) pVehicle->bMeleeProof = true;
+
+#ifdef VEHICLE_MODS // Save/Load
+	if (m_nFlags & FLAG_BULLETPROOFTYRES) pVehicle->bTyresDontBurst = true;
+	if (pVehicle->IsCar() && m_nFlags & FLAG_HYDRAULICS) ((CAutomobile*)pVehicle)->bHasHydraulics = true;
+#endif
+
 	return pVehicle;
 }
 
@@ -2435,6 +2845,11 @@ void CGarage::PlayerArrestedOrDied()
 	case GARAGE_BOMBSHOP3:
 	case GARAGE_RESPRAY:
 	case GARAGE_CRUSHER:
+
+#ifdef VEHICLE_MODS // mod garage
+	case GARAGE_MOD:
+#endif
+
 		switch (m_eGarageState) {
 		case GS_FULLYCLOSED:
 		case GS_CLOSING:
@@ -2616,8 +3031,13 @@ void CGarages::SetAllDoorsBackToOriginalHeight()
 void CGarages::Save(uint8 * buf, uint32 * size)
 {
 //INITSAVEBUF
+
+#ifdef VEHICLE_MODS // Save/Load
+	*size = (6 * sizeof(uint32) + TOTAL_COLLECTCARS_GARAGES * sizeof(*CarTypesCollected) + sizeof(uint32) + TOTAL_HIDEOUT_GARAGES * NUM_GARAGE_STORED_CARS * sizeof(CStoredCar) + NUM_GARAGES * sizeof(CGarage));
+#else
 	*size = 7876; // for some reason it's not actual size again
 	//*size = (6 * sizeof(uint32) + TOTAL_COLLECTCARS_GARAGES * sizeof(*CarTypesCollected) + sizeof(uint32) + TOTAL_HIDEOUT_GARAGES * NUM_GARAGE_STORED_CARS * sizeof(CStoredCar) + NUM_GARAGES * sizeof(CGarage));
+#endif
 #if !defined THIS_IS_STUPID && defined COMPATIBLE_SAVES
 	memset(buf + 7340, 0, *size - 7340); // garbage data is written otherwise
 #endif
@@ -2694,10 +3114,28 @@ const CStoredCar &CStoredCar::operator=(const CStoredCar & other)
 	m_nFlags = other.m_nFlags;
 	m_nPrimaryColor = other.m_nPrimaryColor;
 	m_nSecondaryColor = other.m_nSecondaryColor;
+
+#ifdef IMPROVED_VEHICLES // More colors
+	m_nTertiaryColor = other.m_nTertiaryColor;
+	m_nQuaternaryColor = other.m_nQuaternaryColor;
+#endif
+
 	m_nRadioStation = other.m_nRadioStation;
 	m_nVariationA = other.m_nVariationA;
 	m_nVariationB = other.m_nVariationB;
 	m_nCarBombType = other.m_nCarBombType;
+
+#ifdef VEHICLE_MODS // Save/Load
+	m_nWindowTintLevel = other.m_nWindowTintLevel;
+	m_nAddSuspensionForceLevel = other.m_nAddSuspensionForceLevel;
+	m_nRimsColor = other.m_nRimsColor;
+	m_nSpoilerColor = other.m_nSpoilerColor;
+	m_fAddEngineAcceleration = other.m_fAddEngineAcceleration;
+	m_fAddBrakeDeceleration = other.m_fAddBrakeDeceleration;
+	m_nArmorLevel = other.m_nArmorLevel;
+	for (int upgradeID = 0; upgradeID < NUM_UPGRADES; upgradeID++)
+		m_nUpgradeModelIndex[upgradeID] = other.m_nUpgradeModelIndex[upgradeID];
+#endif	
 	return *this;
 }
 
@@ -2709,8 +3147,12 @@ const CStoredCar &CStoredCar::operator=(const CStoredCar & other)
 void CGarages::Load(uint8* buf, uint32 size)
 {
 //INITSAVEBUF
+#ifdef VEHICLE_MODS // Save/Load
+	assert(size == (6 * sizeof(uint32) + TOTAL_COLLECTCARS_GARAGES * sizeof(*CarTypesCollected) + sizeof(uint32) + TOTAL_HIDEOUT_GARAGES * NUM_GARAGE_STORED_CARS * sizeof(CStoredCar) + NUM_GARAGES * sizeof(CGarage)));
+#else
 	assert(size == 7876);
 	//assert(size == (6 * sizeof(uint32) + TOTAL_COLLECTCARS_GARAGES * sizeof(*CarTypesCollected) + sizeof(uint32) + TOTAL_HIDEOUT_GARAGES * NUM_GARAGE_STORED_CARS * sizeof(CStoredCar) + NUM_GARAGES * sizeof(CGarage)));
+#endif
 	CloseHideOutGaragesBeforeSave();
 	ReadSaveBuf(&NumGarages, buf);
 	int32 tempInt;
diff --git a/src/control/Garages.h b/src/control/Garages.h
index 71081deb..00a49d8a 100644
--- a/src/control/Garages.h
+++ b/src/control/Garages.h
@@ -4,6 +4,10 @@
 #include "config.h"
 #include "Lists.h"
 
+#ifdef VEHICLE_MODS // Save/Load
+#include "Automobile.h"
+#endif
+
 class CVehicle;
 
 enum eGarageState
@@ -51,7 +55,10 @@ enum eGarageType
 	GARAGE_HIDEOUT_NINE,
 	GARAGE_HIDEOUT_TEN,
 	GARAGE_HIDEOUT_ELEVEN,
-	GARAGE_HIDEOUT_TWELVE
+	GARAGE_HIDEOUT_TWELVE,
+#ifdef VEHICLE_MODS // mod garage
+	GARAGE_MOD,
+#endif
 };
 
 enum
@@ -69,6 +76,11 @@ class CStoredCar
 		FLAG_EXPLOSIONPROOF = 0x4,
 		FLAG_COLLISIONPROOF = 0x8,
 		FLAG_MELEEPROOF = 0x10,
+
+#ifdef VEHICLE_MODS // Save/Load
+		FLAG_BULLETPROOFTYRES = 0x20,
+		FLAG_HYDRAULICS = 0x40,
+#endif
 	};
 	int32 m_nModelIndex;
 	CVector m_vecPos;
@@ -76,10 +88,27 @@ class CStoredCar
 	int32 m_nFlags;
 	int8 m_nPrimaryColor;
 	int8 m_nSecondaryColor;
+
+#ifdef IMPROVED_VEHICLES // More colors
+	int8 m_nTertiaryColor;
+	int8 m_nQuaternaryColor;
+#endif
 	int8 m_nRadioStation;
 	int8 m_nVariationA;
 	int8 m_nVariationB;
 	int8 m_nCarBombType;
+
+#ifdef VEHICLE_MODS // Save/Load
+	uint8 m_nWindowTintLevel;
+	uint8 m_nAddSuspensionForceLevel;
+	uint16 m_nUpgradeModelIndex[NUM_UPGRADES];
+	uint8 m_nRimsColor;
+	uint8 m_nSpoilerColor;
+	float m_fAddEngineAcceleration;
+	float m_fAddBrakeDeceleration;
+	int m_nArmorLevel;
+#endif
+
 public:
 	void Init() { m_nModelIndex = 0; }
 	void Clear() { m_nModelIndex = 0; }
@@ -231,6 +260,11 @@ public:
 	static CStoredCar aCarsInSafeHouses[TOTAL_HIDEOUT_GARAGES][NUM_GARAGE_STORED_CARS];
 	static bool bCamShouldBeOutisde;
 
+#ifdef VEHICLE_MODS // mod garage
+	static bool bPlayerInModGarage;
+	static bool bPlayerShouldBeLeaveModGarage;
+#endif
+
 	static void Init(void);
 #ifndef PS2
 	static void Shutdown(void);
@@ -273,6 +307,15 @@ public:
 	static void SetMaxNumStoredCarsForGarage(int16 garage, uint8 num) { aGarages[garage].m_nMaxStoredCars = num; }
 
 	static bool IsCarSprayable(CVehicle*);
+
+#ifdef VEHICLE_MODS // mod garage
+	static void ActivateModGarage();
+	static void LeaveModGarage();
+	static bool IsCarModifiable(CVehicle* pVehicle);
+	static bool IsCarTintable(CVehicle* pVehicle);
+	static void TryChangeCameraInModGarage(const char* menuName);
+#endif
+
 	static float FindDoorHeightForMI(int32);
 	static void CloseHideOutGaragesBeforeSave(void);
 	static int32 CountCarsInHideoutGarage(uint8);
diff --git a/src/control/Replay.cpp b/src/control/Replay.cpp
index 71b28f7a..4e0a8304 100644
--- a/src/control/Replay.cpp
+++ b/src/control/Replay.cpp
@@ -758,6 +758,12 @@ void CReplay::StoreCarUpdate(CVehicle *vehicle, int id)
 	vp->mi = vehicle->GetModelIndex();
 	vp->primary_color = vehicle->m_currentColour1;
 	vp->secondary_color = vehicle->m_currentColour2;
+
+#ifdef IMPROVED_VEHICLES // More colors
+	vp->tertiary_color = vehicle->m_currentColour3;
+	vp->quaternary_color = vehicle->m_currentColour4;
+#endif
+
 	if (vehicle->GetModelIndex() == MI_RHINO)
 		vp->car_gun = 128.0f / PI * ((CAutomobile*)vehicle)->m_fCarGunLR;
 	else
@@ -1001,6 +1007,12 @@ bool CReplay::PlayBackThisFrameInterpolation(CAddressInReplayBuffer *buffer, flo
 					vp->matrix.DecompressIntoFullMatrix(new_v->GetMatrix());
 					new_v->m_currentColour1 = vp->primary_color;
 					new_v->m_currentColour2 = vp->secondary_color;
+
+#ifdef IMPROVED_VEHICLES // More colors
+					new_v->m_currentColour3 = vp->tertiary_color;
+					new_v->m_currentColour4 = vp->quaternary_color;
+#endif
+
 					CWorld::Add(new_v);
 				}
 			}
diff --git a/src/control/Replay.h b/src/control/Replay.h
index 5dd8b651..4b8de297 100644
--- a/src/control/Replay.h
+++ b/src/control/Replay.h
@@ -211,8 +211,14 @@ class CReplay
 		uint8 wheel_susp_dist[4];
 		uint8 wheel_rotation[4];
 		uint8 door_status;
+
 		uint8 primary_color;
 		uint8 secondary_color;
+#ifdef IMPROVED_VEHICLES // More colors
+		uint8 tertiary_color;
+		uint8 quaternary_color;
+#endif
+
 		bool render_scorched;
 		int8 skimmer_speed;
 		int8 vehicle_type;
diff --git a/src/control/Script.cpp b/src/control/Script.cpp
index 3cb45e36..8ed7ea7f 100644
--- a/src/control/Script.cpp
+++ b/src/control/Script.cpp
@@ -2534,6 +2534,12 @@ int8 CRunningScript::ProcessCommands100To199(int32 command)
 			car->bHasBeenOwnedByPlayer = true;
 			if (m_bIsMissionScript)
 				car->bIsStaticWaitingForCollision = true;
+
+#ifdef VEHICLE_MODS // TrySetRandomCarMod for racing vehicles
+			if (missionRetryScriptIndex == 82 && car->IsCar())
+				((CAutomobile*)car)->TrySetRandomCarMod(true);
+#endif
+
 			CWorld::Add(car);
 			handle = CPools::GetVehiclePool()->GetIndex(car);
 		}
diff --git a/src/core/Cam.cpp b/src/core/Cam.cpp
index 1462c67a..a460a891 100644
--- a/src/core/Cam.cpp
+++ b/src/core/Cam.cpp
@@ -6021,8 +6021,15 @@ CCam::Process_FollowCar_SA(const CVector& CameraTarget, float TargetOrientation,
 #endif
 
 	bool correctAlpha = true;
+
+
+#ifdef VEHICLE_MODS // hydraulics
+	if (!isCar || !((CAutomobile*)car)->bHasHydraulics) {
+#else
 	//	if (SA checks if we aren't in work car, why?) {
 	if (!isCar || car->GetModelIndex() != MI_VOODOO) {
+#endif
+
 		correctAlpha = false;
 	}
 	else {
diff --git a/src/core/Camera.cpp b/src/core/Camera.cpp
index d073dcf1..8c497465 100644
--- a/src/core/Camera.cpp
+++ b/src/core/Camera.cpp
@@ -1105,15 +1105,40 @@ CCamera::CamControl(void)
 			   (m_bLookingAtPlayer || WhoIsInControlOfTheCamera == CAMCONTROL_OBBE) &&
 			   !m_WideScreenOn && !m_bFailedCullZoneTestPreviously && !m_bFirstPersonBeingUsed){
 
-				if(FrontEndMenuManager.m_ControlMethod == CONTROL_STANDARD){
 
-					if(PedZoomIndicator == CAM_ZOOM_3)
+				//
+#if defined FIRST_PERSON && defined IMPROVED_MENU_AND_INPUT
+				if (PedZoomIndicator == CAM_ZOOM_3) {
+					PedZoomIndicator = CAM_ZOOM_REAL_1ST_PERSON;
+					CarZoomIndicator = CAM_ZOOM_REAL_1ST_PERSON;
+				} else if (PedZoomIndicator == CAM_ZOOM_1) {
+					PedZoomIndicator = CAM_ZOOM_2;
+					CarZoomIndicator = CAM_ZOOM_2;
+				} else if (PedZoomIndicator == CAM_ZOOM_2) {
+					PedZoomIndicator = CAM_ZOOM_3;
+					CarZoomIndicator = CAM_ZOOM_2;
+				} else {
+					PedZoomIndicator = CAM_ZOOM_1;
+					CarZoomIndicator = CAM_ZOOM_2;
+				}
+#else
+				if (FrontEndMenuManager.m_ControlMethod == CONTROL_STANDARD) {
+					if (PedZoomIndicator == CAM_ZOOM_3)
 						PedZoomIndicator = CAM_ZOOM_1;
 					else
 						PedZoomIndicator = CAM_ZOOM_3;
 				}else
 					PedZoomIndicator++;
+#endif
+
+#ifdef FIRST_PERSON
+				if (PedZoomIndicator == CAM_ZOOM_REAL_1ST_PERSON) {
+					ReqMode = CCam::MODE_REAL_1ST_PERSON;
+				}
+#endif
 			}
+
+			//
 			// disabled top down and obbe's cam here
 			if(PedZoomIndicator < CAM_ZOOM_1) PedZoomIndicator = CAM_ZOOM_3;
 
diff --git a/src/core/ControllerConfig.cpp b/src/core/ControllerConfig.cpp
index 0db70841..69444ee5 100644
--- a/src/core/ControllerConfig.cpp
+++ b/src/core/ControllerConfig.cpp
@@ -2035,6 +2035,12 @@ void CControllerConfigManager::DeleteMatchingVehicleControls(e_ControllerAction
 		CLEAR_ACTION_IF_NEEDED(VEHICLE_TURRETRIGHT);
 		CLEAR_ACTION_IF_NEEDED(VEHICLE_TURRETUP);
 		CLEAR_ACTION_IF_NEEDED(VEHICLE_TURRETDOWN);
+
+#if defined IMPROVED_MENU_AND_INPUT && defined IMPROVED_VEHICLES_2 // Turn and emergency signals for player
+		CLEAR_ACTION_IF_NEEDED(VEHICLE_LEFT_TURNSIGNALS);
+		CLEAR_ACTION_IF_NEEDED(VEHICLE_RIGHT_TURNSIGNALS);
+		CLEAR_ACTION_IF_NEEDED(VEHICLE_EMERGENCYLIGHTS);
+#endif
 	}
 }
 
diff --git a/src/core/FileLoader.cpp b/src/core/FileLoader.cpp
index ef0f402d..3e931c7d 100644
--- a/src/core/FileLoader.cpp
+++ b/src/core/FileLoader.cpp
@@ -135,7 +135,14 @@ CFileLoader::LoadLevel(const char *filename)
 			if(!objectsLoaded){
 				LoadingScreenLoadingFile("Collision");
 				PUSH_MEMID(MEMID_WORLD);
+
+
+				// TODO Do some more testing on this one.
+#ifdef VICE_EXTENDED
+				CObjectData::Initialise("ViceExtended\\DATA\\OBJECT.DAT");
+#else
 				CObjectData::Initialise("DATA\\OBJECT.DAT");
+#endif //VICE_EXTENDED
 				CStreaming::Init();
 				POP_MEMID();
 				PUSH_MEMID(MEMID_COLLISION);
@@ -851,14 +858,29 @@ CFileLoader::LoadWeaponObject(const char *line)
 	float dist;
 	CWeaponModelInfo *mi;
 
+#ifdef EX_IMPROVED_WEAPONS
+	char animForWeaponFile[16];
+
+	sscanf(line, "%d %s %s %s %d %f %s", &id, model, txd, animFile, &numObjs, &dist, animForWeaponFile);
+#else
 	sscanf(line, "%d %s %s %s %d %f", &id, model, txd, animFile, &numObjs, &dist);
+#endif
+
+
 
 	mi = CModelInfo::AddWeaponModel(id);
 	mi->SetModelName(model);
+
+
 	mi->SetNumAtomics(1);
 	mi->m_lodDistances[0] = dist;
 	mi->SetTexDictionary(txd);
 	mi->SetAnimFile(animFile);
+
+#ifdef EX_IMPROVED_WEAPONS
+	mi->SetAnimForWeaponFile(animForWeaponFile);
+#endif
+	
 	mi->SetColModel(&CTempColModels::ms_colModelWeapon);
 	MatchModelString(model, id);
 	return id;
@@ -1416,10 +1438,20 @@ CFileLoader::ReloadObjectTypes(const char *filename)
 	CModelInfo::ReInit2dEffects();
 	debug("Reloading object types from %s...\n", filename);
 
+	// TODO Change this to load from ViceExtended\\DATA\\MAPS
+	// It crashes if I try to move the files in there.
+//#ifdef VICE_EXTENDED
+//	CFileMgr::ChangeDir("ViceExtended\\DATA\\MAPS\\");
+//#else
 	CFileMgr::ChangeDir("\\DATA\\MAPS\\");
+//#endif // VICE_EXTENDED
+	
 	int fd = CFileMgr::OpenFile(filename, "r");
 	assert(fd > 0);
+
+	//#ifndef VICE_EXTENDED
 	CFileMgr::ChangeDir("\\");
+//#endif
 	for (line = CFileLoader::LoadLine(fd); line; line = CFileLoader::LoadLine(fd)) {
 		if (*line == '\0' || *line == '#')
 			continue;
diff --git a/src/core/MenuScreensCustom.cpp b/src/core/MenuScreensCustom.cpp
index 969d8468..ad4ec3e0 100644
--- a/src/core/MenuScreensCustom.cpp
+++ b/src/core/MenuScreensCustom.cpp
@@ -677,9 +677,14 @@ CMenuScreenCustom aScreens[] = {
 #else
 		MENUACTION_KEYBOARDCTRLS,"FEC_RED", {nil, SAVESLOT_NONE, MENUPAGE_KEYBOARD_CONTROLS}, 320, 150, MENUALIGN_CENTER,
 #endif
-#ifdef GAMEPAD_MENU
+#if defined GAMEPAD_MENU && defined IMPROVED_MENU_AND_INPUT
+		MENUACTION_CHANGEMENU,	"FET_AGS", {nil, SAVESLOT_NONE, MENUPAGE_GAMEPAD_SETTINGS}, 0, 0, MENUALIGN_CENTER,
+		MENUACTION_CHANGEMENU,	"FET_AGC", {nil, SAVESLOT_NONE, MENUPAGE_CONTROLLER_SETTINGS}, 0, 0, MENUALIGN_CENTER,
+#elif defined GAMEPAD_MENU
 		MENUACTION_CHANGEMENU,	"FET_AGS", {nil, SAVESLOT_NONE, MENUPAGE_CONTROLLER_SETTINGS}, 0, 0, MENUALIGN_CENTER,
 #endif
+
+
 #ifdef DETECT_JOYSTICK_MENU
 		MENUACTION_CHANGEMENU,	"FEC_JOD", {nil, SAVESLOT_NONE, MENUPAGE_DETECT_JOYSTICK}, 0, 0, MENUALIGN_CENTER,
 #endif
diff --git a/src/core/Pad.cpp b/src/core/Pad.cpp
index 4e49dff3..1b1b9094 100644
--- a/src/core/Pad.cpp
+++ b/src/core/Pad.cpp
@@ -42,6 +42,10 @@
 #include "CarCtrl.h"
 #include "TrafficLights.h"
 
+#ifdef IMPROVED_VEHICLES
+#include "Bike.h"
+#endif
+
 #include "PlayerInfo.h"
 #include "Placeable.h"
 #include "Entity.h"
@@ -340,11 +344,31 @@ void HealthCheat()
 	FindPlayerPed()->m_fHealth = CWorld::Players[0].m_nMaxHealth;
 	if (FindPlayerVehicle()) {
 		FindPlayerVehicle()->m_fHealth = 1000.0f;
+
+#ifdef IMPROVED_VEHICLES // health cheat
 		if (FindPlayerVehicle()->m_vehType == VEHICLE_TYPE_CAR) {
+			((CAutomobile*)FindPlayerVehicle())->Fix();
 			((CAutomobile*)FindPlayerVehicle())->Damage.SetEngineStatus(0);
 			for (int32 i = 0; i < 4; i++)
 				((CAutomobile*)FindPlayerVehicle())->Damage.SetWheelStatus(i, WHEEL_STATUS_OK);
+
+			//for (int32 frameID = CAR_HEADLIGHT_L; frameID < NUM_CAR_NODES; frameID++)
+				//((CAutomobile*)FindPlayerVehicle())->SetFrameLightStatus((eCarNodes)frameID, LIGHT_STATUS_OK);
+
+		} else if (FindPlayerVehicle()->m_vehType == VEHICLE_TYPE_BIKE) {
+			((CBike*)FindPlayerVehicle())->Fix();
+
+			for (int32 frameID = BIKE_HEADLIGHT_L; frameID < BIKE_NUM_NODES; frameID++)
+				((CBike*)FindPlayerVehicle())->SetFrameLightStatus((eBikeNodes)frameID, LIGHT_STATUS_OK);
 		}
+#else
+		if (FindPlayerVehicle()->m_vehType == VEHICLE_TYPE_CAR) {
+			((CAutomobile*)FindPlayerVehicle())->Damage.SetEngineStatus(0);
+			for (int32 i = 0; i < 4; i++)
+				((CAutomobile*)FindPlayerVehicle())->Damage.SetWheelStatus(i, WHEEL_STATUS_OK);
+		}
+#endif
+
 	}
 }
 
@@ -3757,6 +3781,34 @@ bool CPad::GetTarget(void)
 
 	switch (CURMODE)
 	{
+
+#if defined IMPROVED_MENU_AND_INPUT && defined FIRING_AND_AIMING
+		case 0:
+		case 2:
+		{
+			if (FindPlayerVehicle()) {
+				if (IsAffectedByController)
+					return !!NewState.LeftShoulder2;
+				else
+					return !!NewState.DPadDown;
+			}
+
+			return !!NewState.RightShoulder1;
+
+			break;
+		}
+
+		case 1:
+		case 3:
+		{
+			if (IsAffectedByController && FindPlayerVehicle())
+				return !!NewState.LeftShoulder1;
+
+			return !!NewState.LeftShoulder2;
+
+			break;
+		}
+#else
 		case 0:
 		case 1:
 		case 2:
@@ -3772,6 +3824,9 @@ bool CPad::GetTarget(void)
 
 			break;
 		}
+#endif
+
+
 	}
 
 	return false;
diff --git a/src/core/Pad.h b/src/core/Pad.h
index c4cd81c7..b8aab6a9 100644
--- a/src/core/Pad.h
+++ b/src/core/Pad.h
@@ -284,6 +284,14 @@ public:
 	bool ChangeStationJustDown(void);
 #endif
 
+#if defined IMPROVED_MENU_AND_INPUT && defined IMPROVED_VEHICLES_2 // Turn and emergency signals for player
+	bool LeftTurnSignalsJustDown();
+	bool RightTurnSignalsJustDown();
+	bool EmergencyLightsJustDown();
+#endif
+
+
+
 	bool CycleWeaponLeftJustDown(void);
 	bool CycleWeaponRightJustDown(void);
 	bool GetTarget(void);
diff --git a/src/core/Pools.cpp b/src/core/Pools.cpp
index e601b3c8..f596f508 100644
--- a/src/core/Pools.cpp
+++ b/src/core/Pools.cpp
@@ -204,6 +204,12 @@ INITSAVEBUF
 		pVehicle->VehicleCreatedBy = pBufferVehicle->VehicleCreatedBy;
 		pVehicle->m_currentColour1 = pBufferVehicle->m_currentColour1;
 		pVehicle->m_currentColour2 = pBufferVehicle->m_currentColour2;
+
+#ifdef IMPROVED_VEHICLES // More colors
+		pVehicle->m_currentColour3 = pBufferVehicle->m_currentColour3;
+		pVehicle->m_currentColour4 = pBufferVehicle->m_currentColour4;
+#endif
+
 		pVehicle->m_nAlarmState = pBufferVehicle->m_nAlarmState;
 		pVehicle->m_nNumMaxPassengers = pBufferVehicle->m_nNumMaxPassengers;
 		pVehicle->field_1D0[0] = pBufferVehicle->field_1D0[0];
diff --git a/src/core/Streaming.cpp b/src/core/Streaming.cpp
index 6b833611..c2f350e2 100644
--- a/src/core/Streaming.cpp
+++ b/src/core/Streaming.cpp
@@ -1523,6 +1523,15 @@ CStreaming::RemoveAllUnusedModels(void)
 		RemoveLoadedVehicle();
 
 	for(i = NUM_DEFAULT_MODELS; i < MODELINFOSIZE; i++){
+#ifdef VEHICLE_MODS // for new wheels and vehicle mods
+		if (i >= MI_FIRST_NEW_WHEEL && i <= NUM_NEW_WHEEL_MODELS)
+			continue;
+
+		if (i >= MI_FIRST_VEH_MOD && i <= NUM_VEH_MODS)
+			continue;
+#endif
+
+
 		if(ms_aInfoForModel[i].m_loadState == STREAMSTATE_LOADED &&
 		    CModelInfo::GetModelInfo(i)->GetNumRefs() == 0) {
 			RemoveModel(i);
diff --git a/src/core/common.h b/src/core/common.h
index bbedc282..d91fef42 100644
--- a/src/core/common.h
+++ b/src/core/common.h
@@ -342,6 +342,33 @@ float InterpFloat(float currentValue, float newValue, float interpSpeed);
 CVector InterpVector(CVector currentValue, CVector newValue, float interpSpeed);
 #endif
 
+// #ifdef VICE_EXTENDED // Game limits
+// extern uint16 NUMPTRNODES;
+// extern uint16 NUMENTRYINFOS;
+// extern uint16 NUMPEDS;
+// extern uint16 NUMVEHICLES;
+// extern uint16 NUMBUILDINGS;
+// extern uint16 NUMTREADABLES;
+// extern uint16 NUMOBJECTS;
+// extern uint16 NUMDUMMIES;
+// extern uint16 NUMAUDIOSCRIPTOBJECTS;
+// extern uint16 NUMCOLMODELS;
+// extern uint16 MAXWHEELMODELS;
+// #endif
+
+#ifdef FEATURES_INI
+extern bool bVehiclesDontCatchFireWhenTurningOver;
+extern bool bHealthRegenerationUpToHalf;
+extern bool bWantedStarsHideOnScreenWhenThereIsNoSearch;
+extern bool bRemoveMoneyZerosInTheHud;
+extern bool bPlayerDoesntBounceAwayFromMovingCar;
+extern bool bStandardCarsUseTurnSignals;
+extern bool bCameraShakeInVehicleAtHighSpeed;
+extern bool bMilitaryFiringFromTankAtPlayer;
+extern bool bDisableBulletTraces;
+extern CRGBA WaypointColor;
+#endif
+
 #ifdef CLIMBING
 extern bool bEnableClimbing;
 #endif
diff --git a/src/core/config.h b/src/core/config.h
index eafb881b..f483c59e 100644
--- a/src/core/config.h
+++ b/src/core/config.h
@@ -106,6 +106,16 @@
 // Copied in changes from this define
 #define IMPROVED_MENU_AND_INPUT
 
+// Copied in changes from these three defines, they don't work so I disabled all this for now.
+// #define VEHICLE_MODS
+// #define IMPROVED_VEHICLES
+// #define IMPROVED_VEHICLES_2
+
+// Add this in for some of the new ini features from Extended Vice.
+// #define FEATURES_INI
+
+// #define NEW_VEHICLE_LOADER
+
 // It seems to build with this now.
 // TODO Fix this to work, it shows in the menu but doesn't seem to change the weapon sights.
 // This almost works, I think I'm missing the texture somewhere.
@@ -137,7 +147,6 @@
 //#define MODLOADER
 
 
-
 // TODO Implement these
 // #define EX_PED_ANIMS_IN_CAR
 // #define EX_DISPLAYED_COLLECTIBLES
@@ -154,13 +163,7 @@
 	#define IMPROVED_TECH_PART
 	#define WANTED_PATHS
 
-	#define VEHICLE_MODS
-	#define IMPROVED_VEHICLES
-	#define IMPROVED_VEHICLES_2
-	#define NEW_VEHICLE_LOADER
-
 	#define TRIANGLE_FOR_MOUSE_RECRUIT
-	#define IMPROVED_MENU_AND_INPUT
 
 	#define EX_EXPERIMENTAL
 	#define EX_SECOND_SAMPLE_BANK // ViceEx.RAW and ViceEx.SDT
@@ -332,164 +335,17 @@
 
 */
 
-// #ifdef VICE_EXTENDED
-// // Implement the raised limits from Vice Extended.
-// // This should possibly fix the rocket launcher animations in 3rd person
-// enum Config {
-// 	NUMPLAYERS = 1,
-
-// 	NUMCDIMAGES = 6,   // gta3.img duplicates (not used on PC)
-// 	MAX_CDIMAGES = 32, // additional cdimages
-// 	MAX_CDCHANNELS = 5,
-
-// 	MODELINFOSIZE = 10000,
-// 	TXDSTORESIZE = 1485,
-// 	COLSTORESIZE = 100,
-// 	EXTRADIRSIZE = 512,
-// 	CUTSCENEDIRSIZE = 512,
-
-// 	SIMPLEMODELSIZE = 10000,
-// 	TIMEMODELSIZE = 10000,
-// 	CLUMPMODELSIZE = 100,
-// 	WEAPONMODELSIZE = 77,
-// 	PEDMODELSIZE = 130,
-// 	VEHICLEMODELSIZE = 210,
-// 	TWODFXSIZE = 3000,
-
-// 	MAXVEHICLESLOADED = 50, // 70 on mobile
-
-// 	NUMOBJECTINFO = 210,
-
-// 	NUMCUTSCENEOBJECTS = 50, // not a pool in VC
-
-// 	NUMANIMBLOCKS = 40,
-// 	NUMANIMATIONS = 500,
-
-// 	NUMTEMPOBJECTS = 40,
-
-// 	// Path data
-// 	NUM_PATHNODES = 9650,
-// 	NUM_CARPATHLINKS = 3500,
-// 	NUM_MAPOBJECTS = 1250,
-// 	NUM_PATHCONNECTIONS = 20400,
-// 	NUM_WANTEDPATHNODES = 20,
-// 	NUM_WANTEDPATHS = 100,
-
-// 	// Link list lengths
-// 	NUMALPHALIST = 20,
-// 	NUMBOATALPHALIST = 20,
-// 	NUMALPHAENTITYLIST = 2000,
-// 	NUMALPHAUNTERWATERENTITYLIST = 30,
-// 	NUMCOLCACHELINKS = 50,
-// 	NUMREFERENCES = 800,
-
-// 	// Zones
-// 	NUMAUDIOZONES = 14,
-// 	NUMINFOZONES = 169,
-// 	NUMMAPZONES = 39,
-// 	NUMNAVIGZONES = 20,
-
-// 	// Cull zones
-// 	NUMATTRIBZONES = 704,
-
-// 	NUMOCCLUSIONVOLUMES = 350,
-// 	NUMACTIVEOCCLUDERS = 48,
-
-// 	PATHNODESIZE = 4500,
-
-// 	NUMWEATHERS = 7,
-// 	NUMHOURS = 24,
-
-// 	NUMEXTRADIRECTIONALS = 4,
-// 	NUMANTENNAS = 8,
-// 	NUMCORONAS = 2000,
-// 	NUMPOINTLIGHTS = 32,
-// 	NUM3DMARKERS = 32,
-// 	NUMBRIGHTLIGHTS = 32,
-// 	NUMSHINYTEXTS = 32,
-// 	NUMMONEYMESSAGES = 16,
-// 	NUMPICKUPMESSAGES = 16,
-// 	NUMBULLETTRACES = 16,
-// 	NUMMBLURSTREAKS = 4,
-// 	NUMSKIDMARKS = 32,
-
-// 	NUMONSCREENCLOCKS = 1,
-// 	NUMONSCREENCOUNTERS = 3,
-// 	NUMRADARBLIPS = 300,
-// 	NUMGENERALPICKUPS = 320,
-// 	NUMSCRIPTEDPICKUPS = 100,
-// 	NUMPICKUPS = NUMGENERALPICKUPS + NUMSCRIPTEDPICKUPS,
-// 	NUMCOLLECTEDPICKUPS = 100,
-// 	NUMPACMANPICKUPS = 256,
-// 	NUMEVENTS = 64,
-
-// 	NUM_CARGENS = 185,
-
-// 	NUM_PATH_NODES_IN_AUTOPILOT = 8,
-
-// 	NUM_ACCIDENTS = 20,
-// 	NUM_FIRES = 40,
-// 	NUM_GARAGES = 35,
-// 	NUM_PROJECTILES = 32,
-
-// 	NUM_GLASSPANES = 45,
-// 	NUM_GLASSENTITIES = 32,
-// 	NUM_WATERCANNONS = 3,
-
-// 	NUMPEDROUTES = 200,
-// 	NUMPHONES = 50,
-// 	NUMPEDGROUPS = 67,
-// 	NUMMODELSPERPEDGROUP = 16,
-// 	MAXZONEPEDSLOADED = 8,
-// 	NUMSHOTINFOS = 100,
-
-// 	NUMROADBLOCKS = 300,
-// 	NUM_SCRIPT_ROADBLOCKS = 16,
-
-// 	NUMVISIBLEENTITIES = 2000,
-// 	NUMINVISIBLEENTITIES = 150,
-
-// 	NUM_AUDIOENTITY_EVENTS = 4,
-// 	NUM_PED_COMMENTS_SLOTS = 20,
-
-// 	NUM_SOUND_QUEUES = 2,
-// 	NUM_AUDIOENTITIES = 250,
-
-// 	NUM_SCRIPT_MAX_ENTITIES = 40,
-
-// 	NUM_GARAGE_STORED_CARS = 4,
-
-// 	NUM_CRANES = 8,
-// 	NUM_ESCALATORS = 22,
-// 	NUM_WATER_CREATURES = 8,
-
-// 	NUM_EXPLOSIONS = 48,
-
-// 	NUM_SETPIECES = 96,
-// 	NUM_SHORTCUT_START_POINTS = 16,
-
-// 	// Pool sizes
-// 	NUMPTRNODES = 50000,
-// 	NUMBUILDINGS = 7000,
-// 	NUMAUDIOSCRIPTOBJECTS = 192,
-// 	NUMCOLMODELS = 4400,
-// 	NUMDUMMIES = 2340,
-// 	NUMENTRYINFOS = 3200,
-// 	NUMOBJECTS = 460,
-// 	NUMPEDS = 140,
-
-// 	NUMTREADABLES = 1,
-// 	NUMVEHICLES = 110,
-
-
-// };
-// #else
 enum Config {
 	NUMPLAYERS = 1,
 
 	NUMCDIMAGES = 6,  // gta3.img duplicates (not used on PC)
 	MAX_CDIMAGES = 8, // additional cdimages
 	MAX_CDCHANNELS = 5,
+	
+	// New
+#ifdef VICE_EXTENDED
+	MAX_WHEELMODELS = 12,
+#endif
 
 	MODELINFOSIZE = 6500, // 4900 on PS2
 	TXDSTORESIZE = 1385,
diff --git a/src/core/re3.cpp b/src/core/re3.cpp
index 8b58d68d..3c94181f 100644
--- a/src/core/re3.cpp
+++ b/src/core/re3.cpp
@@ -63,6 +63,13 @@
 #include "Garages.h"
 #include "custom_cheats.h"
 
+#ifdef VEHICLE_MODS // mod garage
+#include "DMAudio.h"
+#include "Garages.h"
+#include "Wanted.h"
+#include "Messages.h"
+#endif
+
 #ifdef RWLIBS
 extern "C" int vsprintf(char* const _Buffer, char const* const _Format, va_list  _ArgList);
 #endif
diff --git a/src/extras/custompipes.cpp b/src/extras/custompipes.cpp
index a485138e..630fe6bc 100644
--- a/src/extras/custompipes.cpp
+++ b/src/extras/custompipes.cpp
@@ -134,9 +134,18 @@ EnvMapRender(void)
 	EnvMapCam->getFrame()->transform(&EnvMapCam->getFrame()->matrix, rw::COMBINEREPLACE);
 
 	rw::RGBA skycol;
+
+#ifdef IMPROVED_VEHICLES
+	skycol.red = CTimeCycle::GetSkyTopRed();
+	skycol.green = CTimeCycle::GetSkyTopGreen();
+	skycol.blue = CTimeCycle::GetSkyTopBlue();
+#else
 	skycol.red = CTimeCycle::GetSkyBottomRed();
 	skycol.green = CTimeCycle::GetSkyBottomGreen();
 	skycol.blue = CTimeCycle::GetSkyBottomBlue();
+#endif
+
+
 	skycol.alpha = 255;
 	EnvMapCam->clear(&skycol, rwCAMERACLEARZ|rwCAMERACLEARIMAGE);
 	RwCameraBeginUpdate(EnvMapCam);
diff --git a/src/extras/debug/debug_functions.cpp b/src/extras/debug/debug_functions.cpp
index 43d10ed1..ef212acd 100644
--- a/src/extras/debug/debug_functions.cpp
+++ b/src/extras/debug/debug_functions.cpp
@@ -4,50 +4,48 @@
 #if defined DETECT_JOYSTICK_MENU && defined XINPUT
 #include <xinput.h>
 #if !defined(PSAPI_VERSION) || (PSAPI_VERSION > 1)
-#pragma comment( lib, "Xinput9_1_0.lib" )
+#pragma comment(lib, "Xinput9_1_0.lib")
 #else
-#pragma comment( lib, "Xinput.lib" )
+#pragma comment(lib, "Xinput.lib")
 #endif
 #endif
-#include "Renderer.h"
-#include "Occlusion.h"
-#include "Credits.h"
-#include "Camera.h"
-#include "Weather.h"
-#include "Timecycle.h"
-#include "Clock.h"
-#include "World.h"
-#include "Vehicle.h"
-#include "ModelIndices.h"
-#include "Streaming.h"
-#include "Boat.h"
-#include "Heli.h"
 #include "Automobile.h"
 #include "Bike.h"
+#include "Boat.h"
+#include "Camera.h"
+#include "CarCtrl.h"
+#include "Clock.h"
 #include "Console.h"
+#include "ControllerConfig.h"
+#include "Credits.h"
 #include "Debug.h"
+#include "FileMgr.h"
+#include "Frontend.h"
+#include "Heli.h"
 #include "Hud.h"
-#include "SceneEdit.h"
+#include "IniFile.h"
+#include "MBlur.h"
+#include "MemoryHeap.h"
+#include "ModelIndices.h"
+#include "Occlusion.h"
 #include "Pad.h"
 #include "PlayerPed.h"
+#include "Population.h"
 #include "Radar.h"
-#include "debugmenu.h"
-#include "Frontend.h"
+#include "Renderer.h"
+#include "SceneEdit.h"
+#include "Script.h"
+#include "Streaming.h"
+#include "Timecycle.h"
+#include "Vehicle.h"
 #include "WaterLevel.h"
+#include "Weather.h"
+#include "World.h"
+#include "Zones.h"
+#include "custompipes.h"
+#include "debugmenu.h"
 #include "main.h"
-#include "Script.h"
-#include "MBlur.h"
 #include "postfx.h"
-#include "custompipes.h"
-#include "MemoryHeap.h"
-#include "FileMgr.h"
-#include "Camera.h"
-#include "MBlur.h"
-#include "ControllerConfig.h"
-#include "CarCtrl.h"
-#include "Population.h"
-#include "IniFile.h"
-#include "Zones.h"
 
 #include "crossplatform.h"
 
@@ -59,6 +57,13 @@
 #include <list>
 
 // Extra
+#ifdef VEHICLE_MODS // mod garage
+#include "DMAudio.h"
+#include "Garages.h"
+#include "Messages.h"
+#include "Wanted.h"
+#endif
+
 #include "Garages.h"
 
 // Cheats
@@ -66,10 +71,9 @@
 #include "player_cheats.h"
 #include "vehicle_cheats.h"
 
-
 // Functions
-#include "vehicle_functions.h"
 #include "log_functions.h"
+#include "vehicle_functions.h"
 
 #define _IMGUI_TEST
 #ifdef _IMGUI_TEST
@@ -84,7 +88,6 @@
 
 // TODO Move these into another file, and all debug functions.
 
-
 #ifdef _MOVE_DEBUG_FILE
 
 #ifdef DEBUGMENU
@@ -192,7 +195,7 @@ toggleImGui()
 
 // This one is accessing it from CGarages::ToggleRespray
 // void ToggleRespray();
-//  Oops, this killed it by being defined again :\
+//   Oops, this killed it by being defined again :\
 //bool m_allowAllVehiclesRespray;
 // 5-28-2024 @ 3:16AM
 // I never did get this working.
@@ -328,10 +331,8 @@ static const char *carnames[] = {
     "blistac",  "polmav",  "boxville", "benson",   "mesa",     "rcgoblin", "hotrina",  "hotrinb",  "bloodra",  "bloodrb",  "vicechee"};
 
 #ifdef EX_COP_FUNCTIONS
-static const char *policeWeaponNames[] = {
-	"colt45", "python", "shotgun", "spaz12-shotgun", "stubby-shotgun", "tec-9", "uzi", "unknown", "mp5", "m4"
-};
-#endif //EX_COP_FUNCTIONS
+static const char *policeWeaponNames[] = {"colt45", "python", "shotgun", "spaz12-shotgun", "stubby-shotgun", "tec-9", "uzi", "unknown", "mp5", "m4"};
+#endif // EX_COP_FUNCTIONS
 
 static CTweakVar **TweakVarsList;
 static int TweakVarsListSize = -1;
@@ -431,6 +432,891 @@ switchWeather(void)
 	CWeather::StreamAfterRainTimer = 0;
 }
 
+// TODO Figure out how to move these into a separate file, mod_garage_functions.cpp.
+// First I need to get it working though.
+//*****************
+// Begin Vehicle mod garage functions from Extended Vice
+//*****************
+
+#if defined VEHICLE_MODS && defined IMPROVED_VEHICLES // mod garage
+DebugMenuEntry *carTintLevel;
+DebugMenuEntry *carAddSuspensionForceLevel;
+DebugMenuEntry *carWheelNumber;
+DebugMenuEntry *carRimsColor;
+DebugMenuEntry *carSpoilerColor;
+DebugMenuEntry *carSpoilerNumber;
+DebugMenuEntry *carSkirtsNumber;
+DebugMenuEntry *carRoofScoopNumber;
+DebugMenuEntry *carBonnetScoopNumber;
+DebugMenuEntry *carVentsNumber;
+DebugMenuEntry *carHasSupercharger;
+DebugMenuEntry *carCol3;
+DebugMenuEntry *carCol4;
+
+void
+SetTempWindowTintLevel()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh) return;
+
+	if(carTintLevel) DebugMenuEntrySetAddress(carTintLevel, &playerVeh->m_nTempWindowTintLevel);
+}
+
+void
+PurchaseTint()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carTintLevel) return;
+
+	if(playerVeh->m_nWindowTintLevel == playerVeh->m_nTempWindowTintLevel) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	int price = 500;
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+	DebugMenuEntrySetAddress(carTintLevel, &playerVeh->m_nTempWindowTintLevel);
+	playerVeh->m_nWindowTintLevel = playerVeh->m_nTempWindowTintLevel;
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+SetTempSuspensionForceLevel()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carAddSuspensionForceLevel) return;
+
+	DebugMenuEntrySetAddress(carAddSuspensionForceLevel, &playerVeh->m_nTempAddSuspensionForceLevel);
+}
+void
+PurchaseSuspension()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carAddSuspensionForceLevel) return;
+
+	if(playerVeh->m_nAddSuspensionForceLevel == playerVeh->m_nTempAddSuspensionForceLevel) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	int price = 500;
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	DebugMenuEntrySetAddress(carAddSuspensionForceLevel, &playerVeh->m_nTempAddSuspensionForceLevel);
+	playerVeh->m_nAddSuspensionForceLevel = playerVeh->m_nTempAddSuspensionForceLevel;
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+SetTempWheelModelIndex()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carWheelNumber) return;
+
+	DebugMenuEntrySetAddress(carWheelNumber, &playerVeh->m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber);
+	playerVeh->m_aUpgrades[UPGRADE_WHEELS].m_nTempUpgradeModelIndex = playerVeh->GetWheelModelIndexFromWheelNumber();
+	playerVeh->SetWheels(playerVeh->m_aUpgrades[UPGRADE_WHEELS].m_nTempUpgradeModelIndex);
+}
+void
+PurchaseWheels()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carWheelNumber) return;
+
+	if(playerVeh->m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeModelIndex == playerVeh->m_aUpgrades[UPGRADE_WHEELS].m_nTempUpgradeModelIndex) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	int price = 1000;
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	DebugMenuEntrySetAddress(carWheelNumber, &playerVeh->m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber);
+	playerVeh->m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeModelIndex = playerVeh->m_aUpgrades[UPGRADE_WHEELS].m_nTempUpgradeModelIndex;
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+SetTempColor1()
+{
+	CVehicle *playerVeh = FindPlayerVehicle();
+
+	if(!playerVeh || !carCol1) return;
+
+	DebugMenuEntrySetAddress(carCol1, &playerVeh->m_nTempColor1);
+}
+void
+SetTempColor2()
+{
+	CVehicle *playerVeh = FindPlayerVehicle();
+
+	if(!playerVeh || !carCol2) return;
+
+	DebugMenuEntrySetAddress(carCol2, &playerVeh->m_nTempColor2);
+}
+void
+PaintVehicle2()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh) return;
+
+	if(playerVeh->m_nTempColor1 == playerVeh->m_currentColour1 && playerVeh->m_nTempColor2 == playerVeh->m_currentColour2) {
+
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	int price = 50;
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	if(carCol1) {
+		DebugMenuEntrySetAddress(carCol1, &playerVeh->m_nTempColor1);
+		playerVeh->m_currentColour1 = playerVeh->m_nTempColor1;
+	}
+
+	if(carCol2) {
+		DebugMenuEntrySetAddress(carCol2, &playerVeh->m_nTempColor2);
+		playerVeh->m_currentColour2 = playerVeh->m_nTempColor2;
+	}
+
+	if(FindPlayerPed()->m_pWanted->GetWantedLevel() != 0) FindPlayerPed()->m_pWanted->Suspend();
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+void
+SetTempColor3()
+{
+	CVehicle *playerVeh = FindPlayerVehicle();
+
+	if(!playerVeh || !carCol3) return;
+
+	DebugMenuEntrySetAddress(carCol3, &playerVeh->m_nTempColor3);
+}
+void
+SetTempColor4()
+{
+	CVehicle *playerVeh = FindPlayerVehicle();
+
+	if(!playerVeh || !carCol4) return;
+
+	DebugMenuEntrySetAddress(carCol4, &playerVeh->m_nTempColor4);
+}
+void
+PaintVehicle4()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh) return;
+
+	if(playerVeh->m_nTempColor1 == playerVeh->m_currentColour1 && playerVeh->m_nTempColor2 == playerVeh->m_currentColour2 &&
+	   playerVeh->m_nTempColor3 == playerVeh->m_currentColour3 && playerVeh->m_nTempColor4 == playerVeh->m_currentColour4) {
+
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	int price = 100;
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	if(carCol1) {
+		DebugMenuEntrySetAddress(carCol1, &playerVeh->m_nTempColor1);
+		playerVeh->m_currentColour1 = playerVeh->m_nTempColor1;
+	}
+
+	if(carCol2) {
+		DebugMenuEntrySetAddress(carCol2, &playerVeh->m_nTempColor2);
+		playerVeh->m_currentColour2 = playerVeh->m_nTempColor2;
+	}
+
+	if(carCol3) {
+		DebugMenuEntrySetAddress(carCol3, &playerVeh->m_nTempColor3);
+		playerVeh->m_currentColour3 = playerVeh->m_nTempColor3;
+	}
+
+	if(carCol4) {
+		DebugMenuEntrySetAddress(carCol4, &playerVeh->m_nTempColor4);
+		playerVeh->m_currentColour4 = playerVeh->m_nTempColor4;
+	}
+
+	if(FindPlayerPed()->m_pWanted->GetWantedLevel() != 0) FindPlayerPed()->m_pWanted->Suspend();
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+SetTempRimsColor()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carRimsColor) return;
+
+	DebugMenuEntrySetAddress(carRimsColor, &playerVeh->m_nTempRimsColor);
+}
+void
+PaintRims()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh) return;
+
+	if(playerVeh->m_nTempRimsColor == playerVeh->m_nRimsColor) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	int price = 50;
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	if(carRimsColor) {
+		DebugMenuEntrySetAddress(carRimsColor, &playerVeh->m_nTempRimsColor);
+		playerVeh->m_nRimsColor = playerVeh->m_nTempRimsColor;
+	}
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+SetTempSpoilerColor()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carSpoilerColor) return;
+
+	DebugMenuEntrySetAddress(carSpoilerColor, &playerVeh->m_nTempSpoilerColor);
+}
+void
+PaintSpoiler()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh) return;
+
+	if(playerVeh->m_nTempSpoilerColor == playerVeh->m_nSpoilerColor) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	int price = 25;
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	if(carSpoilerColor) {
+		DebugMenuEntrySetAddress(carSpoilerColor, &playerVeh->m_nTempSpoilerColor);
+		playerVeh->m_nSpoilerColor = playerVeh->m_nTempSpoilerColor;
+	}
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+SetTempSpoilerModelIndex()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carSpoilerNumber) return;
+
+	DebugMenuEntrySetAddress(carSpoilerNumber, &playerVeh->m_aUpgrades[UPGRADE_SPOILER].m_nUpgradeNumber);
+	if(playerVeh->m_aUpgrades[UPGRADE_SPOILER].m_nUpgradeNumber == 0) {
+		playerVeh->m_aUpgrades[UPGRADE_SPOILER].m_nTempUpgradeModelIndex = 0;
+		playerVeh->RemoveUpgrade(UPGRADE_SPOILER, true);
+	} else {
+		playerVeh->m_aUpgrades[UPGRADE_SPOILER].m_nTempUpgradeModelIndex =
+		    (MI_SPOILER_1 - 1) + playerVeh->m_aUpgrades[UPGRADE_SPOILER].m_nUpgradeNumber;
+		playerVeh->SetUpgrade(playerVeh->m_aUpgrades[UPGRADE_SPOILER].m_nTempUpgradeModelIndex, true);
+	}
+}
+void
+PurchaseSpoiler()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carSpoilerNumber) return;
+
+	if(playerVeh->m_aUpgrades[UPGRADE_SPOILER].m_nUpgradeModelIndex == playerVeh->m_aUpgrades[UPGRADE_SPOILER].m_nTempUpgradeModelIndex) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	int price = 500;
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	DebugMenuEntrySetAddress(carSpoilerNumber, &playerVeh->m_aUpgrades[UPGRADE_SPOILER].m_nUpgradeNumber);
+	playerVeh->m_aUpgrades[UPGRADE_SPOILER].m_nUpgradeModelIndex = playerVeh->m_aUpgrades[UPGRADE_SPOILER].m_nTempUpgradeModelIndex;
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+SetTempSkirtsModelIndex()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carSkirtsNumber) return;
+
+	DebugMenuEntrySetAddress(carSkirtsNumber, &playerVeh->m_aUpgrades[UPGRADE_SKIRTS].m_nUpgradeNumber);
+	if(playerVeh->m_aUpgrades[UPGRADE_SKIRTS].m_nUpgradeNumber == 0) {
+		playerVeh->m_aUpgrades[UPGRADE_SKIRTS].m_nTempUpgradeModelIndex = 0;
+		playerVeh->RemoveUpgrade(UPGRADE_SKIRTS, true);
+	} else {
+		int number = playerVeh->m_aUpgrades[UPGRADE_SKIRTS].m_nUpgradeNumber;
+		if(number == 0)
+			playerVeh->m_aUpgrades[UPGRADE_SKIRTS].m_nTempUpgradeModelIndex = 0;
+		else if(number == 1)
+			playerVeh->m_aUpgrades[UPGRADE_SKIRTS].m_nTempUpgradeModelIndex = MI_SIDE_SKIRT_L_1;
+
+		playerVeh->SetUpgrade(playerVeh->m_aUpgrades[UPGRADE_SKIRTS].m_nTempUpgradeModelIndex, true);
+	}
+}
+void
+PurchaseSkirts()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carSkirtsNumber) return;
+
+	if(playerVeh->m_aUpgrades[UPGRADE_SKIRTS].m_nUpgradeModelIndex == playerVeh->m_aUpgrades[UPGRADE_SKIRTS].m_nTempUpgradeModelIndex) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	int price = 200;
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	DebugMenuEntrySetAddress(carSkirtsNumber, &playerVeh->m_aUpgrades[UPGRADE_SKIRTS].m_nUpgradeNumber);
+	playerVeh->m_aUpgrades[UPGRADE_SKIRTS].m_nUpgradeModelIndex = playerVeh->m_aUpgrades[UPGRADE_SKIRTS].m_nTempUpgradeModelIndex;
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+SetTempRoofScoopModelIndex()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carRoofScoopNumber) return;
+
+	DebugMenuEntrySetAddress(carRoofScoopNumber, &playerVeh->m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nUpgradeNumber);
+	if(playerVeh->m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nUpgradeNumber == 0) {
+		playerVeh->m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nTempUpgradeModelIndex = 0;
+		playerVeh->RemoveUpgrade(UPGRADE_ROOF_SCOOP, true);
+	} else {
+		playerVeh->m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nTempUpgradeModelIndex =
+		    (MI_RF_SCOOP_1 - 1) + playerVeh->m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nUpgradeNumber;
+		playerVeh->SetUpgrade(playerVeh->m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nTempUpgradeModelIndex, true);
+	}
+}
+void
+PurchaseRoofScoop()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carRoofScoopNumber) return;
+
+	if(playerVeh->m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nUpgradeModelIndex == playerVeh->m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nTempUpgradeModelIndex) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	int price = 300;
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	DebugMenuEntrySetAddress(carRoofScoopNumber, &playerVeh->m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nUpgradeNumber);
+	playerVeh->m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nUpgradeModelIndex = playerVeh->m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nTempUpgradeModelIndex;
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+SetTempBonnetScoopModelIndex()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carBonnetScoopNumber) return;
+
+	DebugMenuEntrySetAddress(carBonnetScoopNumber, &playerVeh->m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nUpgradeNumber);
+	if(playerVeh->m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nUpgradeNumber == 0) {
+		playerVeh->m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nTempUpgradeModelIndex = 0;
+		playerVeh->RemoveUpgrade(UPGRADE_BONNET_SCOOP, true);
+	} else {
+		playerVeh->m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nTempUpgradeModelIndex =
+		    (MI_BNT_SCOOP_1 - 1) + playerVeh->m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nUpgradeNumber;
+		playerVeh->SetUpgrade(playerVeh->m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nTempUpgradeModelIndex, true);
+	}
+}
+void
+PurchaseBonnetScoop()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carBonnetScoopNumber) return;
+
+	if(playerVeh->m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nUpgradeModelIndex == playerVeh->m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nTempUpgradeModelIndex) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	int price = 300;
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	DebugMenuEntrySetAddress(carBonnetScoopNumber, &playerVeh->m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nUpgradeNumber);
+	playerVeh->m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nUpgradeModelIndex = playerVeh->m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nTempUpgradeModelIndex;
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+SetTempVentsModelIndex()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carVentsNumber) return;
+
+	DebugMenuEntrySetAddress(carVentsNumber, &playerVeh->m_aUpgrades[UPGRADE_VENTS].m_nUpgradeNumber);
+	if(playerVeh->m_aUpgrades[UPGRADE_VENTS].m_nUpgradeNumber == 0) {
+		playerVeh->m_aUpgrades[UPGRADE_VENTS].m_nTempUpgradeModelIndex = 0;
+		playerVeh->RemoveUpgrade(UPGRADE_VENTS, true);
+	} else {
+		int number = playerVeh->m_aUpgrades[UPGRADE_VENTS].m_nUpgradeNumber;
+		if(number == 0)
+			playerVeh->m_aUpgrades[UPGRADE_VENTS].m_nTempUpgradeModelIndex = 0;
+		else if(number == 1)
+			playerVeh->m_aUpgrades[UPGRADE_VENTS].m_nTempUpgradeModelIndex = MI_BNT_VENT_L_1;
+		else if(number == 2)
+			playerVeh->m_aUpgrades[UPGRADE_VENTS].m_nTempUpgradeModelIndex = MI_BNT_VENT_L_2;
+
+		playerVeh->SetUpgrade(playerVeh->m_aUpgrades[UPGRADE_VENTS].m_nTempUpgradeModelIndex, true);
+	}
+}
+void
+PurchaseVents()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carVentsNumber) return;
+
+	if(playerVeh->m_aUpgrades[UPGRADE_VENTS].m_nUpgradeModelIndex == playerVeh->m_aUpgrades[UPGRADE_VENTS].m_nTempUpgradeModelIndex) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	int price = 400;
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	DebugMenuEntrySetAddress(carVentsNumber, &playerVeh->m_aUpgrades[UPGRADE_VENTS].m_nUpgradeNumber);
+	playerVeh->m_aUpgrades[UPGRADE_VENTS].m_nUpgradeModelIndex = playerVeh->m_aUpgrades[UPGRADE_VENTS].m_nTempUpgradeModelIndex;
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+SetTempSupercharger()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carHasSupercharger) return;
+
+	DebugMenuEntrySetAddress(carHasSupercharger, &playerVeh->m_aUpgrades[UPGRADE_SUPERCHARGER].m_nUpgradeNumber);
+	if(playerVeh->m_aUpgrades[UPGRADE_SUPERCHARGER].m_nUpgradeNumber == 0) {
+		playerVeh->m_aUpgrades[UPGRADE_SUPERCHARGER].m_nTempUpgradeModelIndex = 0;
+		playerVeh->RemoveUpgrade(UPGRADE_SUPERCHARGER, true);
+	} else {
+		if(playerVeh->GetModelIndex() == MI_SABRE) playerVeh->m_aUpgrades[UPGRADE_SUPERCHARGER].m_nTempUpgradeModelIndex = MI_SC_SABRE_BONNET_OK;
+		playerVeh->SetUpgrade(playerVeh->m_aUpgrades[UPGRADE_SUPERCHARGER].m_nTempUpgradeModelIndex, true);
+	}
+}
+void
+PurchaseSupercharger()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh || !carHasSupercharger) return;
+
+	if(playerVeh->m_aUpgrades[UPGRADE_SUPERCHARGER].m_nUpgradeModelIndex == playerVeh->m_aUpgrades[UPGRADE_SUPERCHARGER].m_nTempUpgradeModelIndex) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	int price = 1000;
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	DebugMenuEntrySetAddress(carHasSupercharger, &playerVeh->m_aUpgrades[UPGRADE_SUPERCHARGER].m_nUpgradeNumber);
+	playerVeh->m_aUpgrades[UPGRADE_SUPERCHARGER].m_nUpgradeModelIndex = playerVeh->m_aUpgrades[UPGRADE_SUPERCHARGER].m_nTempUpgradeModelIndex;
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+PurchaseTyres()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh) return;
+
+	if(playerVeh->bTyresDontBurst) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	int price = 500;
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	playerVeh->bTyresDontBurst = true;
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+PurchaseHydraulics()
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh) return;
+
+	if(playerVeh->bHasHydraulics) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	int price = 1500;
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	playerVeh->bHasHydraulics = true;
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+PurchaseEngineTuning(float additionalAccel, int price)
+{
+	CVehicle *playerVeh = FindPlayerVehicle();
+
+	if(!playerVeh) return;
+
+	additionalAccel *= 1.0f / (50.0f * 50.0f); // convert to game units
+
+	if(playerVeh->m_fAddEngineAcceleration >= additionalAccel) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		return;
+	}
+
+	playerVeh->m_fAddEngineAcceleration = additionalAccel;
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+PurchaseBrakes(float additionalDecel, int price)
+{
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh) return;
+
+	additionalDecel *= 1.0f / (50.0f * 50.0f); // convert to game units
+
+	if(playerVeh->m_fAddBrakeDeceleration >= additionalDecel) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	playerVeh->m_fAddBrakeDeceleration = additionalDecel;
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+PurchaseArmor(int level, int price)
+{
+	CVehicle *playerVeh = FindPlayerVehicle();
+
+	if(!playerVeh) return;
+
+	if(playerVeh->m_nArmorLevel >= level) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_24"), 4000, 1);
+		return;
+	}
+
+	if(CWorld::Players[CWorld::PlayerInFocus].m_nMoney < price) {
+		CMessages::AddMessageJumpQ(TheText.Get("GA_23"), 4000, 1);
+		DMAudio.PlayFrontEndSound(SOUND_GARAGE_NO_MONEY, 1);
+		return;
+	}
+
+	playerVeh->m_nArmorLevel = level;
+
+	DMAudio.PlayFrontEndSound(SOUND_GARAGE_OPENING, 1);
+	CWorld::Players[CWorld::PlayerInFocus].m_nMoney = Max(0, CWorld::Players[CWorld::PlayerInFocus].m_nMoney - price);
+}
+
+void
+LeaveModGarage()
+{
+	CGarages::bPlayerShouldBeLeaveModGarage = true;
+
+	CAutomobile *playerVeh = (CAutomobile *)FindPlayerVehicle();
+
+	if(!playerVeh) return;
+
+	if(playerVeh->m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeModelIndex != playerVeh->m_aUpgrades[UPGRADE_WHEELS].m_nTempUpgradeModelIndex) {
+		playerVeh->SetWheels(playerVeh->m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeModelIndex);
+		playerVeh->m_aUpgrades[UPGRADE_WHEELS].m_nTempUpgradeModelIndex = playerVeh->m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeModelIndex;
+	}
+
+	if(playerVeh->m_nTempColor1 != playerVeh->m_currentColour1) playerVeh->m_nTempColor1 = playerVeh->m_currentColour1;
+
+	if(playerVeh->m_nTempColor2 != playerVeh->m_currentColour2) playerVeh->m_nTempColor2 = playerVeh->m_currentColour2;
+
+	if(playerVeh->m_nTempColor3 != playerVeh->m_currentColour3) playerVeh->m_nTempColor3 = playerVeh->m_currentColour3;
+
+	if(playerVeh->m_nTempColor4 != playerVeh->m_currentColour4) playerVeh->m_nTempColor4 = playerVeh->m_currentColour4;
+
+	if(playerVeh->m_nTempRimsColor != playerVeh->m_nRimsColor) playerVeh->m_nTempRimsColor = playerVeh->m_nRimsColor;
+
+	if(playerVeh->m_nTempSpoilerColor != playerVeh->m_nSpoilerColor) playerVeh->m_nTempSpoilerColor = playerVeh->m_nSpoilerColor;
+
+	for(int upgradeID = 0; upgradeID < NUM_UPGRADES; upgradeID++) {
+		if(playerVeh->m_aUpgrades[upgradeID].m_nUpgradeModelIndex == playerVeh->m_aUpgrades[upgradeID].m_nTempUpgradeModelIndex) continue;
+
+		playerVeh->m_aUpgrades[upgradeID].m_nTempUpgradeModelIndex = playerVeh->m_aUpgrades[upgradeID].m_nUpgradeModelIndex;
+		if(playerVeh->m_aUpgrades[upgradeID].m_nUpgradeModelIndex == 0)
+			playerVeh->RemoveUpgrade((eUpgradeTypes)upgradeID, false);
+		else
+			playerVeh->SetUpgrade(playerVeh->m_aUpgrades[upgradeID].m_nUpgradeModelIndex, false);
+	}
+}
+
+void
+VehicleModMenuPopulate(void)
+{
+	static uint8 dummy;
+	CVehicle *playerVeh = FindPlayerVehicle();
+
+	if(!playerVeh) return;
+
+	if(playerVeh->GetModelInfo()->bHasManyColors) {
+		carCol1 = DebugMenuAddVar("Paint", "Primary colour", &dummy, SetTempColor1, 1, 0, 94, nil);
+		DebugMenuEntrySetAddress(carCol1, &playerVeh->m_nTempColor1);
+		carCol2 = DebugMenuAddVar("Paint", "Secondary colour", &dummy, SetTempColor2, 1, 0, 94, nil);
+		DebugMenuEntrySetAddress(carCol2, &playerVeh->m_nTempColor2);
+		carCol3 = DebugMenuAddVar("Paint", "Tertiary colour", &dummy, SetTempColor3, 1, 0, 94, nil);
+		DebugMenuEntrySetAddress(carCol3, &playerVeh->m_nTempColor3);
+		carCol4 = DebugMenuAddVar("Paint", "Quaternary colour", &dummy, SetTempColor4, 1, 0, 94, nil);
+		DebugMenuEntrySetAddress(carCol4, &playerVeh->m_nTempColor4);
+		DebugMenuAddCmd("Paint", "Paint vehicle, $100", PaintVehicle4);
+	} else {
+		carCol1 = DebugMenuAddVar("Paint", "Primary colour", &dummy, SetTempColor1, 1, 0, 94, nil);
+		DebugMenuEntrySetAddress(carCol1, &playerVeh->m_nTempColor1);
+		carCol2 = DebugMenuAddVar("Paint", "Secondary colour", &dummy, SetTempColor2, 1, 0, 94, nil);
+		DebugMenuEntrySetAddress(carCol2, &playerVeh->m_nTempColor2);
+		DebugMenuAddCmd("Paint", "Paint vehicle, $50", PaintVehicle2);
+	}
+
+	DebugMenuAddCmd("Armor", "Purchase level 1 armor, $1000", []() { PurchaseArmor(1, 1000); });
+	DebugMenuAddCmd("Armor", "Purchase level 2 armor, $2000", []() { PurchaseArmor(2, 2000); });
+	DebugMenuAddCmd("Armor", "Purchase level 3 armor, $3000", []() { PurchaseArmor(3, 3000); });
+	DebugMenuAddCmd("Armor", "Purchase level 4 armor, $4000", []() { PurchaseArmor(4, 4000); });
+
+	DebugMenuAddCmd("Engine", "Purchase engine tuning 1, $500", []() { PurchaseEngineTuning(0.5f, 500); });
+	DebugMenuAddCmd("Engine", "Purchase engine tuning 2, $1000", []() { PurchaseEngineTuning(1.0f, 1000); });
+	DebugMenuAddCmd("Engine", "Purchase engine tuning 3, $1500", []() { PurchaseEngineTuning(1.5f, 1500); });
+	DebugMenuAddCmd("Engine", "Purchase engine tuning 4, $2000", []() { PurchaseEngineTuning(2.0f, 2000); });
+
+	if(playerVeh->IsCar()) {
+		CAutomobile *playerCar = (CAutomobile *)FindPlayerVehicle();
+
+		DebugMenuAddCmd("Brakes", "Purchase improved brakes 1, $250", []() { PurchaseBrakes(0.5f, 250); });
+		DebugMenuAddCmd("Brakes", "Purchase improved brakes 2, $500", []() { PurchaseBrakes(1.0f, 500); });
+		DebugMenuAddCmd("Brakes", "Purchase improved brakes 3, $750", []() { PurchaseBrakes(1.5f, 750); });
+		DebugMenuAddCmd("Brakes", "Purchase improved brakes 4, $1000", []() { PurchaseBrakes(2.0f, 1000); });
+
+		if(CGarages::IsCarTintable(playerCar)) {
+			carTintLevel = DebugMenuAddVar("Window tint", "Tint level", &dummy, SetTempWindowTintLevel, 1, 1, 4, nil);
+			DebugMenuEntrySetAddress(carTintLevel, &playerCar->m_nTempWindowTintLevel);
+			DebugMenuAddCmd("Window tint", "Purchase tint, $500", PurchaseTint);
+		}
+
+		carAddSuspensionForceLevel = DebugMenuAddVar("Suspension", "Suspension force level", &dummy, SetTempSuspensionForceLevel, 1, 1, 4, nil);
+		DebugMenuEntrySetAddress(carAddSuspensionForceLevel, &playerCar->m_nTempAddSuspensionForceLevel);
+		DebugMenuAddCmd("Suspension", "Purchase suspension, $500", PurchaseSuspension);
+
+		if(playerVeh->GetModelInfo()->m_wheelId != 249) {
+			//carWheelNumber = DebugMenuAddVar("Wheels", "Wheel model", &dummy, SetTempWheelModelIndex, 1, 1, MAXWHEELMODELS, nil);
+			carWheelNumber = DebugMenuAddVar("Wheels", "Wheel model", &dummy, SetTempWheelModelIndex, 1, 1, Config::MAX_WHEELMODELS, nil);
+			DebugMenuEntrySetAddress(carWheelNumber, &playerCar->m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber);
+			DebugMenuAddCmd("Wheels", "Purchase wheels, $1000", PurchaseWheels);
+			carRimsColor = DebugMenuAddVar("Wheels", "Rims color", &dummy, SetTempRimsColor, 1, 0, 94, nil);
+			DebugMenuEntrySetAddress(carRimsColor, &playerCar->m_nTempRimsColor);
+			DebugMenuAddCmd("Wheels", "Paint rims, $50", PaintRims);
+		}
+		DebugMenuAddCmd("Wheels", "Purchase bulletproof tyres, $500", PurchaseTyres);
+
+		DebugMenuAddCmd("Hydraulics", "Purchase hydraulics, $1500", PurchaseHydraulics);
+
+		if(playerCar->m_aCarNodes[CAR_SPOILER_OK]) {
+			carSpoilerNumber = DebugMenuAddVar("Spoiler", "Spoiler model", &dummy, SetTempSpoilerModelIndex, 1, 0, 9, nil);
+			DebugMenuEntrySetAddress(carSpoilerNumber, &playerCar->m_aUpgrades[UPGRADE_SPOILER].m_nUpgradeNumber);
+			DebugMenuAddCmd("Spoiler", "Purchase spoiler, $500", PurchaseSpoiler);
+			carSpoilerColor = DebugMenuAddVar("Spoiler", "Spoiler color", &dummy, SetTempSpoilerColor, 1, 0, 94, nil);
+			DebugMenuEntrySetAddress(carSpoilerColor, &playerCar->m_nTempSpoilerColor);
+			DebugMenuAddCmd("Spoiler", "Paint spoiler, $25", PaintSpoiler);
+		}
+
+		if(playerCar->m_aCarNodes[CAR_SKIRT_L] && playerCar->m_aCarNodes[CAR_SKIRT_R]) {
+			carSkirtsNumber = DebugMenuAddVar("Side skirts", "Side skirts model", &dummy, SetTempSkirtsModelIndex, 1, 0, 1, nil);
+			DebugMenuEntrySetAddress(carSkirtsNumber, &playerCar->m_aUpgrades[UPGRADE_SKIRTS].m_nUpgradeNumber);
+			DebugMenuAddCmd("Side skirts", "Purchase side skirts, $200", PurchaseSkirts);
+		}
+
+		if(playerCar->m_aCarNodes[CAR_RF_SCOOP]) {
+			carRoofScoopNumber = DebugMenuAddVar("Scoop", "Roof scoop model", &dummy, SetTempRoofScoopModelIndex, 1, 0, 1, nil);
+			DebugMenuEntrySetAddress(carRoofScoopNumber, &playerCar->m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nUpgradeNumber);
+			DebugMenuAddCmd("Scoop", "Purchase roof scoop, $300", PurchaseRoofScoop);
+		}
+
+		if(playerCar->m_aCarNodes[CAR_BNT_SCOOP_OK] && playerCar->m_aCarNodes[CAR_BNT_SCOOP_DAM]) {
+			carBonnetScoopNumber = DebugMenuAddVar("Scoop", "Bonnet scoop model", &dummy, SetTempBonnetScoopModelIndex, 1, 0, 4, nil);
+			DebugMenuEntrySetAddress(carBonnetScoopNumber, &playerCar->m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nUpgradeNumber);
+			DebugMenuAddCmd("Scoop", "Purchase bonnet scoop, $300", PurchaseBonnetScoop);
+		}
+
+		if(playerCar->m_aCarNodes[CAR_VENT_L_OK] && playerCar->m_aCarNodes[CAR_VENT_L_DAM] && playerCar->m_aCarNodes[CAR_VENT_R_OK] &&
+		   playerCar->m_aCarNodes[CAR_VENT_R_DAM]) {
+
+			carVentsNumber = DebugMenuAddVar("Vents", "Vents model", &dummy, SetTempVentsModelIndex, 1, 0, 2, nil);
+			DebugMenuEntrySetAddress(carVentsNumber, &playerCar->m_aUpgrades[UPGRADE_VENTS].m_nUpgradeNumber);
+			DebugMenuAddCmd("Vents", "Purchase vents, $400", PurchaseVents);
+		}
+
+		if(playerCar->m_aCarNodes[CAR_SUPERCHARGER]) {
+			static const char *hasSupercharger[] = {"No", "Yes"};
+			carHasSupercharger = DebugMenuAddVar("Supercharger", "Has a supercharger", &dummy, SetTempSupercharger, 1, 0, 1, hasSupercharger);
+			DebugMenuEntrySetAddress(carHasSupercharger, &playerCar->m_aUpgrades[UPGRADE_SUPERCHARGER].m_nUpgradeNumber);
+			DebugMenuAddCmd("Supercharger", "Purchase supercharger, $1000", PurchaseSupercharger);
+		}
+	} else if(playerVeh->IsBike()) {
+		DebugMenuAddCmd("Wheels", "Purchase bulletproof tyres, $500", PurchaseTyres);
+	}
+
+	DebugMenuAddCmd("Exit", "Leave Vice City Customs", LeaveModGarage);
+}
+#endif
+
+//*****************
+// End Vehicle mod garage functions from Extended Vice
+//*****************
+
 /// <summary>
 /// This is where everything is defined in the debug menu.
 /// TODO Figure out how to make the text wrap.
@@ -483,11 +1369,10 @@ DebugMenuPopulate(void)
 		// Begin time and weather
 		//*****************
 
-
 		// Current hour
 		e = DebugMenuAddVar("Time & Weather", "Current Hour", &CClock::GetHoursRef(), nil, 1, 0, 23, nil);
 		DebugMenuEntrySetWrap(e, true);
-		
+
 		// Current minute
 		e = DebugMenuAddVar(
 		    "Time & Weather", "Current Minute", &CClock::GetMinutesRef(), []() { CWeather::InterpolationValue = CClock::GetMinutes() / 60.0f; }, 1, 0,
@@ -497,14 +1382,14 @@ DebugMenuPopulate(void)
 		// Old weather
 		e = DebugMenuAddVar("Time & Weather", "Old Weather", (int16 *)&CWeather::OldWeatherType, switchWeather, 1, 0, 5, weathers);
 		DebugMenuEntrySetWrap(e, true);
-		
+
 		// New weather
 		e = DebugMenuAddVar("Time & Weather", "New Weather", (int16 *)&CWeather::NewWeatherType, switchWeather, 1, 0, 5, weathers);
 		DebugMenuEntrySetWrap(e, true);
 		// Extra colours
 		DebugMenuAddVarBool32("Time & Weather", "Extracolours On", &CTimeCycle::m_bExtraColourOn, nil);
 		DebugMenuAddVar("Time & Weather", "Extracolour", &CTimeCycle::m_ExtraColour, nil, 1, 0, 23, extracols);
-		
+
 		// Time scale
 		DebugMenuAddVar("Time & Weather", "Time scale", (float *)&CTimer::GetTimeScale(), nil, 0.1f, 0.0f, 10.0f);
 
@@ -521,17 +1406,15 @@ DebugMenuPopulate(void)
 #define _TEST1
 // Custom added by kelson8, these can be disabled by commenting out CUSTOM_CODE in config.h
 #ifdef _TEST1
-		//DebugMenuAddCmd("Cheats", "Infinite Health", CustomCheats::InfiniteHealthCheat);
-		//DebugMenuAddCmd("Cheats", "Never wanted", CustomCheats::NeverWantedCheat);
+		// DebugMenuAddCmd("Cheats", "Infinite Health", CustomCheats::InfiniteHealthCheat);
+		// DebugMenuAddCmd("Cheats", "Never wanted", CustomCheats::NeverWantedCheat);
 		DebugMenuAddCmd("Cheats", "Infinite Health", PlayerCheats::InfiniteHealthCheat);
 		DebugMenuAddCmd("Cheats", "Never wanted", PlayerCheats::NeverWantedCheat);
 
-
-		//DebugMenuAddCmd("Cheats", "Invincible Vehicle", customCheats->InvincibleVehicleCheat);
+		// DebugMenuAddCmd("Cheats", "Invincible Vehicle", customCheats->InvincibleVehicleCheat);
 		DebugMenuAddCmd("Cheats", "Invincible Vehicle", vehicleCheats->InvincibleVehicleCheat);
 		DebugMenuAddCmd("Cheats", "Suicide", SuicideCheat);
 
-
 		// This adds another menu to it, i didn't know it was that simple.
 		// DebugMenuAddCmd("Test", "Suicide", SuicideCheat);
 
@@ -540,7 +1423,6 @@ DebugMenuPopulate(void)
 		// at a Pay N Spray
 		DebugMenuAddCmd("Cheats", "Toggle all vehicle repair", CGarages::ToggleRespray);
 
-
 		DebugMenuAddCmd("Cheats", "Drop a bomb", CustomCheats::ExplosionCheat);
 
 		DebugMenuAddCmd("Cheats", "Spawn Ped", CustomCheats::SpawnPedCheat);
@@ -590,7 +1472,7 @@ DebugMenuPopulate(void)
 		DebugMenuAddCmd("Cheats", "Tank", []() { VehicleCheat(MI_RHINO); });
 #else
 		DebugMenuAddCmd("Cheats", "Tank", []() { VehicleCheat(MI_TAXI); });
-#endif //CUSTOM_CODE
+#endif // CUSTOM_CODE
 
 #ifdef CUSTOM_CODE
 		DebugMenuAddCmd("Cheats", "Blow up cars", CustomCheats::BlowUpAllCars);
@@ -812,32 +1694,16 @@ DebugMenuPopulate(void)
 		//? I guess this is for toggling the interiors.
 		// Original define: UTILS
 #ifdef CUSTOM_CODE
-			static const char *areanames[] = {
-				"0 - Main map",
-				"1 - Hotel",
-				"2 - Mansion",
-				"3 - Bank",
-				"4 - Mall",
-				"5 - Strip club",
-				"6 - Lawyers",
-				"7 - Coffee shop",
-				"8 - Concert hall",
-				"9 - Studio",
-				"10 - Rifle range",
-				"11 - Biker bar",
-				"12 - Police station",
-				"13 - Everywhere",
-				"14 - Dirt",
-				"15 - Blood",
-				"16 - Ovalring", 
-				"17 - Malibu club", 
-				"18 - Print works",
+		static const char *areanames[] = {
+		    "0 - Main map",    "1 - Hotel",        "2 - Mansion",   "3 - Bank",         "4 - Mall",         "5 - Strip club",      "6 - Lawyers",
+		    "7 - Coffee shop", "8 - Concert hall", "9 - Studio",    "10 - Rifle range", "11 - Biker bar",   "12 - Police station", "13 - Everywhere",
+		    "14 - Dirt",       "15 - Blood",       "16 - Ovalring", "17 - Malibu club", "18 - Print works",
 		};
 		e = DebugMenuAddVar(
 		    "Game", "Current area", &CGame::currArea, []() { CStreaming::RemoveBuildingsNotInArea(CGame::currArea); }, 1, 0, ARRAY_SIZE(areanames) - 1,
 		    areanames);
 		DebugMenuEntrySetWrap(e, true);
-#endif //CUSTOM_CODE
+#endif // CUSTOM_CODE
 
 		// Mission list
 #ifdef MISSION_SWITCHER
@@ -951,7 +1817,7 @@ DebugMenuPopulate(void)
 		//*****************
 		// End Game functions
 		//*****************
-		
+
 		//*****************
 		// Begin Cam functions
 		//*****************
@@ -982,8 +1848,8 @@ DebugMenuPopulate(void)
 		// I have modified the original debug menu function for this.
 		// I basically copied the original debug function and made it use my spawn vehicle function,
 		// which removes the players current vehicle and warps them into a new one
-		// 
-		// TODO Fix the player warping into a vehicle, they sometimes get forced out of it, 
+		//
+		// TODO Fix the player warping into a vehicle, they sometimes get forced out of it,
 		// I guess it's something I'm doing in the function.
 		e = DebugMenuAddVar("Vehicle", "Spawn Vehicle id", &spawnCarId, nil, 1, MI_LANDSTAL, MI_VICECHEE, carnames);
 		DebugMenuEntrySetWrap(e, true);
@@ -1000,15 +1866,14 @@ DebugMenuPopulate(void)
 		DebugMenuAddCmd("Vehicle", "Remove vehicle", VehicleFunctions::RemoveCurrentVehicleFromWorld);
 		DebugMenuAddCmd("Vehicle", "Unlock all doors", VehicleFunctions::UnlockAllCarDoorsInPlayerArea);
 
-		#ifdef TOGGLE_UPSIDEDOWN_EXPLOSIONS
+#ifdef TOGGLE_UPSIDEDOWN_EXPLOSIONS
 		DebugMenuAddCmd("Vehicle", "Upside down explosions", VehicleFunctions::ToggleUpsideDownExplosions);
-		#endif //TOGGLE_UPSIDEDOWN_EXPLOSIONS
+#endif // TOGGLE_UPSIDEDOWN_EXPLOSIONS
 
 		//*****************
 		// End Custom Vehicle functions
 		//*****************
 
-
 		//*****************
 		// Begin test functions
 		//*****************
@@ -1018,28 +1883,28 @@ DebugMenuPopulate(void)
 		DebugMenuAddCmd("Test", "Enable alt police wpns", CustomCheats::EnableChangePoliceWeapons);
 		DebugMenuAddCmd("Test", "Disable alt police wpns", CustomCheats::DisableChangePoliceWeapons);
 
-		// This now crashes to the error under Read2BytesFromScript in Script.h
-		#ifdef PLUGIN_SDK_TEST
+// This now crashes to the error under Read2BytesFromScript in Script.h
+#ifdef PLUGIN_SDK_TEST
 		DebugMenuAddCmd("Test", "Plugin sdk command test", CustomCheats::CommandTest1);
-		#endif //PLUGIN_SDK_TEST
+#endif // PLUGIN_SDK_TEST
 
 		// TODO Setup this
 #ifdef EX_COP_FUNCTIONS
 		DebugMenuAddCmd("Test", "Toggle police spike strips", CustomCheats::TogglePoliceSpikeStrips);
-#endif //EX_COP_FUNCTIONS
-		// TODO Fix this to work right.
-		//DebugMenuAddCmd("Test", "Give RC Car", CustomCheats::GiveRcCar);
-		
+#endif // EX_COP_FUNCTIONS
+       //  TODO Fix this to work right.
+       // DebugMenuAddCmd("Test", "Give RC Car", CustomCheats::GiveRcCar);
+
 		// Misc testing
 		// Log to a test file.
 		DebugMenuAddCmd("Test", "Log test", LogFunctions::LogText);
 		// Check if file exists
 		DebugMenuAddCmd("Test", "Check file", LogFunctions::DoesFileExistTest);
 		// Old function
-		//DebugMenuAddCmd("Test", "Log test N", LogFunctions::LogTest);
+		// DebugMenuAddCmd("Test", "Log test N", LogFunctions::LogTest);
 
 		// Menu test, this shows up in the game under DoRWStuffEndOfFrame in main.cpp
-		//DebugMenuAddCmd("Test", "Menu test", CustomCheats::SetText);
+		// DebugMenuAddCmd("Test", "Menu test", CustomCheats::SetText);
 		// Test for toggling the text
 		DebugMenuAddCmd("Test", "Display text", CustomCheats::ToggleText);
 
@@ -1051,27 +1916,24 @@ DebugMenuPopulate(void)
 		DebugMenuAddCmd("Test", "Toggle ImGui", toggleImGui);
 #endif
 
-
 		// TODO Setup police weapon changing here.
 		// TODO Finish setting this up.
 #ifdef EX_COP_FUNCTIONS
 		// TODO Make this variable public, like my other ones.
 		// streetCopWeaponId
 		static int weaponId = WEAPONTYPE_COLT45;
-		//e = DebugMenuAddVar("Test", "Street cop weapons", &weaponId, nil, 1, WEAPONTYPE_COLT45, WEAPONTYPE_M4, policeWeaponNames);
+		// e = DebugMenuAddVar("Test", "Street cop weapons", &weaponId, nil, 1, WEAPONTYPE_COLT45, WEAPONTYPE_M4, policeWeaponNames);
 		e = DebugMenuAddVar("Test", "Street cop weapons", &weaponId, nil, 1, WEAPONTYPE_COLT45, WEAPONTYPE_M4, policeWeaponNames);
 		DebugMenuEntrySetWrap(e, true);
 
-		
 		// DebugMenuAddCmd("Test", "Set weapons", []() {
 		// 	// Make them not get specifc weapons
 		// 	// if(weaponId == WEAPONTYPE_SILENCED_INGRAM) return;
 		// 	VehicleFunctions::SpawnVehicle(spawnCarId, true, true);
 		// });
-#endif //EX_COP_FUNCTIONS
+#endif // EX_COP_FUNCTIONS
 
-
-#endif //CUSTOM_CODE
+#endif // CUSTOM_CODE
 
 		//*****************
 		// End test functions
@@ -1082,5 +1944,4 @@ DebugMenuPopulate(void)
 }
 #endif
 
-
 #endif //_MOVE_DEBUG_FILE
\ No newline at end of file
diff --git a/src/extras/debugmenu.cpp b/src/extras/debugmenu.cpp
index 810e8afe..8daef926 100644
--- a/src/extras/debugmenu.cpp
+++ b/src/extras/debugmenu.cpp
@@ -9,6 +9,10 @@
 #include "debugmenu.h"
 #include <new>
 
+#ifdef VEHICLE_MODS // mod garage
+#include "Garages.h"
+#endif
+
 #ifdef _WIN32
 #define snprintf _snprintf
 
@@ -75,23 +79,78 @@ createMenuFont(void)
 {
 	OpenCharsetSafe();
 
+
+#ifdef VEHICLE_MODS // mod garage
+	RwRGBA fg_normal;
+	RwRGBA bg_normal;
+	if (CGarages::bPlayerInModGarage) {
+		fg_normal = { 255, 200, 255, 255 };
+		bg_normal = { 0, 0, 0, 125 };
+	} else {
+		fg_normal = { 255, 255, 255, 255 };
+		bg_normal = { 255, 255, 255, 0 };
+	}
+#else
 	RwRGBA fg_normal = { 255, 255, 255, 255 };
 	RwRGBA bg_normal = { 255, 255, 255, 0 };
+#endif
+
 	fontStyles[MENUFONT_NORMAL] = RtCharsetCreate(&fg_normal, &bg_normal);
 	assert(fontStyles[MENUFONT_NORMAL]);
 
+#ifdef VEHICLE_MODS // mod garage
+	RwRGBA fg_sel_active;
+	RwRGBA bg_sel_active;
+	if (CGarages::bPlayerInModGarage) {
+		fg_sel_active = { 255, 150, 255, 255 };
+		bg_sel_active = { 0, 125, 0, 255 };
+	} else {
+		fg_sel_active = { 200, 200, 200, 255 };
+		bg_sel_active = { 132, 132, 132, 255 };
+	}
+#else
 	RwRGBA fg_sel_active = { 200, 200, 200, 255 };
 	RwRGBA bg_sel_active = { 132, 132, 132, 255 };
+#endif
+
+
 	fontStyles[MENUFONT_SEL_ACTIVE] = RtCharsetCreate(&fg_sel_active, &bg_sel_active);
 	assert(fontStyles[MENUFONT_SEL_ACTIVE]);
 
+#ifdef VEHICLE_MODS // mod garage
+	RwRGBA fg_sel_inactive;
+	RwRGBA bg_sel_inactive;
+	if (CGarages::bPlayerInModGarage) {
+		fg_sel_inactive = { 255, 150, 255, 255 };
+		bg_sel_inactive = { 0, 75, 0, 255 };
+	} else {
+		fg_sel_inactive = { 200, 200, 200, 255 };
+		bg_sel_inactive = { 200, 200, 200, 0 };
+	}
+#else
 	RwRGBA fg_sel_inactive = { 200, 200, 200, 255 };
 	RwRGBA bg_sel_inactive = { 200, 200, 200, 0 };
+#endif
+
+
 	fontStyles[MENUFONT_SEL_INACTIVE] = RtCharsetCreate(&fg_sel_inactive, &bg_sel_inactive);
 	assert(fontStyles[MENUFONT_SEL_INACTIVE]);
 
+#ifdef VEHICLE_MODS // mod garage
+	RwRGBA fg_mouse;
+	RwRGBA bg_mouse;
+	if (CGarages::bPlayerInModGarage) {
+		fg_mouse = { 255, 200, 255, 255 };
+		bg_mouse = { 0, 100, 0, 255 };
+	} else {
+		fg_mouse = { 255, 255, 255, 255 };
+		bg_mouse = { 132, 132, 132, 255 };
+	}
+#else
 	RwRGBA fg_mouse = { 255, 255, 255, 255 };
 	RwRGBA bg_mouse = { 132, 132, 132, 255 };
+#endif
+
 	fontStyles[MENUFONT_MOUSE] = RtCharsetCreate(&fg_mouse, &bg_mouse);
 	assert(fontStyles[MENUFONT_MOUSE]);
 
@@ -504,9 +563,15 @@ FLOATTYPES
 void
 MenuEntry_Cmd::processInput(bool mouseOver, bool selected)
 {
+#ifdef VEHICLE_MODS // mod garage
+	CPad* pad = CPad::GetPad(0);
+	if (this->triggerFunc && (selected && (pad->IsAffectedByController && pad->GetCrossJustUp()) || pad->GetReturnJustUp() || (mouseOver && button1justdown)))
+		this->triggerFunc();
+#else
 	// Don't execute on button3
 	if(this->triggerFunc && (selected && (leftjustdown || rightjustdown) || (mouseOver && button1justdown)))
 		this->triggerFunc();
+#endif
 }
 
 void
@@ -754,8 +819,12 @@ findMenu(const char *name)
 			Menu *submenu = new Menu();
 			submenu->parent = m;
 			MenuEntry *me = new MenuEntry_Sub(curname, submenu);
+#ifdef VEHICLE_MODS // don't sort entries when a player is in the mod garage
+			if (m == &toplevel && !CGarages::bPlayerInModGarage)
+#else
 			// Don't sort submenus outside the toplevel menu
 			if(m == &toplevel)
+#endif
 				m->insertEntrySorted(me);
 			else
 				m->appendEntry(me);
@@ -930,10 +999,19 @@ processInput(void)
 		activeMenu->scroll(shift ? -5 : -1);
 	if(pgdnjustdown)
 		activeMenu->scroll(shift ? 5 : 1);
+
+#ifdef VEHICLE_MODS // mod garage
+	CPad* pad = CPad::GetPad(0);
+	if (downjustdown || (pad->IsAffectedByController && pad->GetDPadDownJustDown()))
+		activeMenu->changeSelection(activeMenu->selection + (shift ? 5 : 1));
+	if (upjustdown || (pad->IsAffectedByController && pad->GetDPadUpJustDown()))
+		activeMenu->changeSelection(activeMenu->selection - (shift ? 5 : 1));
+#else
 	if(downjustdown)
 		activeMenu->changeSelection(activeMenu->selection + (shift ? 5 : 1));
 	if(upjustdown)
 		activeMenu->changeSelection(activeMenu->selection - (shift ? 5 : 1));
+#endif
 
 	if(CPad::NewMouseControllerState.WHEELUP){
 		if(mouseOverMenu)
@@ -959,11 +1037,42 @@ processInput(void)
 		}
 	}
 
-	// Have to call this before processInput below because menu entry can change
+#ifdef VEHICLE_MODS // mod garage
 	if((button1justdown || button3justdown) && mouseOverEntry){
+		if (CGarages::bPlayerInModGarage && activeMenu->selectedEntry->type == MENUSUB)
+			CGarages::TryChangeCameraInModGarage(activeMenu->selectedEntry->name);
+
 		activeMenu = mouseOverEntry->menu;
 		activeMenu->changeSelection(mouseOverEntry);
 	}
+
+	if(pad->IsAffectedByController && pad->GetCrossJustUp() || pad->GetReturnJustUp()){
+		if (CGarages::bPlayerInModGarage && activeMenu->selectedEntry->type == MENUSUB)
+			CGarages::TryChangeCameraInModGarage(activeMenu->selectedEntry->name);
+
+		if (activeMenu->selectedEntry && activeMenu->selectedEntry->type == MENUVAR &&
+			mouseOverEntry != activeMenu->selectedEntry)
+			((MenuEntry_Var*)activeMenu->selectedEntry)->processInput(false, true);
+
+		if(activeMenu->selectedEntry && activeMenu->selectedEntry->type == MENUSUB)
+			activeMenu = ((MenuEntry_Sub*)activeMenu->selectedEntry)->submenu;
+	}else if(pad->IsAffectedByController && pad->GetCircleJustDown() || KEYJUSTDOWN(rsBACKSP)){
+		if(activeMenu->parent)
+			activeMenu = activeMenu->parent;
+	}else{
+		if (mouseOverEntry && mouseOverEntry->type == MENUVAR)
+			((MenuEntry_Var*)mouseOverEntry)->processInput(true, mouseOverEntry == activeMenu->selectedEntry);
+		if (activeMenu->selectedEntry && activeMenu->selectedEntry->type == MENUVAR &&
+			mouseOverEntry != activeMenu->selectedEntry)
+			((MenuEntry_Var*)activeMenu->selectedEntry)->processInput(false, true);
+	}
+#else
+	// Have to call this before processInput below because menu entry can change
+	if ((button1justdown || button3justdown) && mouseOverEntry) {
+		activeMenu = mouseOverEntry->menu;
+		activeMenu->changeSelection(mouseOverEntry);
+	}
+
 	if(KEYJUSTDOWN(rsENTER)){
 		if(activeMenu->selectedEntry && activeMenu->selectedEntry->type == MENUSUB)
 			activeMenu = ((MenuEntry_Sub*)activeMenu->selectedEntry)->submenu;
@@ -977,6 +1086,7 @@ processInput(void)
 		   mouseOverEntry != activeMenu->selectedEntry)
 			((MenuEntry_Var*)activeMenu->selectedEntry)->processInput(false, true);
 	}
+#endif
 }
 
 void
@@ -1015,7 +1125,17 @@ DebugMenuProcess(void)
 	// We only process some input here
 
 	CPad *pad = CPad::GetPad(0);
+
+#ifdef VEHICLE_MODS // mod garage
+	if (!menuOn && CGarages::bPlayerInModGarage)
+		menuOn = true;
+	else if (menuOn && CGarages::bPlayerShouldBeLeaveModGarage) {
+		menuOn = false;
+	} else if (CTRLJUSTDOWN('M') && !CGarages::bPlayerInModGarage)
+#else
 	if(CTRLJUSTDOWN('M'))
+#endif
+
 		menuOn = !menuOn;
 	if(!menuOn)
 		return;
@@ -1033,7 +1153,12 @@ DebugMenuProcess(void)
 void
 DebugMenuRender(void)
 {
+#ifdef VEHICLE_MODS // mod garage
+	if(!menuOn || CGarages::bPlayerShouldBeLeaveModGarage)
+#else
 	if(!menuOn)
+#endif
+
 		return;
 
 	RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
@@ -1054,7 +1179,12 @@ DebugMenuRender(void)
 		fontscale = 1;
 
 	Pt sz;
+
+#ifdef VEHICLE_MODS // mod garage
+	sz = fontPrint(CGarages::bPlayerInModGarage ? "Vice City Customs" : "Debug Menu", firstBorder*fontscale+30, topBorder, 0);
+#else
 	sz = fontPrint("Debug Menu", firstBorder*fontscale+30, topBorder, 0);
+#endif
 
 	toplevel.r.x = firstBorder*fontscale;
 	toplevel.r.y = topBorder + sz.y + 10;
diff --git a/src/extras/functions/ini_functions.cpp b/src/extras/functions/ini_functions.cpp
index 8c48dc35..b83f229f 100644
--- a/src/extras/functions/ini_functions.cpp
+++ b/src/extras/functions/ini_functions.cpp
@@ -80,8 +80,8 @@
 mINI::INIFile ini("reVC.ini");
 mINI::INIStructure cfg;
 
-#define FEATURES_INI
-#ifdef FEATURES_INI
+// FEATURES_INI
+#ifdef VICE_EXTENDED
 mINI::INIFile featuresIni("ViceExtended/features.ini");
 mINI::INIStructure featuresCfg;
 
@@ -132,6 +132,54 @@ IniFunctions::ReadIniIfExists(const char *cat, const char *key, uint8 *out)
 ///////////////////
 
 
+// #ifdef VICE_EXTENDED // Game limits
+// mINI::INIFile limitsIni("ViceExtended/limits.ini");
+// mINI::INIStructure limitsCfg;
+
+// uint8 bInitLimitsIni = limitsIni.read(limitsCfg);
+
+// uint16 ReadAndGetGameLimit(const char* key)
+// {
+// 	mINI::INIMap<std::string> section = limitsCfg.get("Limits");
+// 	if (section.has(key)) {
+// 		char* endPtr;
+// 		return strtol(section.get(key).c_str(), &endPtr, 0);
+// 	}
+// 	return 0;
+// }
+
+// extern uint16 NUMPTRNODES = ReadAndGetGameLimit("NUMPTRNODES");
+// extern uint16 NUMENTRYINFOS = ReadAndGetGameLimit("NUMENTRYINFOS");
+// extern uint16 NUMPEDS = ReadAndGetGameLimit("NUMPEDS");
+// extern uint16 NUMVEHICLES = ReadAndGetGameLimit("NUMVEHICLES");
+// extern uint16 NUMBUILDINGS = ReadAndGetGameLimit("NUMBUILDINGS");
+// extern uint16 NUMTREADABLES = ReadAndGetGameLimit("NUMTREADABLES");
+// extern uint16 NUMOBJECTS = ReadAndGetGameLimit("NUMOBJECTS");
+// extern uint16 NUMDUMMIES = ReadAndGetGameLimit("NUMDUMMIES");
+// extern uint16 NUMAUDIOSCRIPTOBJECTS = ReadAndGetGameLimit("NUMAUDIOSCRIPTOBJECTS");
+// extern uint16 NUMCOLMODELS = ReadAndGetGameLimit("NUMCOLMODELS");
+// extern uint16 MAXWHEELMODELS = ReadAndGetGameLimit("MAXWHEELMODELS");
+// #endif
+
+#ifdef FEATURES_INI
+
+// TODO Implement these
+extern bool bVehiclesDontCatchFireWhenTurningOver = ReadAndGetFeature("VehiclesDontCatchFireWhenTurningOver");
+extern bool bHealthRegenerationUpToHalf = ReadAndGetFeature("HealthRegenerationUpToHalf");
+extern bool bWantedStarsHideOnScreenWhenThereIsNoSearch = ReadAndGetFeature("WantedStarsHideOnScreenWhenThereIsNoSearch");
+extern bool bRemoveMoneyZerosInTheHud = ReadAndGetFeature("RemoveMoneyZerosInTheHud");
+extern bool bPlayerDoesntBounceAwayFromMovingCar = ReadAndGetFeature("PlayerDoesntBounceAwayFromMovingCar");
+
+// This one should work
+extern bool bStandardCarsUseTurnSignals = ReadAndGetFeature("StandardCarsUseTurnSignals");
+
+// TODO Implement these
+extern bool bCameraShakeInVehicleAtHighSpeed = ReadAndGetFeature("CameraShakeInVehicleAtHighSpeed");
+extern bool bMilitaryFiringFromTankAtPlayer = ReadAndGetFeature("MilitaryFiringFromTankAtPlayer");
+extern bool bDisableBulletTraces = ReadAndGetFeature("DisableBulletTraces");
+
+#endif
+
 #ifdef EX_GPS
 
 CRGBA ReadAndGetWaypointColor(const char* key)
diff --git a/src/modelinfo/ModelIndices.h b/src/modelinfo/ModelIndices.h
index 836c4092..08efae09 100644
--- a/src/modelinfo/ModelIndices.h
+++ b/src/modelinfo/ModelIndices.h
@@ -466,6 +466,60 @@ enum
 
 
 	NUM_DEFAULT_MODELS,// = 300
+
+#ifdef VEHICLE_MODS
+	MI_FIRST_NEW_WHEEL = 6600,
+	MI_WHEEL_CLASSIC2 = MI_FIRST_NEW_WHEEL,
+	MI_WHEEL_SALOON2,
+	MI_WHEEL_LIGHTTRUCK2,
+	MI_WHEEL_OFFROAD2,
+	MI_WHEEL_SALOON3,
+	MI_WHEEL_16,
+	MI_WHEEL_17,
+	MI_WHEEL_18,
+	MI_WHEEL_19,
+	MI_WHEEL_20,
+	MI_WHEEL_21,
+	MI_WHEEL_22,
+	MI_WHEEL_23,
+	MI_WHEEL_24,
+	MI_WHEEL_25,
+	MI_WHEEL_26,
+	MI_WHEEL_27,
+	MI_WHEEL_28,
+	MI_WHEEL_29,
+	MI_WHEEL_30,
+	NUM_NEW_WHEEL_MODELS,
+
+	MI_FIRST_VEH_MOD = 6620,
+	MI_SPOILER_1 = MI_FIRST_VEH_MOD,
+	MI_SPOILER_2,
+	MI_SPOILER_3,
+	MI_SPOILER_4,
+	MI_SPOILER_5,
+	MI_SPOILER_6,
+	MI_SPOILER_7,
+	MI_SPOILER_8,
+	MI_SPOILER_9,
+	MI_SIDE_SKIRT_L_1 = 6630,
+	MI_SIDE_SKIRT_R_1,
+	MI_BNT_SCOOP_1 = 6640,
+	MI_BNT_SCOOP_2,
+	MI_BNT_SCOOP_3,
+	MI_BNT_SCOOP_4,
+	MI_RF_SCOOP_1 = 6645,
+	MI_BNT_VENT_L_1 = 6650,
+	MI_BNT_VENT_L_1_DAM,
+	MI_BNT_VENT_R_1,
+	MI_BNT_VENT_R_1_DAM,
+	MI_BNT_VENT_L_2,
+	MI_BNT_VENT_L_2_DAM,
+	MI_BNT_VENT_R_2,
+	MI_BNT_VENT_R_2_DAM,
+	MI_SC_SABRE_BONNET_OK,
+	MI_SC_SABRE_BONNET_DAM,
+	NUM_VEH_MODS,
+#endif
 };
 
 enum{
diff --git a/src/modelinfo/ModelInfo.cpp b/src/modelinfo/ModelInfo.cpp
index 41515e20..17461f7b 100644
--- a/src/modelinfo/ModelInfo.cpp
+++ b/src/modelinfo/ModelInfo.cpp
@@ -177,6 +177,12 @@ CModelInfo::AddVehicleModel(int id)
 	modelinfo->m_wheelId = -1;
 	modelinfo->m_materials1[0] = nil;
 	modelinfo->m_materials2[0] = nil;
+
+#ifdef IMPROVED_VEHICLES // More colors
+	modelinfo->m_materials3[0] = nil;
+	modelinfo->m_materials4[0] = nil;
+#endif
+
 	modelinfo->m_bikeSteerAngle = 999.99f;
 	return modelinfo;
 }
diff --git a/src/modelinfo/VehicleModelInfo.cpp b/src/modelinfo/VehicleModelInfo.cpp
index b991b7fe..9dc26011 100644
--- a/src/modelinfo/VehicleModelInfo.cpp
+++ b/src/modelinfo/VehicleModelInfo.cpp
@@ -48,6 +48,11 @@ enum {
 	VEHICLE_FLAG_ANGLECULL	= 0x1000,
 	VEHICLE_FLAG_REARDOOR	= 0x2000,
 	VEHICLE_FLAG_FRONTDOOR	= 0x4000,
+
+#ifdef VEHICLE_MODS // vehicle flags
+	VEHICLE_FLAG_VEHMOD_OK = 0x8000,
+	VEHICLE_FLAG_VEHMOD_DAM = 0x16000,
+#endif
 };
 
 RwObjectNameIdAssocation carIds[] = {
@@ -71,10 +76,79 @@ RwObjectNameIdAssocation carIds[] = {
 	{ "bump_rear_dummy",	CAR_BUMP_REAR,	VEHICLE_FLAG_REAR | VEHICLE_FLAG_COLLAPSE },
 	{ "windscreen_dummy",	CAR_WINDSCREEN,	VEHICLE_FLAG_WINDSCREEN | VEHICLE_FLAG_DRAWLAST | VEHICLE_FLAG_FRONT | VEHICLE_FLAG_COLLAPSE },
 
+#ifdef VEHICLE_MODS
+	{ "vm_spoiler_ok",	CAR_SPOILER_OK,	VEHICLE_FLAG_REAR | VEHICLE_FLAG_VEHMOD_OK},
+	{ "vm_spoiler_dam",	CAR_SPOILER_DAM,	VEHICLE_FLAG_REAR | VEHICLE_FLAG_VEHMOD_DAM},
+	{ "vm_skirt_l",		CAR_SKIRT_L,	VEHICLE_FLAG_LEFT | VEHICLE_FLAG_VEHMOD_OK},
+	{ "vm_skirt_r",		CAR_SKIRT_R,	VEHICLE_FLAG_RIGHT | VEHICLE_FLAG_VEHMOD_OK},
+	{ "vm_rf_scoop",	CAR_RF_SCOOP,	VEHICLE_FLAG_VEHMOD_OK},
+	{ "vm_bnt_scoop_ok",	CAR_BNT_SCOOP_OK,	VEHICLE_FLAG_VEHMOD_OK},
+	{ "vm_bnt_scoop_dam",	CAR_BNT_SCOOP_DAM,	VEHICLE_FLAG_VEHMOD_DAM},
+	{ "vm_vent_l_ok",		CAR_VENT_L_OK,	VEHICLE_FLAG_VEHMOD_OK},
+	{ "vm_vent_l_dam",		CAR_VENT_L_DAM,	VEHICLE_FLAG_VEHMOD_DAM},
+	{ "vm_vent_r_ok",		CAR_VENT_R_OK,	VEHICLE_FLAG_VEHMOD_OK},
+	{ "vm_vent_r_dam",		CAR_VENT_R_DAM,	VEHICLE_FLAG_VEHMOD_DAM},
+	//{ "vm_supercharger",	CAR_SUPERCHARGER,	VEHICLE_FLAG_VEHMOD_DAM},
+#endif
+
+#ifdef IMPROVED_VEHICLES_2
+	{ "steeringwheel",	CAR_STEERINGWHEEL,	VEHICLE_FLAG_LEFT },
+	
+	{ "headlight_l",			CAR_HEADLIGHT_L,	VEHICLE_FLAG_LEFT | VEHICLE_FLAG_DRAWLAST },
+	{ "headlight_l_hi",			CAR_HEADLIGHT_L,	VEHICLE_FLAG_LEFT | VEHICLE_FLAG_DRAWLAST },
+	{ "taillight_l",			CAR_TAILLIGHT_L,	VEHICLE_FLAG_LEFT },
+	{ "reversinglight_l",		CAR_REVERSINGLIGHT_L,	VEHICLE_FLAG_LEFT },
+	{ "brakelight_l",			CAR_BRAKELIGHT_L,	VEHICLE_FLAG_LEFT },
+	{ "indicator_lf",			CAR_INDICATOR_LF,	VEHICLE_FLAG_LEFT },
+	{ "indicator2_lf",			CAR_INDICATOR_2_LF,	VEHICLE_FLAG_LEFT },
+	{ "indicator_lr",			CAR_INDICATOR_LR,	VEHICLE_FLAG_LEFT },
+	{ "indicator2_lr",			CAR_INDICATOR_2_LR,	VEHICLE_FLAG_LEFT },
+	{ "window_misc_l_hi",		CAR_WINDOW_L_MISC,	VEHICLE_FLAG_LEFT | VEHICLE_FLAG_DRAWLAST},
+
+	{ "window_rear_hi",			CAR_WINDOW_REAR,	VEHICLE_FLAG_REAR | VEHICLE_FLAG_DRAWLAST},
+
+	{ "headlight_r",			CAR_HEADLIGHT_R,	VEHICLE_FLAG_RIGHT | VEHICLE_FLAG_DRAWLAST },
+	{ "headlight_r_hi",			CAR_HEADLIGHT_R,	VEHICLE_FLAG_RIGHT | VEHICLE_FLAG_DRAWLAST },
+	{ "taillight_r",			CAR_TAILLIGHT_R,	VEHICLE_FLAG_RIGHT },
+	{ "reversinglight_r",		CAR_REVERSINGLIGHT_R,	VEHICLE_FLAG_RIGHT },
+	{ "brakelight_r",			CAR_BRAKELIGHT_R,	VEHICLE_FLAG_RIGHT },
+	{ "indicator_rf",			CAR_INDICATOR_RF,	VEHICLE_FLAG_RIGHT },
+	{ "indicator2_rf",			CAR_INDICATOR_2_RF,	VEHICLE_FLAG_RIGHT },
+	{ "indicator_rr",			CAR_INDICATOR_RR,	VEHICLE_FLAG_RIGHT },
+	{ "indicator2_rr",			CAR_INDICATOR_2_RR,	VEHICLE_FLAG_RIGHT },
+	{ "window_misc_r_hi",		CAR_WINDOW_R_MISC,	VEHICLE_FLAG_RIGHT | VEHICLE_FLAG_DRAWLAST},
+#endif
+#ifdef IMPROVED_VEHICLES // Service lights for service cars and cleareance lights
+	{ "servicelights_0",	CAR_SERVICELIGHTS_0,	VEHICLE_FLAG_DRAWLAST },
+	{ "servicelights_1",	CAR_SERVICELIGHTS_1,	VEHICLE_FLAG_DRAWLAST },
+	{ "servicelights_2",	CAR_SERVICELIGHTS_2,	VEHICLE_FLAG_DRAWLAST },
+	{ "servicelights_3",	CAR_SERVICELIGHTS_3,	VEHICLE_FLAG_DRAWLAST },
+	{ "clearance_lights",	CAR_CLEARANCE_LIGHTS,	VEHICLE_FLAG_DRAWLAST },
+#endif
+
 	{ "ped_frontseat",	CAR_POS_FRONTSEAT,	VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
 	{ "ped_backseat",	CAR_POS_BACKSEAT,	VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
 	{ "headlights",		CAR_POS_HEADLIGHTS,	VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
 	{ "taillights",		CAR_POS_TAILLIGHTS,	VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+
+
+#ifdef IMPROVED_VEHICLES_2
+	{ "headlights2",			CAR_POS_HEADLIGHTS_2,	VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "taillights2",			CAR_POS_TAILLIGHTS_2,	VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "reversinglights",		CAR_POS_REVERSINGLIGHTS, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "reversinglights2",		CAR_POS_REVERSINGLIGHTS_2, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "brakelights",			CAR_POS_BRAKELIGHTS, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "brakelights2",			CAR_POS_BRAKELIGHTS_2, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "indicators_f",			CAR_POS_INDICATORS_F, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "indicators_r",			CAR_POS_INDICATORS_R, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "indicators2_f",			CAR_POS_INDICATORS_2_F, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "indicators2_r",			CAR_POS_INDICATORS_2_R, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "engine",					CAR_POS_ENGINE, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "overheat",				CAR_POS_OVERHEAT, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "overheat2",				CAR_POS_OVERHEAT_2, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "petrolcap",				CAR_POS_PETROLCAP, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+#endif
+
 	{ "exhaust",		CAR_POS_EXHAUST,	VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
 	{ "extra1",		0, VEHICLE_FLAG_DRAWLAST | VEHICLE_FLAG_COMP | CLUMP_FLAG_NO_HIERID },
 	{ "extra2",		0, VEHICLE_FLAG_DRAWLAST | VEHICLE_FLAG_COMP | CLUMP_FLAG_NO_HIERID },
@@ -146,11 +220,30 @@ RwObjectNameIdAssocation bikeIds[] = {
 	{ "wheel_rear",		BIKE_WHEEL_REAR,	0 },
 	{ "mudguard",		BIKE_MUDGUARD,	0 },
 	{ "handlebars",		BIKE_HANDLEBARS,	0 },
+
+#ifdef IMPROVED_VEHICLES_2
+	{ "headlight_l",	BIKE_HEADLIGHT_L,	VEHICLE_FLAG_FRONT },
+	{ "taillight_l",	BIKE_TAILLIGHT_L,	VEHICLE_FLAG_LEFT },
+	{ "indicator_lf",	BIKE_INDICATOR_LF,	VEHICLE_FLAG_LEFT },
+	{ "indicator_lr",	BIKE_INDICATOR_LR,	VEHICLE_FLAG_LEFT },
+	{ "indicator_rf",	BIKE_INDICATOR_RF,	VEHICLE_FLAG_RIGHT },
+	{ "indicator_rr",	BIKE_INDICATOR_RR,	VEHICLE_FLAG_RIGHT },
+#endif
+
 	{ "ped_frontseat",	CAR_POS_FRONTSEAT,	VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
 	{ "ped_backseat",	CAR_POS_BACKSEAT,	VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
 	{ "headlights",		CAR_POS_HEADLIGHTS,	VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
 	{ "taillights",		CAR_POS_TAILLIGHTS,	VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
 	{ "exhaust",		CAR_POS_EXHAUST,	VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+
+#ifdef IMPROVED_VEHICLES_2
+	{ "indicators_f",	CAR_POS_INDICATORS_F, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "indicators_r",	CAR_POS_INDICATORS_R, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "overheat",		CAR_POS_OVERHEAT, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "overheat2",		CAR_POS_OVERHEAT_2, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+	{ "petrolcap",		CAR_POS_PETROLCAP, VEHICLE_FLAG_POS | CLUMP_FLAG_NO_HIERID },
+#endif
+
 	{ "extra1",		0,	VEHICLE_FLAG_DRAWLAST | VEHICLE_FLAG_COMP | CLUMP_FLAG_NO_HIERID },
 	{ "extra2",		0,	VEHICLE_FLAG_DRAWLAST | VEHICLE_FLAG_COMP | CLUMP_FLAG_NO_HIERID },
 	{ "extra3",		0,	VEHICLE_FLAG_DRAWLAST | VEHICLE_FLAG_COMP | CLUMP_FLAG_NO_HIERID },
@@ -183,6 +276,10 @@ CVehicleModelInfo::CVehicleModelInfo(void)
 	}
 	m_numColours = 0;
 	m_animFileIndex = -1;
+
+#ifdef IMPROVED_VEHICLES_2
+	bNewLights = false;
+#endif
 }
 
 void
@@ -253,6 +350,22 @@ CVehicleModelInfo::SetClump(RpClump *clump)
 	PreprocessHierarchy();
 	FindEditableMaterialList();
 	SetEnvironmentMap();
+
+#ifdef IMPROVED_VEHICLES_2 // set light textures
+	RwTexDictionary* modelTxd = CTxdStore::GetSlot(GetTxdSlot())->texDict;
+
+	if (modelTxd) {
+		lightsOffTexture = RwTexDictionaryFindNamedTexture(modelTxd, "lights");
+		lightsOnTexture = RwTexDictionaryFindNamedTexture(modelTxd, "lightson");
+	}
+#endif
+
+#ifdef IMPROVED_VEHICLES // Service lights for service cars - init
+	if (modelTxd) {
+		serviceLightsOffTexture = RwTexDictionaryFindNamedTexture(modelTxd, "servicelights");
+		serviceLightsOnTexture = RwTexDictionaryFindNamedTexture(modelTxd, "servicelightson");
+	}
+#endif
 }
 
 void
@@ -279,6 +392,16 @@ CVehicleModelInfo::ConvertAnimFileIndex(void)
 RwFrame*
 CVehicleModelInfo::CollapseFramesCB(RwFrame *frame, void *data)
 {
+#ifdef IMPROVED_VEHICLES_2 // don't move light frame
+	if (strstr(GetFrameNodeName(frame), "light_l") || strstr(GetFrameNodeName(frame), "light_r") || strstr(GetFrameNodeName(frame), "indicator"))
+		return frame;
+#endif
+
+#ifdef VEHICLE_MODS // don't move upgrade frame
+	if (strstr(GetFrameNodeName(frame), "vm_"))
+		return frame;
+#endif
+
 	RwFrameForAllChildren(frame, CollapseFramesCB, data);
 	RwFrameForAllObjects(frame, MoveObjectsCB, data);
 	RwFrameDestroy(frame);
@@ -306,6 +429,13 @@ CVehicleModelInfo::HideDamagedAtomicCB(RpAtomic *atomic, void *data)
 RpAtomic*
 CVehicleModelInfo::HideAllComponentsAtomicCB(RpAtomic *atomic, void *data)
 {
+#ifdef VEHICLE_MODS
+	if (strstr(GetFrameNodeName(RpAtomicGetFrame(atomic)), "supercharger") ||
+		strstr(GetFrameNodeName(RpAtomicGetFrame(atomic)), "carb") ||
+		strstr(GetFrameNodeName(RpAtomicGetFrame(atomic)), "flywheel"))
+		return atomic;
+#endif
+
 	if(CVisibilityPlugins::GetAtomicId(atomic) & (uintptr)data)
 		RpAtomicSetFlags(atomic, 0);
 	else
@@ -335,11 +465,22 @@ CVehicleModelInfo::SetAtomicRendererCB(RpAtomic *atomic, void *data)
 	name = GetFrameNodeName(RpAtomicGetFrame(atomic));
 	alpha = false;
 	RpGeometryForAllMaterials(RpAtomicGetGeometry(atomic), HasAlphaMaterialCB, &alpha);
+
+#ifdef IMPROVED_VEHICLES_2
+	if (strstr(name, "_hi") || !CGeneral::faststrncmp(name, "extra", 5)) {
+		if (alpha || strncmp(name, "windscreen", 10) == 0) {
+			CVisibilityPlugins::SetAtomicRenderCallback(atomic, CVisibilityPlugins::RenderVehicleHiDetailAlphaCB);
+			if (strncmp(name, "window", 6) == 0)
+				CVisibilityPlugins::SetAtomicFlag(atomic, ATOMIC_FLAG_DOORWINDOW);
+		} else
+			CVisibilityPlugins::SetAtomicRenderCallback(atomic, CVisibilityPlugins::RenderVehicleHiDetailCB);
+#else
 	if(strstr(name, "_hi") || !CGeneral::faststrncmp(name, "extra", 5)) {
 		if(alpha || strncmp(name, "windscreen", 10) == 0)
 			CVisibilityPlugins::SetAtomicRenderCallback(atomic, CVisibilityPlugins::RenderVehicleHiDetailAlphaCB);
 		else
 			CVisibilityPlugins::SetAtomicRenderCallback(atomic, CVisibilityPlugins::RenderVehicleHiDetailCB);
+#endif
 	}else if(strstr(name, "_lo")){
 		RpClumpRemoveAtomic(clump, atomic);
 		RpAtomicDestroy(atomic);
@@ -601,6 +742,76 @@ CVehicleModelInfo::PreprocessHierarchy(void)
 
 		SetVehicleComponentFlags(assoc.frame, desc[i].flags);
 
+#ifdef VEHICLE_MODS // set default window material color
+		if (strncmp(desc[i].name, "door_lf_dummy", 13) == 0) {
+			RpAtomic* doorAtomic = nil;
+			RwFrameForAllObjects(assoc.frame, GetCurrentAtomicObjectCB, &doorAtomic);
+			if (doorAtomic) {
+				for (int i = 0; i < doorAtomic->geometry->matList.numMaterials; i++) {
+					RpMaterial* material = doorAtomic->geometry->matList.materials[i];
+
+					if (material->color.alpha == 255)
+						continue;
+
+					m_nDefaultWindowMaterialColor = material->color;
+					break;
+				}
+			}
+
+			continue;
+		}
+#endif
+
+#ifdef IMPROVED_VEHICLES_2 // set default window material color
+		if (strncmp(desc[i].name, "door_lf_dummy", 13) == 0) {
+			RpAtomic* windowAtomic = nil;
+			RwFrameForAllObjects(assoc.frame, GetWindowAtomicObjectCB, &windowAtomic);
+			if (windowAtomic) {
+				RpMaterial* material = windowAtomic->geometry->matList.materials[0];
+				m_nDefaultWindowMaterialColor = material->color;
+			}
+
+			continue;
+		}
+#endif
+
+#ifdef IMPROVED_VEHICLES_2
+		if (!CGeneral::faststrncmp(desc[i].name, "headlight_l", 11) || 
+			!CGeneral::faststrncmp(desc[i].name, "headlight_l_hi", 14) ||
+			!CGeneral::faststrncmp(desc[i].name, "taillight_l", 11)) {
+
+			bNewLights = true;
+		}
+
+		char* parentName = GetFrameNodeName(assoc.frame->getParent());
+		if (!CGeneral::faststrncmp(parentName, "wing_lf_dummy", 11)) {
+			if (!CGeneral::faststrncmp(desc[i].name, "headlight_l", 11))
+				newLightsData.bWingHeadlights = true;
+			else if (!CGeneral::faststrncmp(desc[i].name, "indicator_lf", 12))
+				newLightsData.bWingIndicators1 = true;
+			else if (!CGeneral::faststrncmp(desc[i].name, "indicator2_lf", 13))
+				newLightsData.bWingIndicators2 = true;
+		} else if (!CGeneral::faststrncmp(parentName, "bump_front_dummy", 16)) {
+			if (!CGeneral::faststrncmp(desc[i].name, "headlight_l", 11))
+				newLightsData.bBumperHeadlights = true;
+			else if (!CGeneral::faststrncmp(desc[i].name, "indicator_lf", 12))
+				newLightsData.bBumperForwardIndicators1 = true;
+			else if (!CGeneral::faststrncmp(desc[i].name, "indicator2_lf", 13))
+				newLightsData.bBumperForwardIndicators2 = true;
+		} else if (!CGeneral::faststrncmp(parentName, "bump_rear_dummy", 16)) {
+			if (!CGeneral::faststrncmp(desc[i].name, "taillight_l", 11))
+				newLightsData.bBumperTaillights = true;
+			else if (!CGeneral::faststrncmp(desc[i].name, "indicator_lr", 12))
+				newLightsData.bBumperRearIndicators1 = true;
+			else if (!CGeneral::faststrncmp(desc[i].name, "indicator2_lr", 13))
+				newLightsData.bBumperRearIndicators2 = true;
+			else if (!CGeneral::faststrncmp(desc[i].name, "brakelight_l", 12))
+				newLightsData.bBumperBrakelights = true;
+			else if (!CGeneral::faststrncmp(desc[i].name, "reversinglight_l", 16))
+				newLightsData.bBumperReversinglights = true;
+		}
+#endif
+
 		if(desc[i].flags & VEHICLE_FLAG_ADD_WHEEL){
 			if(m_wheelId == -1)
 				RwFrameDestroy(assoc.frame);
@@ -805,6 +1016,11 @@ struct editableMatCBData
 	CVehicleModelInfo *vehicle;
 	int32 numMats1;
 	int32 numMats2;
+
+#ifdef IMPROVED_VEHICLES // More colors
+	int32 numMats3;
+	int32 numMats4;
+#endif
 };
 
 RpMaterial*
@@ -819,10 +1035,24 @@ CVehicleModelInfo::GetEditableMaterialListCB(RpMaterial *material, void *data)
 	if(col->red == 0x3C && col->green == 0xFF && col->blue == 0){
 		cbdata->vehicle->m_materials1[cbdata->numMats1++] = material;
 		RpMaterialSetColor(material, &white);
-	}else if(col->red == 0xFF && col->green == 0 && col->blue == 0xAF){
+	} else if(col->red == 0xFF && col->green == 0 && col->blue == 0xAF) {
 		cbdata->vehicle->m_materials2[cbdata->numMats2++] = material;
 		RpMaterialSetColor(material, &white);
+
 	}
+
+#ifdef IMPROVED_VEHICLES // More colors
+	else if (col->red == 0 && col->green == 255 && col->blue == 255 || 
+			 col->red == 185 && col->green == 255 && col->blue == 0) { // MVL and SA tertiary colours
+
+		cbdata->vehicle->m_materials3[cbdata->numMats3++] = material;
+		RpMaterialSetColor(material, &white);
+	} else if(col->red == 255 && col->green == 60 && col->blue == 0){ // SA quaternary colours
+		cbdata->vehicle->m_materials4[cbdata->numMats4++] = material;
+		RpMaterialSetColor(material, &white);
+	}
+#endif
+	
 	return material;
 }
 
@@ -836,6 +1066,11 @@ CVehicleModelInfo::GetEditableMaterialListCB(RpAtomic *atomic, void *data)
 static int maxFirstMaterials;
 static int maxSecondMaterials;
 
+#ifdef IMPROVED_VEHICLES // More colors
+static int maxThirdMaterials;
+static int maxFourthMaterials;
+#endif
+
 void
 CVehicleModelInfo::FindEditableMaterialList(void)
 {
@@ -845,6 +1080,12 @@ CVehicleModelInfo::FindEditableMaterialList(void)
 	cbdata.vehicle = this;
 	cbdata.numMats1 = 0;
 	cbdata.numMats2 = 0;
+
+#ifdef IMPROVED_VEHICLES // More colors
+	cbdata.numMats3 = 0;
+	cbdata.numMats4 = 0;
+#endif
+
 	RpClumpForAllAtomics(m_clump, GetEditableMaterialListCB, &cbdata);
 	for(i = 0; i < m_numComps; i++)
 		GetEditableMaterialListCB(m_comps[i], &cbdata);
@@ -854,10 +1095,23 @@ CVehicleModelInfo::FindEditableMaterialList(void)
 	maxSecondMaterials = Max(maxSecondMaterials, cbdata.numMats2);
 	m_currentColour1 = -1;
 	m_currentColour2 = -1;
+
+#ifdef IMPROVED_VEHICLES // More colors
+	m_materials3[cbdata.numMats3] = nil;
+	m_materials4[cbdata.numMats4] = nil;
+	maxThirdMaterials = Max(maxThirdMaterials, cbdata.numMats3);
+	maxFourthMaterials = Max(maxFourthMaterials, cbdata.numMats4);
+	m_currentColour3 = -1;
+	m_currentColour4 = -1;
+#endif
 }
 
 void
+#ifdef IMPROVED_VEHICLES // More colors
+CVehicleModelInfo::SetVehicleColour(uint8 c1, uint8 c2, uint8 c3, uint8 c4)
+#else
 CVehicleModelInfo::SetVehicleColour(uint8 c1, uint8 c2)
+#endif
 {
 	RwRGBA col, *colp;
 	RpMaterial **matp;
@@ -883,8 +1137,68 @@ CVehicleModelInfo::SetVehicleColour(uint8 c1, uint8 c2)
 		}
 		m_currentColour2 = c2;
 	}
+
+#ifdef IMPROVED_VEHICLES // More colors
+	if(c3 != m_currentColour3){
+		col = ms_vehicleColourTable[c3];
+		for(matp = m_materials3; *matp; matp++){
+			colp = (RwRGBA*)RpMaterialGetColor(*matp);
+			colp->red = col.red;
+			colp->green = col.green;
+			colp->blue = col.blue;
+		}
+		m_currentColour3 = c3;
+	}
+
+	if(c4 != m_currentColour4){
+		col = ms_vehicleColourTable[c4];
+		for(matp = m_materials4; *matp; matp++){
+			colp = (RwRGBA*)RpMaterialGetColor(*matp);
+			colp->red = col.red;
+			colp->green = col.green;
+			colp->blue = col.blue;
+		}
+		m_currentColour4 = c4;
+	}
+#endif
 }
 
+#ifdef IMPROVED_VEHICLES // More colors
+void
+CVehicleModelInfo::ChooseVehicleColour(uint8 &col1, uint8 &col2, uint8& col3, uint8& col4)
+{
+	if(m_numColours == 0 || gbBlackCars){
+		col1 = 0;
+		col2 = 0;
+		col3 = 0;
+		col4 = 0;
+	}else if(gbPinkCars){
+		col1 = 68;
+		col2 = 68;
+		col3 = 68;
+		col4 = 68;
+	}else{
+		m_lastColorVariation = (m_lastColorVariation+1) % m_numColours;
+		col1 = m_colours1[m_lastColorVariation];
+		col2 = m_colours2[m_lastColorVariation];
+		col3 = m_colours3[m_lastColorVariation];
+		col4 = m_colours4[m_lastColorVariation];
+		if(m_numColours > 1){
+			CVehicle *veh = FindPlayerVehicle();
+			if(veh && CModelInfo::GetModelInfo(veh->GetModelIndex()) == this &&
+			   veh->m_currentColour1 == col1 && veh->m_currentColour2 == col2 &&
+			   veh->m_currentColour3 == col3 && veh->m_currentColour4 == col4){
+
+				m_lastColorVariation = (m_lastColorVariation+1) % m_numColours;
+				col1 = m_colours1[m_lastColorVariation];
+				col2 = m_colours2[m_lastColorVariation];
+				col3 = m_colours3[m_lastColorVariation];
+				col4 = m_colours4[m_lastColorVariation];
+			}
+		}
+	}
+}
+#else
 void
 CVehicleModelInfo::ChooseVehicleColour(uint8 &col1, uint8 &col2)
 {
@@ -910,7 +1224,42 @@ CVehicleModelInfo::ChooseVehicleColour(uint8 &col1, uint8 &col2)
 		}
 	}
 }
+#endif
+
+#ifdef IMPROVED_VEHICLES // More colors
+void
+CVehicleModelInfo::AvoidSameVehicleColour(uint8 *col1, uint8 *col2, uint8 *col3, uint8 *col4)
+{
+	int i, n;
 
+	if(gbBlackCars){
+		*col1 = 0;
+		*col2 = 0;
+		*col3 = 0;
+		*col4 = 0;
+	}else if(gbPinkCars){
+		*col1 = 68;
+		*col2 = 68;
+		*col3 = 68;
+		*col4 = 68;
+	}else{
+		if(m_numColours > 1)
+			for(i = 0; i < NUM_VEHICLE_COLOURS; i++){
+				if(*col1 != m_lastColour1 || *col2 != m_lastColour2 || *col3 != m_lastColour3 || *col4 != m_lastColour4)
+					break;
+				n = CGeneral::GetRandomNumberInRange(0, m_numColours);
+				*col1 = m_colours1[n];
+				*col2 = m_colours2[n];
+				*col3 = m_colours3[n];
+				*col4 = m_colours4[n];
+			}
+		m_lastColour1 = *col1;
+		m_lastColour2 = *col2;
+		m_lastColour3 = *col3;
+		m_lastColour4 = *col4;
+	}
+}
+#else
 void
 CVehicleModelInfo::AvoidSameVehicleColour(uint8 *col1, uint8 *col2)
 {
@@ -935,6 +1284,7 @@ CVehicleModelInfo::AvoidSameVehicleColour(uint8 *col1, uint8 *col2)
 		m_lastColour2 = *col2;
 	}
 }
+#endif
 
 // unused
 RwTexture*
diff --git a/src/modelinfo/VehicleModelInfo.h b/src/modelinfo/VehicleModelInfo.h
index c7a41126..cd54fbd6 100644
--- a/src/modelinfo/VehicleModelInfo.h
+++ b/src/modelinfo/VehicleModelInfo.h
@@ -3,9 +3,17 @@
 #include "ClumpModelInfo.h"
 
 enum {
+#ifdef IMPROVED_VEHICLES // More materials and colors
+	NUM_FIRST_MATERIALS = 50,
+	NUM_SECOND_MATERIALS = 50,
+	NUM_THIRD_MATERIALS = 50,
+	NUM_FOURTH_MATERIALS = 50,
+	NUM_VEHICLE_COLOURS = 16,
+#else
 	NUM_FIRST_MATERIALS = 24,
 	NUM_SECOND_MATERIALS = 20,
 	NUM_VEHICLE_COLOURS = 8,
+#endif
 };
 
 enum {
@@ -22,6 +30,9 @@ enum {
 	ATOMIC_FLAG_REARDOOR	= 0x200,
 	ATOMIC_FLAG_FRONTDOOR	= 0x400,
 	ATOMIC_FLAG_NOCULL	= 0x800,
+#ifdef IMPROVED_VEHICLES_2
+	ATOMIC_FLAG_DOORWINDOW	= 0x1000,
+#endif
 };
 
 enum eVehicleType {
@@ -40,7 +51,25 @@ enum eCarPositions
 	CAR_POS_TAILLIGHTS,
 	CAR_POS_FRONTSEAT,
 	CAR_POS_BACKSEAT,
-	CAR_POS_EXHAUST
+	CAR_POS_EXHAUST,
+
+#ifdef IMPROVED_VEHICLES_2 // dummy positions
+	CAR_POS_HEADLIGHTS_2,
+	CAR_POS_TAILLIGHTS_2,
+	CAR_POS_REVERSINGLIGHTS,
+	CAR_POS_REVERSINGLIGHTS_2,
+	CAR_POS_BRAKELIGHTS,
+	CAR_POS_BRAKELIGHTS_2,
+	CAR_POS_INDICATORS_F,
+	CAR_POS_INDICATORS_R,
+	CAR_POS_INDICATORS_2_F,
+	CAR_POS_INDICATORS_2_R,
+	CAR_POS_ENGINE,
+	CAR_POS_OVERHEAT,
+	CAR_POS_OVERHEAT_2,
+	CAR_POS_PETROLCAP,
+	NUM_VEHICLE_POSITIONS,
+#endif
 };
 
 enum eBoatPositions
@@ -64,15 +93,40 @@ enum ePlanePositions
 	PLANE_POS_LIGHT_TAIL,
 };
 
+#ifndef IMPROVED_VEHICLES_2
 enum {
 	NUM_VEHICLE_POSITIONS = 5
 };
+#endif
+
+#ifdef IMPROVED_VEHICLES_2
+struct tNewLightsData {
+	bool bBumperHeadlights;
+	bool bBumperForwardIndicators1;
+	bool bBumperForwardIndicators2;
+	bool bWingHeadlights;
+	bool bWingIndicators1;
+	bool bWingIndicators2;
+	bool bBumperRearIndicators1;
+	bool bBumperRearIndicators2;
+	bool bBumperTaillights;
+	bool bBumperReversinglights;
+	bool bBumperBrakelights;
+};
+#endif
 
 class CVehicleModelInfo : public CClumpModelInfo
 {
 public:
 	uint8 m_lastColour1;
 	uint8 m_lastColour2;
+#ifdef IMPROVED_VEHICLES // More colors
+	uint8 m_lastColour3;
+	uint8 m_lastColour4;
+	bool bHasManyColors;
+#endif
+
+
 	char m_gameName[10];
 	int32 m_vehicleType;
 	float m_wheelScale;
@@ -93,6 +147,17 @@ public:
 	RpMaterial *m_materials2[NUM_SECOND_MATERIALS];
 	uint8 m_colours1[NUM_VEHICLE_COLOURS];
 	uint8 m_colours2[NUM_VEHICLE_COLOURS];
+
+#ifdef IMPROVED_VEHICLES // More colors
+	RpMaterial* m_materials3[NUM_THIRD_MATERIALS];
+	RpMaterial* m_materials4[NUM_FOURTH_MATERIALS];
+	uint8 m_colours3[NUM_VEHICLE_COLOURS];
+	uint8 m_colours4[NUM_VEHICLE_COLOURS];
+	uint8 m_currentColour3;
+	uint8 m_currentColour4;
+#endif
+
+
 	uint8 m_numColours;
 	uint8 m_lastColorVariation;
 	uint8 m_currentColour1;
@@ -104,6 +169,22 @@ public:
 		char *m_animFileName;
 	};
 
+#ifdef IMPROVED_VEHICLES_2
+	RwTexture* lightsOffTexture;
+	RwTexture* lightsOnTexture;
+	bool bNewLights;
+	tNewLightsData newLightsData;
+#endif
+
+#ifdef VEHICLE_MODS
+	CRGBA m_nDefaultWindowMaterialColor;
+#endif
+
+#ifdef IMPROVED_VEHICLES // Service lights for service cars - init
+	RwTexture* serviceLightsOffTexture;
+	RwTexture* serviceLightsOnTexture;
+#endif
+
 	static int8 ms_compsToUse[2];
 	static int8 ms_compsUsed[2];
 	static RwRGBA ms_vehicleColourTable[256];
@@ -145,9 +226,17 @@ public:
 	static RpMaterial *GetEditableMaterialListCB(RpMaterial *material, void *data);
 	static RpAtomic *GetEditableMaterialListCB(RpAtomic *atomic, void *data);
 	void FindEditableMaterialList(void);
+
+#ifdef IMPROVED_VEHICLES // More colors
+	void SetVehicleColour(uint8 c1, uint8 c2, uint8 c3 = 0, uint8 c4 = 0);
+	void ChooseVehicleColour(uint8& col1, uint8& col2, uint8& col3, uint8& col4);
+	void AvoidSameVehicleColour(uint8* col1, uint8* col2, uint8* col3, uint8* col4);
+#else
 	void SetVehicleColour(uint8 c1, uint8 c2);
-	void ChooseVehicleColour(uint8 &col1, uint8 &col2);
-	void AvoidSameVehicleColour(uint8 *col1, uint8 *col2);
+	void ChooseVehicleColour(uint8& col1, uint8& col2);
+	void AvoidSameVehicleColour(uint8* col1, uint8* col2);
+#endif
+
 	static void LoadVehicleColours(void);
 	static void DeleteVehicleColourTextures(void);
 
diff --git a/src/peds/PedIK.h b/src/peds/PedIK.h
index 3011dd5f..9964279e 100644
--- a/src/peds/PedIK.h
+++ b/src/peds/PedIK.h
@@ -2,6 +2,10 @@
 #include "common.h"
 #include "AnimBlendClumpData.h"
 
+#ifdef IMPROVED_VEHICLES_2 // steering wheel IK
+#include "PedModelInfo.h"
+#endif
+
 struct LimbOrientation
 {
 	float yaw;
diff --git a/src/renderer/Coronas.cpp b/src/renderer/Coronas.cpp
index d9bf88d1..dc91009a 100644
--- a/src/renderer/Coronas.cpp
+++ b/src/renderer/Coronas.cpp
@@ -659,6 +659,10 @@ void
 CCoronas::DoSunAndMoon(void)
 {
 	// yeah, moon is done somewhere else....
+	
+	// I think the moon is under CWeapon::FireSniper for some reason?
+	// Why the hell...?
+	// Oh it's also done in Clouds.cpp, does the sniper make the moon bigger like in SA?
 
 	CVector sunCoors = CTimeCycle::GetSunDirection();
 	sunCoors *= 150.0f;
diff --git a/src/renderer/Hud.cpp b/src/renderer/Hud.cpp
index 28328766..47e4bd91 100644
--- a/src/renderer/Hud.cpp
+++ b/src/renderer/Hud.cpp
@@ -26,6 +26,10 @@
 #include "General.h"
 #include "VarConsole.h"
 
+#ifdef VEHICLE_MODS
+#include "Garages.h"
+#endif
+
 #ifdef EX_PC_KEY_ICONS
 #include "ControllerConfig.h"
 #endif
@@ -573,7 +577,11 @@ void CHud::Draw()
 			CFont::SetColor(MONEY_COLOR);
 
 			if (FrontEndMenuManager.m_PrefsShowHud) {
+#ifdef VEHICLE_MODS // HUD in mod garage
+				CFont::PrintString(SCREEN_SCALE_FROM_RIGHT(110.0f), SCREEN_SCALE_Y(CGarages::bPlayerInModGarage ? 10.0f : 43.0f), sPrint);
+#else
 				CFont::PrintString(SCREEN_SCALE_FROM_RIGHT(110.0f), SCREEN_SCALE_Y(43.0f), sPrint);
+#endif
 			}
 		}
 
@@ -587,7 +595,13 @@ void CHud::Draw()
 			alpha = CHud::DrawFadeState(HUD_WEAPON_FADING, 1);
 			m_LastWeapon = playerPed->GetWeapon()->m_eWeaponType;
 		}
+
+#ifdef VEHICLE_MODS // hide some hud elements when a player in the mod garage
+		if (m_WeaponState != FADED_OUT && !CGarages::bPlayerInModGarage) {
+#else
 		if (m_WeaponState != FADED_OUT) {
+#endif
+
 			CWeapon *weapon = playerPed->GetWeapon();
 			int32 AmmoAmount = CWeaponInfo::GetWeaponInfo((eWeaponType)WeaponType)->m_nAmountofAmmunition;
 			int32 AmmoInClip = weapon->m_nAmmoInClip;
@@ -691,7 +705,12 @@ void CHud::Draw()
 			m_LastTimeEnergyLost = CWorld::Players[CWorld::PlayerInFocus].m_nTimeLastHealthLoss;
 		}
 
+#ifdef VEHICLE_MODS // hide some hud elements when a player in the mod garage
+		if (m_EnergyLostState != FADED_OUT && !CGarages::bPlayerInModGarage) {
+#else
 		if (m_EnergyLostState != FADED_OUT) {
+#endif
+
 			CFont::SetBackgroundOff();
 			CFont::SetScale(SCREEN_SCALE_X(HUD_TEXT_SCALE_X), SCREEN_SCALE_Y(HUD_TEXT_SCALE_Y));
 			CFont::SetJustifyOff();
@@ -734,7 +753,13 @@ void CHud::Draw()
 				DrawArmour
 			*/
 			// TODO Add a toggle option for this.
+
+#ifdef VEHICLE_MODS // hide some hud elements when a player in the mod garage
+			if (!CGarages::bPlayerInModGarage && (m_ItemToFlash == ITEM_ARMOUR && FRAMECOUNTER & 8 || m_ItemToFlash != ITEM_ARMOUR)) {
+#else
 			if (m_ItemToFlash == ITEM_ARMOUR && FRAMECOUNTER & 8 || m_ItemToFlash != ITEM_ARMOUR) {
+#endif
+
 				CFont::SetScale(SCREEN_SCALE_X(HUD_TEXT_SCALE_X), SCREEN_SCALE_Y(HUD_TEXT_SCALE_Y));
 				if (playerPed->m_fArmour > 1.0f) {
 					AsciiToUnicode("<", sPrintIcon);
@@ -788,17 +813,35 @@ void CHud::Draw()
 
 						WANTED_COLOR.a = alpha;
 						CFont::SetColor(WANTED_COLOR);
+			
+#ifdef VEHICLE_MODS // HUD in mod garage
+						CFont::PrintString(SCREEN_SCALE_FROM_RIGHT(110.0f + 23.0f * i), SCREEN_SCALE_Y(CGarages::bPlayerInModGarage ? 35.0f : 87.0f), sPrintIcon);
+#else
 						CFont::PrintString(SCREEN_SCALE_FROM_RIGHT(110.0f + 23.0f * i), SCREEN_SCALE_Y(87.0f), sPrintIcon);
+#endif
+
 
 					} else if (playerPed->m_pWanted->m_nMinWantedLevel > i && FRAMECOUNTER & 4) {
 						WANTED_COLOR_FLASH.a = alpha;
 						CFont::SetColor(WANTED_COLOR_FLASH);
+
+#ifdef VEHICLE_MODS // HUD in mod garage
+						CFont::PrintString(SCREEN_SCALE_FROM_RIGHT(110.0f + 23.0f * i), SCREEN_SCALE_Y(CGarages::bPlayerInModGarage ? 35.0f : 87.0f), sPrintIcon);
+#else
 						CFont::PrintString(SCREEN_SCALE_FROM_RIGHT(110.0f + 23.0f * i), SCREEN_SCALE_Y(87.0f), sPrintIcon);
+#endif
+
 
 					} else if (playerPed->m_pWanted->GetWantedLevel() <= i) {
 						NOTWANTED_COLOR.a = alpha;
 						CFont::SetColor(NOTWANTED_COLOR);
+
+#ifdef VEHICLE_MODS // HUD in mod garage
+						CFont::PrintString(SCREEN_SCALE_FROM_RIGHT(110.0f + 23.0f * i), SCREEN_SCALE_Y(CGarages::bPlayerInModGarage ? 35.0f : 87.0f), sPrintIcon);
+#else
 						CFont::PrintString(SCREEN_SCALE_FROM_RIGHT(110.0f + 23.0f * i), SCREEN_SCALE_Y(87.0f), sPrintIcon);
+#endif
+
 					}
 				}
 			}
@@ -1059,7 +1102,12 @@ void CHud::Draw()
 		/*
 			DrawClock
 		*/
-		if (m_ClockState) {
+#ifdef VEHICLE_MODS // hide some hud elements when a player in the mod garage
+	if (m_ClockState && !CGarages::bPlayerInModGarage) {
+#else
+	if (m_ClockState) {
+#endif
+
 			CFont::SetJustifyOff();
 			CFont::SetCentreOff();
 			CFont::SetBackgroundOff();
@@ -1198,8 +1246,15 @@ void CHud::Draw()
 		/*
 			DrawRadar
 		*/
-		if (FrontEndMenuManager.m_PrefsRadarMode != 2 &&
-			!m_HideRadar && (m_ItemToFlash == ITEM_RADAR && FRAMECOUNTER & 8 || m_ItemToFlash != ITEM_RADAR)) {
+#ifdef VEHICLE_MODS // HUD in mod garage
+	if (!CGarages::bPlayerInModGarage && FrontEndMenuManager.m_PrefsRadarMode != 2 &&
+		!m_HideRadar && (m_ItemToFlash == ITEM_RADAR && FRAMECOUNTER & 8 || m_ItemToFlash != ITEM_RADAR)) {
+#else
+	if (FrontEndMenuManager.m_PrefsRadarMode != 2 &&
+		!m_HideRadar && (m_ItemToFlash == ITEM_RADAR && FRAMECOUNTER & 8 || m_ItemToFlash != ITEM_RADAR)) {
+#endif
+
+
 
 			RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (void*)rwFILTERNEAREST);
 			CRadar::DrawMap();
diff --git a/src/renderer/Particle.cpp b/src/renderer/Particle.cpp
index 67b68475..7c9db5f2 100644
--- a/src/renderer/Particle.cpp
+++ b/src/renderer/Particle.cpp
@@ -516,6 +516,11 @@ void CParticle::Initialise()
 			case PARTICLE_STEAM_NY_SLOWMOTION:
 			case PARTICLE_GROUND_STEAM:
 			case PARTICLE_ENGINE_STEAM:
+
+		
+#ifdef IMPROVED_VEHICLES_2
+			case PARTICLE_ENGINE_STEAM_SMALL:
+#endif
 			case PARTICLE_PEDFOOT_DUST:
 			case PARTICLE_CAR_DUST:
 			case PARTICLE_EXHAUST_FUMES:
@@ -561,6 +566,11 @@ void CParticle::Initialise()
 			
 			case PARTICLE_FLAME:
 			case PARTICLE_CARFLAME:
+
+#ifdef IMPROVED_VEHICLES_2
+			case PARTICLE_CARFLAME_SMALL:
+#endif
+
 				entry->m_ppRaster = &gpFlame1Raster;
 				break;
 			
@@ -636,6 +646,13 @@ void CParticle::Initialise()
 			case PARTICLE_ENGINE_SMOKE:
 			case PARTICLE_ENGINE_SMOKE2:
 			case PARTICLE_CARFLAME_SMOKE:
+
+#ifdef IMPROVED_VEHICLES_2
+			case PARTICLE_ENGINE_SMOKE_SMALL:
+			case PARTICLE_ENGINE_SMOKE2_SMALL:
+			case PARTICLE_CARFLAME_SMOKE_SMALL:
+#endif
+
 			case PARTICLE_FIREBALL_SMOKE:
 			case PARTICLE_ROCKET_SMOKE:
 			case PARTICLE_TEST:
@@ -1826,6 +1843,14 @@ void CParticle::Render()
 			|| type == PARTICLE_ENGINE_SMOKE2
 			|| type == PARTICLE_ENGINE_STEAM
 			|| type == PARTICLE_CARFLAME_SMOKE
+
+#ifdef IMPROVED_VEHICLES_2
+			|| type == PARTICLE_ENGINE_SMOKE_SMALL
+			|| type == PARTICLE_ENGINE_SMOKE2_SMALL
+			|| type == PARTICLE_ENGINE_STEAM_SMALL
+			|| type == PARTICLE_CARFLAME_SMOKE_SMALL
+#endif
+
 			|| type == PARTICLE_RUBBER_SMOKE
 			|| type == PARTICLE_BURNINGRUBBER_SMOKE
 			|| type == PARTICLE_EXHAUST_FUMES
@@ -2090,6 +2115,23 @@ void CParticle::Render()
 								break;
 						}
 					}
+
+#ifdef IMPROVED_VEHICLES_2 // change particle size
+					else if (i == PARTICLE_ENGINE_SMOKE2_SMALL) {
+						w /= 2.7f;
+						h /= 2.7f;
+					} else if (i == PARTICLE_ENGINE_SMOKE_SMALL) {
+						w /= 2.0f;
+						h /= 2.0f;
+					} else if (i == PARTICLE_ENGINE_STEAM_SMALL) {
+						w /= 1.4f;
+						h /= 1.4f;
+					} else if (i == PARTICLE_CARFLAME_SMALL || i == PARTICLE_CARFLAME_SMOKE_SMALL) {
+						w /= 3.2f;
+						h /= 3.2f;
+					}
+#endif
+
 					else if ( i == PARTICLE_WATER_HYDRANT )
 					{
 						int32 timeLeft = (particle->m_nTimeWhenWillBeDestroyed - CTimer::GetTimeInMilliseconds()) / particle->m_nTimeWhenWillBeDestroyed;
diff --git a/src/renderer/ParticleType.h b/src/renderer/ParticleType.h
index 9578083d..aa112526 100644
--- a/src/renderer/ParticleType.h
+++ b/src/renderer/ParticleType.h
@@ -85,8 +85,21 @@ enum tParticleType
 	PARTICLE_RAINDROP_2D,
 	PARTICLE_HEATHAZE,
 	PARTICLE_HEATHAZE_IN_DIST,
+
+#ifdef IMPROVED_VEHICLES_2 // new particle types
+	PARTICLE_ENGINE_SMOKE2_SMALL,
+	PARTICLE_ENGINE_STEAM_SMALL,
+	PARTICLE_ENGINE_SMOKE_SMALL,
+	PARTICLE_CARFLAME_SMALL,
+	PARTICLE_CARFLAME_SMOKE_SMALL,
+#endif
 	
 	MAX_PARTICLES,
 	PARTICLE_FIRST = PARTICLE_SPARK,
+
+#ifdef IMPROVED_VEHICLES_2 // new particle types
+	PARTICLE_LAST = PARTICLE_CARFLAME_SMOKE_SMALL
+#else
 	PARTICLE_LAST = PARTICLE_HEATHAZE_IN_DIST
+#endif
 };
\ No newline at end of file
diff --git a/src/renderer/Weather.cpp b/src/renderer/Weather.cpp
index 0cca75b6..5e03c637 100644
--- a/src/renderer/Weather.cpp
+++ b/src/renderer/Weather.cpp
@@ -21,6 +21,10 @@
 #include "SpecialFX.h"
 #include "Replay.h"
 
+#ifdef VEHICLE_MODS
+#include "Garages.h"
+#endif
+
 int32 CWeather::SoundHandle = -1;
 
 int32 CWeather::WeatherTypeInList;
@@ -453,6 +457,14 @@ void CWeather::AddRain()
 {
 	if (CCullZones::CamNoRain() || CCullZones::PlayerNoRain())
 		return;
+
+#ifdef VEHICLE_MODS // it's not raining in the mod garage
+	if (CGarages::bPlayerInModGarage) {
+		Rain = 0.0f;
+		return;
+	}
+#endif
+
 	if (TheCamera.GetLookingLRBFirstPerson()) {
 		CVehicle* pVehicle = FindPlayerVehicle();
 		if (pVehicle && pVehicle->CarHasRoof()) {
diff --git a/src/vehicles/Automobile.cpp b/src/vehicles/Automobile.cpp
index 5359997f..a18086b5 100644
--- a/src/vehicles/Automobile.cpp
+++ b/src/vehicles/Automobile.cpp
@@ -52,6 +52,16 @@
 #include "Wanted.h"
 #include "SaveBuf.h"
 
+#ifdef VEHICLE_MODS
+#include "ClumpModelInfo.h"
+#endif
+
+#ifdef IMPROVED_VEHICLES_2
+#include "TxdStore.h"
+#include "NodeName.h"
+#include "Debug.h"
+#endif
+
 
 #ifdef TOGGLE_UPSIDEDOWN_EXPLOSIONS
 	// Set this to true by default
@@ -112,7 +122,11 @@ CAutomobile::CAutomobile(int32 id, uint8 CreatedBy)
 	m_auto_unused1 = 20.0f;
 	m_auto_unused2 = 0;
 
+#ifdef IMPROVED_VEHICLES // More colors
+	mi->ChooseVehicleColour(m_currentColour1, m_currentColour2, m_currentColour3, m_currentColour4);
+#else
 	mi->ChooseVehicleColour(m_currentColour1, m_currentColour2);
+#endif
 
 	bIsVan = !!(pHandling->Flags & HANDLING_IS_VAN);
 	bIsBig = !!(pHandling->Flags & HANDLING_IS_BIG);
@@ -241,6 +255,49 @@ CAutomobile::CAutomobile(int32 id, uint8 CreatedBy)
 		bExplosionProof = true;
 		bBulletProof = true;
 	}
+
+#ifdef IMPROVED_VEHICLES_2 // init
+	m_bIndicatorState[INDICATORS_LEFT] = false;
+	m_bIndicatorState[INDICATORS_RIGHT] = false;
+#endif
+
+#if defined VEHICLE_MODS && defined IMPROVED_VEHICLES // init
+	m_nWindowTintLevel = 1;
+	m_nTempWindowTintLevel = 1;
+	m_nAddSuspensionForceLevel = 1;
+	m_nTempAddSuspensionForceLevel = 1;
+	m_nTempColor1 = 0;
+	m_nTempColor2 = 0;
+	m_nTempColor3 = 0;
+	m_nTempColor4 = 0;
+	m_nRimsColor = 1;
+	m_nTempRimsColor = 1;
+	m_nSpoilerColor = -1;
+	m_nTempSpoilerColor = -1;
+	m_fAddBrakeDeceleration = 0.0f;
+	m_fCarbRotation = 0.0f;
+	m_aDefaultBonnetOkAtomic = nil;
+	m_aDefaultBonnetDamAtomic = nil;
+	bHasHydraulics = GetModelIndex() == MI_VOODOO;
+
+	for (int upgradeID = 0; upgradeID < NUM_UPGRADES; upgradeID++) {
+		if (upgradeID == UPGRADE_WHEELS) {
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeModelIndex = mi->m_wheelId;
+			m_aUpgrades[UPGRADE_WHEELS].m_nTempUpgradeModelIndex = mi->m_wheelId;
+			SetWheelNumber(mi->m_wheelId);
+		} else {
+			m_aUpgrades[upgradeID].m_nUpgradeModelIndex = 0;
+			m_aUpgrades[upgradeID].m_nTempUpgradeModelIndex = 0;
+			m_aUpgrades[upgradeID].m_nUpgradeNumber = 0;
+		}
+	}
+
+	if (m_aCarNodes[CAR_SUPERCHARGER]) {
+		RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SUPERCHARGER]->child), 0); // supercharger
+		RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SUPERCHARGER]->child->child->child), 0); // carb
+		RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SUPERCHARGER]->child->child->next->child), 0); // flywheel
+	}
+#endif
 }
 
 void
@@ -248,6 +305,19 @@ CAutomobile::SetModelIndex(uint32 id)
 {
 	CVehicle::SetModelIndex(id);
 	SetupModelNodes();
+
+#ifdef IMPROVED_VEHICLES // Service lights for service cars - init
+	if (m_aCarNodes[CAR_SERVICELIGHTS_1] && (m_aExtras[0] == 0 || m_aExtras[1] == 0)) {
+		if (m_aCarNodes[CAR_SERVICELIGHTS_2]) RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SERVICELIGHTS_2]), 0);
+		if (m_aCarNodes[CAR_SERVICELIGHTS_3]) RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SERVICELIGHTS_3]), 0);
+	} else if (m_aCarNodes[CAR_SERVICELIGHTS_2] && (m_aExtras[0] == 1 || m_aExtras[1] == 1)) {
+		if (m_aCarNodes[CAR_SERVICELIGHTS_1]) RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SERVICELIGHTS_1]), 0);
+		if (m_aCarNodes[CAR_SERVICELIGHTS_3]) RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SERVICELIGHTS_3]), 0);
+	} else if (m_aCarNodes[CAR_SERVICELIGHTS_3] && (m_aExtras[0] == 2 || m_aExtras[1] == 2)) {
+		if (m_aCarNodes[CAR_SERVICELIGHTS_1]) RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SERVICELIGHTS_1]), 0);
+		if (m_aCarNodes[CAR_SERVICELIGHTS_2]) RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SERVICELIGHTS_2]), 0);
+	}
+#endif
 }
 
 #define SAND_SLOWDOWN (0.01f)
@@ -532,7 +602,16 @@ CAutomobile::ProcessControl(void)
 			m_fBrakePedal = 0.0f;
 		bIsHandbrakeOn = false;
 
+
+#ifdef IMPROVED_VEHICLES // steer angle save after exit from vehicle etc
+		if (m_fSteerAngle < 0.0f)
+			m_fSteerAngle = Max(m_fSteerAngle, -DEGTORAD(pHandling->fSteeringLock));
+		else
+			m_fSteerAngle = Min(m_fSteerAngle, DEGTORAD(pHandling->fSteeringLock));
+#else
 		m_fSteerAngle = 0.0f;
+#endif
+
 		m_fGasPedal = 0.0f;
 		if(!IsAlarmOn())
 			m_nCarHornTimer = 0;
@@ -548,7 +627,15 @@ CAutomobile::ProcessControl(void)
 		m_fBrakePedal = 0.05f;
 		bIsHandbrakeOn = true;
 
+#ifdef IMPROVED_VEHICLES // steer angle save after exit from vehicle etc
+		if (m_fSteerAngle < 0.0f)
+			m_fSteerAngle = Max(m_fSteerAngle, -DEGTORAD(pHandling->fSteeringLock));
+		else
+			m_fSteerAngle = Min(m_fSteerAngle, DEGTORAD(pHandling->fSteeringLock));
+#else
 		m_fSteerAngle = 0.0f;
+#endif
+
 		m_fGasPedal = 0.0f;
 		if(!IsAlarmOn())
 			m_nCarHornTimer = 0;
@@ -568,7 +655,15 @@ CAutomobile::ProcessControl(void)
 			bIsHandbrakeOn = false;
 		}
 
+#ifdef IMPROVED_VEHICLES // steer angle save after exit from vehicle etc
+		if (m_fSteerAngle < 0.0f)
+			m_fSteerAngle = Max(m_fSteerAngle, -DEGTORAD(pHandling->fSteeringLock));
+		else
+			m_fSteerAngle = Min(m_fSteerAngle, DEGTORAD(pHandling->fSteeringLock));
+#else
 		m_fSteerAngle = 0.0f;
+#endif
+
 		m_fGasPedal = 0.0f;
 		if(!IsAlarmOn())
 			m_nCarHornTimer = 0;
@@ -643,6 +738,11 @@ CAutomobile::ProcessControl(void)
 
 	VehicleDamage(0.0f, 0);
 
+#ifdef VEHICLE_MODS // hydraulics
+	if (bHasHydraulics)
+		HydraulicControl();
+#endif
+
 	// special control
 	switch(GetModelIndex()){
 	case MI_FIRETRUCK:
@@ -805,7 +905,27 @@ CAutomobile::ProcessControl(void)
 				if(i == CARWHEEL_REAR_LEFT || i == CARWHEEL_REAR_RIGHT)
 					bias = 1.0f - bias;
 
-				ApplySpringCollisionAlt(pHandling->fSuspensionForceLevel,
+#ifdef VEHICLE_MODS // suspension
+					float addSuspensionForceLevel = 1.0f;
+					switch (CGarages::bPlayerInModGarage ? m_nTempAddSuspensionForceLevel : m_nAddSuspensionForceLevel) {
+						case 2:
+							addSuspensionForceLevel = 1.5f;
+							break;
+						case 3:
+							addSuspensionForceLevel = 2.0f;
+							break;
+						case 4:
+							addSuspensionForceLevel = 2.5f;
+							break;
+						default:
+							break;
+					}
+					ApplySpringCollisionAlt(pHandling->fSuspensionForceLevel / addSuspensionForceLevel,
+#else
+					ApplySpringCollisionAlt(pHandling->fSuspensionForceLevel,
+#endif
+
+
 					springDirections[i], contactPoints[i],
 					m_aSuspensionSpringRatio[i], bias, m_aWheelColPoints[i].normal);
 
@@ -859,7 +979,13 @@ CAutomobile::ProcessControl(void)
 		fwdSpeed = DotProduct(m_vecMoveSpeed, GetForward());
 		if(!strongGrip1 && !CVehicle::bCheat3)
 			gripCheat = false;
+
+#ifdef VEHICLE_MODS // engine acceleration
+		float acceleration = pHandling->Transmission.CalculateDriveAcceleration(m_fGasPedal, m_nCurrentGear, m_fChangeGearTime, fwdSpeed, gripCheat, m_fAddEngineAcceleration);
+#else
 		float acceleration = pHandling->Transmission.CalculateDriveAcceleration(m_fGasPedal, m_nCurrentGear, m_fChangeGearTime, fwdSpeed, gripCheat);
+#endif
+		
 		acceleration /= m_fForceMultiplier;
 
 		if(IsRealHeli() || IsRealPlane())
@@ -884,7 +1010,13 @@ CAutomobile::ProcessControl(void)
 				ApplyTurnForce(-GRAVITY*Min(m_fTurnMass, 2500.0f)*GetUp(), -1.0f*GetForward());
 		}
 
+#ifdef VEHICLE_MODS // brake deceleration
+		brake = m_fBrakePedal * (pHandling->fBrakeDeceleration + m_fAddBrakeDeceleration) * CTimer::GetTimeStep();
+#else
 		brake = m_fBrakePedal * pHandling->fBrakeDeceleration * CTimer::GetTimeStep();
+#endif
+
+
 		bool neutralHandling = GetStatus() != STATUS_PLAYER && GetStatus() != STATUS_PLAYER_REMOTE && (pHandling->Flags & HANDLING_NEUTRALHANDLING);
 		float brakeBiasFront = neutralHandling ? 1.0f : 2.0f*pHandling->fBrakeBias;
 		float brakeBiasRear  = neutralHandling ? 1.0f : 2.0f-pHandling->fBrakeBias;	// looks like a bug, but it was correct in III...
@@ -1402,7 +1534,14 @@ CAutomobile::ProcessControl(void)
 					m_bSirenOrAlarm = !m_bSirenOrAlarm;
 				}else
 					m_nCarHornTimer = 0;
-			}else if(GetModelIndex() != MI_VOODOO && !CVehicle::bCheat3 && !carHasNitro){
+
+#ifdef VEHICLE_MODS // hydraulics
+				}else if(!bHasHydraulics && !CVehicle::bCheat3 && !carHasNitro){
+#else
+				}else if(GetModelIndex() != MI_VOODOO && !CVehicle::bCheat3 && !carHasNitro){
+#endif
+
+
 				if(!IsAlarmOn()){
 					if(Pads[0].GetHorn())
 						m_nCarHornTimer = 1;
@@ -1421,6 +1560,23 @@ CAutomobile::ProcessControl(void)
 #endif
 		if(GetStatus() != STATUS_PLAYER && GetStatus() != STATUS_PLAYER_REMOTE && GetStatus() != STATUS_PHYSICS){
 			if(IsRealHeli()){
+
+
+#ifdef IMPROVED_VEHICLES // Blade collision while the player is not in a helicopter
+				if (m_aWheelSpeed[1] > 0.015f && m_aCarNodes[CAR_BONNET]) {
+					CMatrix mat;
+					mat.Attach(RwFrameGetMatrix(m_aCarNodes[CAR_BONNET]));
+					if (GetModelIndex() == MI_RCRAIDER || GetModelIndex() == MI_RCGOBLIN)
+						DoBladeCollision(mat.GetPosition(), GetMatrix(), ROTOR_TOP, 0.72f, 0.9f);
+					else if (GetModelIndex() == MI_SPARROW || GetModelIndex() == MI_SEASPAR)
+						DoBladeCollision(mat.GetPosition(), GetMatrix(), ROTOR_TOP, 5.15f, 0.8f);
+					else if (GetModelIndex() == MI_HUNTER)
+						DoBladeCollision(mat.GetPosition(), GetMatrix(), ROTOR_TOP, 6.15f, 0.5f);
+					else
+						DoBladeCollision(mat.GetPosition(), GetMatrix(), ROTOR_TOP, 6.15f, 1.0f);
+				}
+#endif
+
 				bEngineOn = false;
 				m_aWheelSpeed[1] = Max(m_aWheelSpeed[1]-0.0005f, 0.0f);
 				if(GetModelIndex() != MI_RCRAIDER && GetModelIndex() != MI_RCGOBLIN)
@@ -1548,10 +1704,19 @@ CAutomobile::ProcessControl(void)
 
 
 
+	#ifdef IMPROVED_VEHICLES_2 // move engine fire particles to AddDamagedVehicleParticles
+	if(m_fHealth < 250.0f && GetStatus() != STATUS_WRECKED){
+		// Blow up car after 5 seconds
+		m_fFireBlowUpTimer += CTimer::GetTimeStepInMilliseconds();
+		if(m_fFireBlowUpTimer > 5000.0f)
+			BlowUpCar(m_pSetOnFireEntity);
+	}else
+		m_fFireBlowUpTimer = 0.0f;
+
+#else
 	// Process car on fire
 	// A similar calculation of damagePos is done elsewhere for smoke
 
-	uint8 engineStatus = Damage.GetEngineStatus();
 	CVector damagePos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->m_positions[CAR_POS_HEADLIGHTS];
 
 	switch(Damage.GetDoorStatus(DOOR_BONNET)){
@@ -1596,23 +1761,78 @@ CAutomobile::ProcessControl(void)
 
 		// Blow up car after 5 seconds
 		m_fFireBlowUpTimer += CTimer::GetTimeStepInMilliseconds();
+		if(m_fFireBlowUpTimer > 5000.0f)
+			BlowUpCar(m_pSetOnFireEntity);
+	}else
+		m_fFireBlowUpTimer = 0.0f;
+#endif
+
+
+	uint8 engineStatus = Damage.GetEngineStatus();
+
+
+
+	
+
+	// switch(Damage.GetDoorStatus(DOOR_BONNET)){
+	// case DOOR_STATUS_OK:
+	// case DOOR_STATUS_SMASHED:
+	// 	// Bonnet is still there, smoke comes out at the edge
+	// 	damagePos += vecDAMAGE_ENGINE_POS_SMALL;
+	// 	break;
+	// case DOOR_STATUS_SWINGING:
+	// case DOOR_STATUS_MISSING:
+	// 	// Bonnet is gone, smoke comes out at the engine
+	// 	damagePos += vecDAMAGE_ENGINE_POS_BIG;
+	// 	break;
+	// }
+
+	// move fire forward if in first person
+	// if(this == FindPlayerVehicle() && TheCamera.GetLookingForwardFirstPerson())
+	// 	if(m_fHealth < 250.0f && GetStatus() != STATUS_WRECKED){
+	// 		if(GetModelIndex() == MI_FIRETRUCK)
+	// 			damagePos += CVector(0.0f, 3.0f, -0.2f);
+	// 		else
+	// 			damagePos += CVector(0.0f, 1.2f, -0.8f);
+	// 	}
+
+	// damagePos = GetMatrix()*damagePos;
+	// damagePos.z += 0.15f;
+
+	// if(m_fHealth < 250.0f && GetStatus() != STATUS_WRECKED){
+		// Car is on fire
+
+		// CParticle::AddParticle(PARTICLE_CARFLAME, damagePos,
+		// 	CVector(0.0f, 0.0f, CGeneral::GetRandomNumberInRange(0.01125f, 0.09f)),
+		// 	nil, 0.63f);
+
+		// CVector coors = damagePos;
+		// coors.x += CGeneral::GetRandomNumberInRange(-0.5625f, 0.5625f),
+		// coors.y += CGeneral::GetRandomNumberInRange(-0.5625f, 0.5625f),
+		// coors.z += CGeneral::GetRandomNumberInRange(0.5625f, 2.25f);
+		// CParticle::AddParticle(PARTICLE_CARFLAME_SMOKE, coors, CVector(0.0f, 0.0f, 0.0f));
+
+		// CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2, damagePos, CVector(0.0f, 0.0f, 0.0f), nil, 0.5f);
+
+		// Blow up car after 5 seconds
+		// m_fFireBlowUpTimer += CTimer::GetTimeStepInMilliseconds();
 		// Hmm, chaos mode? Change the value of this damage to be random
 		// if(m_fDamage > 5000.0f)
 
 		// Get a random number
 		// https://www.digitalocean.com/community/tutorials/random-number-generator-c-plus-plus
 // #define _CUSTOM_CODE
-#undef _CUSTOM_CODE
-#ifdef _CUSTOM_CODE
-		float random = rand();
-		if(m_fFireBlowUpTimer > random)
-#else
-		if(m_fFireBlowUpTimer > 5000.0f)
-#endif                  // _CUSTOM_CODE
-#define _CUSTOM_CODE
-			BlowUpCar(m_pSetOnFireEntity);
-	}else
-		m_fFireBlowUpTimer = 0.0f;
+// #undef _CUSTOM_CODE
+// #ifdef _CUSTOM_CODE
+// 		float random = rand();
+// 		if(m_fFireBlowUpTimer > random)
+// #else
+// 		if(m_fFireBlowUpTimer > 5000.0f)
+// #endif                  // _CUSTOM_CODE
+// #define _CUSTOM_CODE
+			// BlowUpCar(m_pSetOnFireEntity);
+	// }else
+		// m_fFireBlowUpTimer = 0.0f;
 
 	// Decrease car health if engine is damaged badly
 	if(engineStatus > ENGINE_STATUS_ON_FIRE && m_fHealth > 250.0f)
@@ -1797,6 +2017,17 @@ CAutomobile::PreRender(void)
 	int i, j, n;
 	CVehicleModelInfo *mi = (CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex());
 
+#ifdef IMPROVED_VEHICLES // SwitchVehicleToRealPhysics when the car is next to the player
+	if (GetStatus() == STATUS_SIMPLE && FindPlayerVehicle() != this) {
+		float radiusSqr = 750.0f;
+		float distanceSqr = (GetPosition() - FindPlayerCoors()).MagnitudeSqr();
+		if (distanceSqr < radiusSqr) {
+			SetStatus(STATUS_PHYSICS);
+			CCarCtrl::SwitchVehicleToRealPhysics(this);
+		}
+	}
+#endif
+
 	if(GetModelIndex() == MI_RHINO && m_aCarNodes[CAR_WINDSCREEN]){
 		// Rotate Rhino turret
 		CMatrix m;
@@ -2279,303 +2510,347 @@ CAutomobile::PreRender(void)
 	   GetVehicleAppearance() != VEHICLE_APPEARANCE_HELI) {
 	// Process lights
 
-	// Turn lights on/off
-	bool shouldLightsBeOn = 
-		CClock::GetHours() > 20 ||
-		CClock::GetHours() > 19 && CClock::GetMinutes() > (m_randomSeed & 0x3F) ||
-		CClock::GetHours() < 7 ||
-		CClock::GetHours() < 8 && CClock::GetMinutes() < (m_randomSeed & 0x3F) ||
-		m_randomSeed/50000.0f < CWeather::Foggyness ||
-		m_randomSeed/50000.0f < CWeather::WetRoads;
-	if(shouldLightsBeOn != bLightsOn && GetStatus() != STATUS_WRECKED){
-		if(GetStatus() == STATUS_ABANDONED){
-			// Turn off lights on abandoned vehicles only when we they're far away
-			if(bLightsOn &&
-			   Abs(TheCamera.GetPosition().x - GetPosition().x) + Abs(TheCamera.GetPosition().y - GetPosition().y) > 100.0f)
-				bLightsOn = false;
-		}else
-			bLightsOn = shouldLightsBeOn;
-	}
-
-	// Actually render the lights
-	bool alarmOn = false;
-	bool alarmOff = false;
-	if(IsAlarmOn()){
-		if(CTimer::GetTimeInMilliseconds() & 0x100)
-			alarmOn = true;
-		else
-			alarmOff = true;
-	}
-	if(bEngineOn && bLightsOn || alarmOn || alarmOff){
-		CVector lookVector = GetPosition() - TheCamera.GetPosition();
-		float camDist = lookVector.Magnitude();
-		if(camDist != 0.0f)
-			lookVector *= 1.0f/camDist;
-		else
-			lookVector = CVector(1.0f, 0.0f, 0.0f);
-
-		// 1.0 if directly behind car, -1.0 if in front
-		float behindness = DotProduct(lookVector, GetForward());
-		behindness = Clamp(behindness, -1.0f, 1.0f);	// shouldn't be necessary
-		// 0.0 if behind car, PI if in front
-		// Abs not necessary
-		float angle = Abs(Acos(behindness));
-
-		// Headlights
+#ifdef IMPROVED_VEHICLES_2
+	DoVehicleLights();
+#else
+// Turn lights on/off
+bool shouldLightsBeOn = 
+	CClock::GetHours() > 20 ||
+	CClock::GetHours() > 19 && CClock::GetMinutes() > (m_randomSeed & 0x3F) ||
+	CClock::GetHours() < 7 ||
+	CClock::GetHours() < 8 && CClock::GetMinutes() < (m_randomSeed & 0x3F) ||
+	m_randomSeed/50000.0f < CWeather::Foggyness ||
+	m_randomSeed/50000.0f < CWeather::WetRoads;
+if(shouldLightsBeOn != bLightsOn && GetStatus() != STATUS_WRECKED){
+	if(GetStatus() == STATUS_ABANDONED){
+		// Turn off lights on abandoned vehicles only when we they're far away
+		if(bLightsOn &&
+		   Abs(TheCamera.GetPosition().x - GetPosition().x) + Abs(TheCamera.GetPosition().y - GetPosition().y) > 100.0f)
+			bLightsOn = false;
+	}else
+		bLightsOn = shouldLightsBeOn;
+}
 
-		CVector headLightPos = mi->m_positions[CAR_POS_HEADLIGHTS];
-		CVector lightR = GetMatrix() * headLightPos;
-		CVector lightL = lightR;
-		lightL -= GetRight()*2.0f*headLightPos.x;
-
-		// Headlight coronas
-		if(DotProduct(lightR-TheCamera.GetPosition(), GetForward()) < 0.0f &&
-		   (TheCamera.Cams[TheCamera.ActiveCam].Mode != CCam::MODE_1STPERSON || this != FindPlayerVehicle())){
-			// In front of car
-			float intensity = -0.5f*behindness + 0.3f;
-			float size = 1.0f - behindness;
-
-			if(behindness < -0.97f && camDist < 30.0f){
-				// Directly in front and not too far away
-				if(pHandling->Flags & HANDLING_HALOGEN_LIGHTS){
-					if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this + 6, 150, 150, 195, 255,
-							lightL, 1.2f, 45.0f*TheCamera.LODDistMultiplier,
-							CCoronas::TYPE_HEADLIGHT, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
-					if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this + 7, 150, 150, 195, 255,
-							lightR, 1.2f, 45.0f*TheCamera.LODDistMultiplier,
-							CCoronas::TYPE_HEADLIGHT, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
-				}else{
-					if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this + 6, 160, 160, 140, 255,
-							lightL, 1.2f, 45.0f*TheCamera.LODDistMultiplier,
-							CCoronas::TYPE_HEADLIGHT, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
-					if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this + 7, 160, 160, 140, 255,
-							lightR, 1.2f, 45.0f*TheCamera.LODDistMultiplier,
-							CCoronas::TYPE_HEADLIGHT, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
-				}
+// Actually render the lights
+bool alarmOn = false;
+bool alarmOff = false;
+if(IsAlarmOn()){
+	if(CTimer::GetTimeInMilliseconds() & 0x100)
+		alarmOn = true;
+	else
+		alarmOff = true;
+}
+if(bEngineOn && bLightsOn || alarmOn || alarmOff){
+	CVector lookVector = GetPosition() - TheCamera.GetPosition();
+	float camDist = lookVector.Magnitude();
+	if(camDist != 0.0f)
+		lookVector *= 1.0f/camDist;
+	else
+		lookVector = CVector(1.0f, 0.0f, 0.0f);
+
+	// 1.0 if directly behind car, -1.0 if in front
+	float behindness = DotProduct(lookVector, GetForward());
+	behindness = Clamp(behindness, -1.0f, 1.0f);	// shouldn't be necessary
+	// 0.0 if behind car, PI if in front
+	// Abs not necessary
+	float angle = Abs(Acos(behindness));
+
+	// Headlights
+
+	CVector headLightPos = mi->m_positions[CAR_POS_HEADLIGHTS];
+	CVector lightR = GetMatrix() * headLightPos;
+	CVector lightL = lightR;
+	lightL -= GetRight()*2.0f*headLightPos.x;
+
+	// Headlight coronas
+	if(DotProduct(lightR-TheCamera.GetPosition(), GetForward()) < 0.0f &&
+	   (TheCamera.Cams[TheCamera.ActiveCam].Mode != CCam::MODE_1STPERSON || this != FindPlayerVehicle())){
+		// In front of car
+		float intensity = -0.5f*behindness + 0.3f;
+		float size = 1.0f - behindness;
+
+		if(behindness < -0.97f && camDist < 30.0f){
+			// Directly in front and not too far away
+			if(pHandling->Flags & HANDLING_HALOGEN_LIGHTS){
+				if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK)
+					CCoronas::RegisterCorona((uintptr)this + 6, 150, 150, 195, 255,
+						lightL, 1.2f, 45.0f*TheCamera.LODDistMultiplier,
+						CCoronas::TYPE_HEADLIGHT, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+				if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
+					CCoronas::RegisterCorona((uintptr)this + 7, 150, 150, 195, 255,
+						lightR, 1.2f, 45.0f*TheCamera.LODDistMultiplier,
+						CCoronas::TYPE_HEADLIGHT, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+			}else{
+				if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK)
+					CCoronas::RegisterCorona((uintptr)this + 6, 160, 160, 140, 255,
+						lightL, 1.2f, 45.0f*TheCamera.LODDistMultiplier,
+						CCoronas::TYPE_HEADLIGHT, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+				if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
+					CCoronas::RegisterCorona((uintptr)this + 7, 160, 160, 140, 255,
+						lightR, 1.2f, 45.0f*TheCamera.LODDistMultiplier,
+						CCoronas::TYPE_HEADLIGHT, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
 			}
+		}
 
-			if(alarmOff){
+		if(alarmOff){
+			if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK)
+				CCoronas::RegisterCorona((uintptr)this, 0, 0, 0, 0,
+					lightL, size, 0.0f,
+					CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+					CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+			if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
+				CCoronas::RegisterCorona((uintptr)this + 1, 0, 0, 0, 0,
+					lightR, size, 0.0f,
+					CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+					CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+		}else{
+			if(pHandling->Flags & HANDLING_HALOGEN_LIGHTS){
 				if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK)
-					CCoronas::RegisterCorona((uintptr)this, 0, 0, 0, 0,
-						lightL, size, 0.0f,
+					CCoronas::RegisterCorona((uintptr)this, 190*intensity, 190*intensity, 255*intensity, 255,
+						lightL, size, 50.0f*TheCamera.LODDistMultiplier,
 						CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
 						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
 				if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
-					CCoronas::RegisterCorona((uintptr)this + 1, 0, 0, 0, 0,
-						lightR, size, 0.0f,
+					CCoronas::RegisterCorona((uintptr)this + 1, 190*intensity, 190*intensity, 255*intensity, 255,
+						lightR, size, 50.0f*TheCamera.LODDistMultiplier,
 						CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
 						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
 			}else{
-				if(pHandling->Flags & HANDLING_HALOGEN_LIGHTS){
-					if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this, 190*intensity, 190*intensity, 255*intensity, 255,
-							lightL, size, 50.0f*TheCamera.LODDistMultiplier,
-							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
-					if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this + 1, 190*intensity, 190*intensity, 255*intensity, 255,
-							lightR, size, 50.0f*TheCamera.LODDistMultiplier,
-							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
-				}else{
-					if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this, 210*intensity, 210*intensity, 195*intensity, 255,
-							lightL, size, 50.0f*TheCamera.LODDistMultiplier,
-							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
-					if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this + 1, 210*intensity, 210*intensity, 195*intensity, 255,
-							lightR, size, 50.0f*TheCamera.LODDistMultiplier,
-							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
-				}
+				if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK)
+					CCoronas::RegisterCorona((uintptr)this, 210*intensity, 210*intensity, 195*intensity, 255,
+						lightL, size, 50.0f*TheCamera.LODDistMultiplier,
+						CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+				if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
+					CCoronas::RegisterCorona((uintptr)this + 1, 210*intensity, 210*intensity, 195*intensity, 255,
+						lightR, size, 50.0f*TheCamera.LODDistMultiplier,
+						CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
 			}
-		}else{
-			// Behind car
-			if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK)
-				CCoronas::UpdateCoronaCoors((uintptr)this, lightL, 50.0f*TheCamera.LODDistMultiplier, angle);
-			if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
-				CCoronas::UpdateCoronaCoors((uintptr)this + 1, lightR, 50.0f*TheCamera.LODDistMultiplier, angle);
 		}
+	}else{
+		// Behind car
+		if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK)
+			CCoronas::UpdateCoronaCoors((uintptr)this, lightL, 50.0f*TheCamera.LODDistMultiplier, angle);
+		if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
+			CCoronas::UpdateCoronaCoors((uintptr)this + 1, lightR, 50.0f*TheCamera.LODDistMultiplier, angle);
+	}
 
-		// bright lights
-		if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK && !bNoBrightHeadLights)
-			CBrightLights::RegisterOne(lightL, GetUp(), GetRight(), GetForward(), pHandling->FrontLights + BRIGHTLIGHT_FRONT);
-		if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK && !bNoBrightHeadLights)
-			CBrightLights::RegisterOne(lightR, GetUp(), GetRight(), GetForward(), pHandling->FrontLights + BRIGHTLIGHT_FRONT);
+#ifndef IMPROVED_VEHICLES // remove bright lights (cubes)
+	// bright lights
+	if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK && !bNoBrightHeadLights)
+		CBrightLights::RegisterOne(lightL, GetUp(), GetRight(), GetForward(), pHandling->FrontLights + BRIGHTLIGHT_FRONT);
+	if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK && !bNoBrightHeadLights)
+		CBrightLights::RegisterOne(lightR, GetUp(), GetRight(), GetForward(), pHandling->FrontLights + BRIGHTLIGHT_FRONT);
+#endif
 
-		// Taillights
+	// Taillights
 
-		CVector tailLightPos = mi->m_positions[CAR_POS_TAILLIGHTS];
-		lightR = GetMatrix() * tailLightPos;
-		lightL = lightR;
-		lightL -= GetRight()*2.0f*tailLightPos.x;
+	CVector tailLightPos = mi->m_positions[CAR_POS_TAILLIGHTS];
+	lightR = GetMatrix() * tailLightPos;
+	lightL = lightR;
+	lightL -= GetRight()*2.0f*tailLightPos.x;
 
-		// Taillight coronas
-		if(DotProduct(lightR-TheCamera.GetPosition(), GetForward()) > 0.0f){
-			// Behind car
-			float intensity = (behindness + 1.0f)*0.4f;
-			float size = (behindness + 1.0f)*0.5f;
+	// Taillight coronas
+	if(DotProduct(lightR-TheCamera.GetPosition(), GetForward()) > 0.0f){
+		// Behind car
+		float intensity = (behindness + 1.0f)*0.4f;
+		float size = (behindness + 1.0f)*0.5f;
 
-			if(m_fGasPedal < 0.0f){
-				// reversing
+		if(m_fGasPedal < 0.0f){
+			// reversing
+			intensity += 0.4f;
+			size += 0.3f;
+
+			if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
+				CCoronas::RegisterCorona((uintptr)this + 14, 128*intensity, 128*intensity, 128*intensity, 255,
+					lightL, size, 50.0f*TheCamera.LODDistMultiplier,
+					CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+					CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+			if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
+				CCoronas::RegisterCorona((uintptr)this + 15, 128*intensity, 128*intensity, 128*intensity, 255,
+					lightR, size, 50.0f*TheCamera.LODDistMultiplier,
+					CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+					CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+		}else{
+			if (m_fBrakePedal > 0.0f) {
 				intensity += 0.4f;
 				size += 0.3f;
+			}
+
+			if(alarmOff){
+				if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
+					CCoronas::RegisterCorona((uintptr)this + 14, 0, 0, 0, 0,
+						lightL, size, 0.0f,
+						CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+				if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
+					CCoronas::RegisterCorona((uintptr)this + 15, 0, 0, 0, 0,
+						lightR, size, 0.0f,
+						CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+			}else{
 				if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
-					CCoronas::RegisterCorona((uintptr)this + 14, 128*intensity, 128*intensity, 128*intensity, 255,
+					CCoronas::RegisterCorona((uintptr)this + 14, 128*intensity, 0, 0, 255,
 						lightL, size, 50.0f*TheCamera.LODDistMultiplier,
 						CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
 						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
 				if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
-					CCoronas::RegisterCorona((uintptr)this + 15, 128*intensity, 128*intensity, 128*intensity, 255,
+					CCoronas::RegisterCorona((uintptr)this + 15, 128*intensity, 0, 0, 255,
 						lightR, size, 50.0f*TheCamera.LODDistMultiplier,
 						CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
 						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
-			}else{
-				if(m_fBrakePedal > 0.0f){
-					intensity += 0.4f;
-					size += 0.3f;
-				}
-
-				if(alarmOff){
-					if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this + 14, 0, 0, 0, 0,
-							lightL, size, 0.0f,
-							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
-					if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this + 15, 0, 0, 0, 0,
-							lightR, size, 0.0f,
-							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
-				}else{
-					if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this + 14, 128*intensity, 0, 0, 255,
-							lightL, size, 50.0f*TheCamera.LODDistMultiplier,
-							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
-					if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this + 15, 128*intensity, 0, 0, 255,
-							lightR, size, 50.0f*TheCamera.LODDistMultiplier,
-							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
-				}
 			}
-		}else{
-			// In front of car
-			// missing LODDistMultiplier probably a BUG
-			if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
-				CCoronas::UpdateCoronaCoors((uintptr)this + 14, lightL, 50.0f, angle);
-			if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
-				CCoronas::UpdateCoronaCoors((uintptr)this + 15, lightR, 50.0f, angle);
 		}
-
-		// bright lights
+	}else{
+		// In front of car
+		// missing LODDistMultiplier probably a BUG
 		if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
-			CBrightLights::RegisterOne(lightL, GetUp(), GetRight(), GetForward(), pHandling->RearLights + BRIGHTLIGHT_REAR);
+			CCoronas::UpdateCoronaCoors((uintptr)this + 14, lightL, 50.0f, angle);
 		if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
-			CBrightLights::RegisterOne(lightR, GetUp(), GetRight(), GetForward(), pHandling->RearLights + BRIGHTLIGHT_REAR);
+			CCoronas::UpdateCoronaCoors((uintptr)this + 15, lightR, 50.0f, angle);
+	}
 
-		// Light shadows
-		if(!alarmOff){
-			CVector pos = GetPosition();
-			CVector2D fwd(GetForward());
-			fwd.Normalise();
-			float f = headLightPos.y + 6.0f;
-			pos += CVector(f*fwd.x, f*fwd.y, 2.0f);
-
-			if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK ||
-			   Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
-				CShadows::StoreCarLightShadow(this, (uintptr)this + 22, gpShadowHeadLightsTex, &pos,
-					7.0f*fwd.x, 7.0f*fwd.y, 5.5f*fwd.y, -5.5f*fwd.x, 45, 45, 45, 7.0f);
-
-			f = (tailLightPos.y - 2.5f) - (headLightPos.y + 6.0f);
-			pos += CVector(f*fwd.x, f*fwd.y, 0.0f);
-			if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK ||
-			   Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
-				CShadows::StoreCarLightShadow(this, (uintptr)this + 25, gpShadowExplosionTex, &pos,
-					3.0f, 0.0f, 0.0f, -3.0f, 35, 0, 0, 4.0f);
-		}
-
-		if(this == FindPlayerVehicle() && !alarmOff){
-			if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK ||
-			   Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
-				CPointLights::AddLight(CPointLights::LIGHT_DIRECTIONAL, GetPosition(), GetForward(),
-					20.0f, 1.0f, 1.0f, 1.0f,
-					FindPlayerVehicle()->m_vecMoveSpeed.MagnitudeSqr2D() < sq(0.45f) ? CPointLights::FOG_NORMAL : CPointLights::FOG_NONE,
-					false);
-			CVector pos = GetPosition() - 4.0f*GetForward();
-			if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK ||
-			   Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK) {
-				if(m_fBrakePedal > 0.0f)
-					CPointLights::AddLight(CPointLights::LIGHT_POINT, pos, CVector(0.0f, 0.0f, 0.0f),
-						10.0f, 1.0f, 0.0f, 0.0f,
-						CPointLights::FOG_NONE, false);
-				else
-					CPointLights::AddLight(CPointLights::LIGHT_POINT, pos, CVector(0.0f, 0.0f, 0.0f),
-						7.0f, 0.6f, 0.0f, 0.0f,
-						CPointLights::FOG_NONE, false);
-			}
+#ifndef IMPROVED_VEHICLES // remove bright lights (cubes)
+	// bright lights
+	if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
+		CBrightLights::RegisterOne(lightL, GetUp(), GetRight(), GetForward(), pHandling->RearLights + BRIGHTLIGHT_REAR);
+	if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
+		CBrightLights::RegisterOne(lightR, GetUp(), GetRight(), GetForward(), pHandling->RearLights + BRIGHTLIGHT_REAR);
+#endif
+
+	// Light shadows
+#ifdef IMPROVED_VEHICLES // Headlight texture now divided into two parts, reversing lights have texture of light (thanks to Alex_Delphi)
+	if(!alarmOff){
+		CVector2D fwd(GetForward());
+		fwd.Normalise();
+		float f = tailLightPos.y + 2.0f;
+		if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK) {
+			lightR += CVector(f * fwd.x, f * fwd.y, 2.0f);
+			if(m_fGasPedal < 0.0f) // reversing
+				CShadows::StoreCarLightShadow(this, (uintptr)this + 27, gpShadowExplosionTex, &lightR, 1.0f, 0.0f, 0.0f, -1.0f, 35, 35, 35, 4.0f);
+			else
+				CShadows::StoreCarLightShadow(this, (uintptr)this + 27, gpShadowExplosionTex, &lightR, 1.0f, 0.0f, 0.0f, -1.0f, 35, 0, 0, 4.0f);
+		}
+		if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK) {
+			lightL += CVector(f * fwd.x, f * fwd.y, 2.0f);
+			if(m_fGasPedal < 0.0f) // reversing
+				CShadows::StoreCarLightShadow(this, (uintptr)this + 29, gpShadowExplosionTex, &lightL, 1.0f, 0.0f, 0.0f, -1.0f, 35, 35, 35, 4.0f);
+			else
+				CShadows::StoreCarLightShadow(this, (uintptr)this + 29, gpShadowExplosionTex, &lightL, 1.0f, 0.0f, 0.0f, -1.0f, 35, 0, 0, 4.0f);
 		}
-	}else if(GetStatus() != STATUS_ABANDONED && GetStatus() != STATUS_WRECKED){
-		// Lights off
 
-		CVector lightPos = mi->m_positions[CAR_POS_TAILLIGHTS];
-		CVector lightR = GetMatrix() * lightPos;
-		CVector lightL = lightR;
-		lightL -= GetRight()*2.0f*lightPos.x;
 
-		if(m_fBrakePedal > 0.0f || m_fGasPedal < 0.0f){
-			CVector lookVector = GetPosition() - TheCamera.GetPosition();
-			lookVector.Normalise();
-			float behindness = DotProduct(lookVector, GetForward());
-			if(behindness > 0.0f){
-				if(m_fGasPedal < 0.0f){
-					// reversing
-					if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this + 14, 120, 120, 120, 255,
-							lightL, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
-							CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, 0.0f);
-					if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this + 15, 120, 120, 120, 255,
-							lightR, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
-							CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, 0.0f);
-					if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
-						CBrightLights::RegisterOne(lightL, GetUp(), GetRight(), GetForward(), pHandling->RearLights + BRIGHTLIGHT_FRONT);
-					if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
-						CBrightLights::RegisterOne(lightR, GetUp(), GetRight(), GetForward(), pHandling->RearLights + BRIGHTLIGHT_FRONT);
-				}else{
-					// braking
-					if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this + 14, 120, 0, 0, 255,
-							lightL, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
-							CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, 0.0f);
-					if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
-						CCoronas::RegisterCorona((uintptr)this + 15, 120, 0, 0, 255,
-							lightR, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
-							CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
-							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, 0.0f);
-					if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
-						CBrightLights::RegisterOne(lightL, GetUp(), GetRight(), GetForward(), pHandling->RearLights + BRIGHTLIGHT_REAR);
-					if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
-						CBrightLights::RegisterOne(lightR, GetUp(), GetRight(), GetForward(), pHandling->RearLights + BRIGHTLIGHT_REAR);
-				}
+		lightR = GetMatrix() * headLightPos;
+		lightL = lightR;
+		lightL -= GetRight() * 2.0f * headLightPos.x;
+		f = headLightPos.y + 6.0f;			
+		if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK) {
+			lightR += CVector(f * fwd.x, f * fwd.y, 2.0f);
+			CShadows::StoreCarLightShadow(this, (uintptr)this + 22, gpShadowHeadLightsTex, &lightR, 8.0f * fwd.x, 8.0f * fwd.y,
+			4.5f * fwd.y, -4.5f * fwd.x, 45, 45, 45, 7.0f);
+		}
+		if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK) {
+			lightL += CVector(f * fwd.x, f * fwd.y, 2.0f);
+			CShadows::StoreCarLightShadow(this, (uintptr)this + 25, gpShadowHeadLightsTex, &lightL, 8.0f * fwd.x, 8.0f * fwd.y,
+			4.5f * fwd.y, -4.5f * fwd.x, 45, 45, 45, 7.0f);
+		}
+	}
+#else
+	if(!alarmOff){
+		CVector pos = GetPosition();
+		CVector2D fwd(GetForward());
+		fwd.Normalise();
+		float f = headLightPos.y + 6.0f;
+		pos += CVector(f*fwd.x, f*fwd.y, 2.0f);
+
+		if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK ||
+		   Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
+			CShadows::StoreCarLightShadow(this, (uintptr)this + 22, gpShadowHeadLightsTex, &pos,
+				7.0f*fwd.x, 7.0f*fwd.y, 5.5f*fwd.y, -5.5f*fwd.x, 45, 45, 45, 7.0f);
+
+		f = (tailLightPos.y - 2.5f) - (headLightPos.y + 6.0f);
+		pos += CVector(f*fwd.x, f*fwd.y, 0.0f);
+		if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK ||
+		   Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
+			CShadows::StoreCarLightShadow(this, (uintptr)this + 25, gpShadowExplosionTex, &pos,
+				3.0f, 0.0f, 0.0f, -3.0f, 35, 0, 0, 4.0f);
+	}
+#endif
+
+	if(this == FindPlayerVehicle() && !alarmOff){
+		if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK ||
+		   Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
+			CPointLights::AddLight(CPointLights::LIGHT_DIRECTIONAL, GetPosition(), GetForward(),
+				20.0f, 1.0f, 1.0f, 1.0f,
+				FindPlayerVehicle()->m_vecMoveSpeed.MagnitudeSqr2D() < sq(0.45f) ? CPointLights::FOG_NORMAL : CPointLights::FOG_NONE,
+				false);
+		CVector pos = GetPosition() - 4.0f*GetForward();
+		if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK ||
+		   Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK) {
+			if(m_fBrakePedal > 0.0f)
+				CPointLights::AddLight(CPointLights::LIGHT_POINT, pos, CVector(0.0f, 0.0f, 0.0f),
+					10.0f, 1.0f, 0.0f, 0.0f,
+					CPointLights::FOG_NONE, false);
+			else
+				CPointLights::AddLight(CPointLights::LIGHT_POINT, pos, CVector(0.0f, 0.0f, 0.0f),
+					7.0f, 0.6f, 0.0f, 0.0f,
+					CPointLights::FOG_NONE, false);
+		}
+	}
+}else if(GetStatus() != STATUS_ABANDONED && GetStatus() != STATUS_WRECKED){
+	// Lights off
+
+	CVector lightPos = mi->m_positions[CAR_POS_TAILLIGHTS];
+	CVector lightR = GetMatrix() * lightPos;
+	CVector lightL = lightR;
+	lightL -= GetRight()*2.0f*lightPos.x;
+
+	if(m_fBrakePedal > 0.0f || m_fGasPedal < 0.0f){
+		CVector lookVector = GetPosition() - TheCamera.GetPosition();
+		lookVector.Normalise();
+		float behindness = DotProduct(lookVector, GetForward());
+		if(behindness > 0.0f){
+			if(m_fGasPedal < 0.0f){
+				// reversing
+				if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
+					CCoronas::RegisterCorona((uintptr)this + 16, 120, 120, 120, 255,
+						lightL, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
+						CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, 0.0f);
+				if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
+					CCoronas::RegisterCorona((uintptr)this + 17, 120, 120, 120, 255,
+						lightR, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
+						CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, 0.0f);
+#ifndef IMPROVED_VEHICLES // remove bright lights (cubes)
+				if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
+					CBrightLights::RegisterOne(lightL, GetUp(), GetRight(), GetForward(), pHandling->RearLights + BRIGHTLIGHT_FRONT);
+				if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
+					CBrightLights::RegisterOne(lightR, GetUp(), GetRight(), GetForward(), pHandling->RearLights + BRIGHTLIGHT_FRONT);
+#endif
 			}else{
+				// braking
 				if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
-					CCoronas::UpdateCoronaCoors((uintptr)this + 14, lightL, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
+					CCoronas::RegisterCorona((uintptr)this + 18, 120, 0, 0, 255,
+						lightL, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
+						CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, 0.0f);
 				if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
-					CCoronas::UpdateCoronaCoors((uintptr)this + 15, lightR, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
+					CCoronas::RegisterCorona((uintptr)this + 19, 120, 0, 0, 255,
+						lightR, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
+						CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, 0.0f);
+#ifndef IMPROVED_VEHICLES // remove bright lights (cubes)
+				if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
+					CBrightLights::RegisterOne(lightL, GetUp(), GetRight(), GetForward(), pHandling->RearLights + BRIGHTLIGHT_REAR);
+				if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
+					CBrightLights::RegisterOne(lightR, GetUp(), GetRight(), GetForward(), pHandling->RearLights + BRIGHTLIGHT_REAR);
+#endif
 			}
 		}else{
 			if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
@@ -2583,7 +2858,14 @@ CAutomobile::PreRender(void)
 			if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
 				CCoronas::UpdateCoronaCoors((uintptr)this + 15, lightR, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
 		}
+	}else{
+		if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
+			CCoronas::UpdateCoronaCoors((uintptr)this + 14, lightL, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
+		if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
+			CCoronas::UpdateCoronaCoors((uintptr)this + 15, lightR, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
 	}
+}
+#endif
 	// end of lights
 	}
 
@@ -2976,8 +3258,72 @@ CAutomobile::PreRender(void)
 		ProcessSwingingDoor(CAR_BOOT, DOOR_BOOT);
 	}
 
+	#ifdef IMPROVED_VEHICLES_2 // rotate steering wheel
+	if (m_aCarNodes[CAR_STEERINGWHEEL]) {
+		CMatrix mat;
+		CVector pos;
+		mat.Attach(RwFrameGetMatrix(m_aCarNodes[CAR_STEERINGWHEEL]));
+		pos = mat.GetPosition();
+		float headingX = Atan2(mat.GetForward().z, mat.GetForward().y);
+		mat.SetRotate(headingX, -m_fSteerAngle * 2.0f, 0.0f);
+		mat.Translate(pos);
+		mat.UpdateRW();
+	}
+#endif
+
+#if defined IMPROVED_VEHICLES && defined VEHICLE_MODS // rotate supercharger things
+	if (m_aCarNodes[CAR_SUPERCHARGER] && bEngineOn) {
+		float carbRotation = 0.0f;
+		float flywheelRotation = 0.0f;
+
+		if(m_fPropellerRotation > TWOPI) m_fPropellerRotation -= TWOPI;
+
+		if(Abs(m_fGasPedal) > 0.0f){
+			m_fPropellerRotation += 0.2f*CTimer::GetTimeStep();
+			flywheelRotation = m_fPropellerRotation;
+
+			if(m_fCarbRotation < 1.3f){
+				m_fCarbRotation = Min(m_fCarbRotation +0.1f*CTimer::GetTimeStep(), 1.3f);
+				carbRotation = m_fCarbRotation;
+			}else{
+				float wave = Sin((CTimer::GetTimeInMilliseconds()%10000)/70.0f);
+				carbRotation = m_fCarbRotation + 0.13*wave;
+			}
+		}else{
+			m_fPropellerRotation += 0.1f*CTimer::GetTimeStep();
+			flywheelRotation = m_fPropellerRotation;
+
+			if(m_fCarbRotation > 0.0f){
+				m_fCarbRotation = Max(m_fCarbRotation -0.05f*CTimer::GetTimeStep(), 0.0f);
+				carbRotation = m_fCarbRotation;
+			}
+		}
+
+		RwFrame* carbFrame = m_aCarNodes[CAR_SUPERCHARGER]->child->child->child;
+		mat.Attach(RwFrameGetMatrix(carbFrame));
+		pos = mat.GetPosition();
+		mat.SetRotateX(carbRotation);
+		mat.Translate(pos);
+		mat.UpdateRW();
+
+		RwFrame* flywheelFrame = m_aCarNodes[CAR_SUPERCHARGER]->child->child->next->child;
+		mat.Attach(RwFrameGetMatrix(flywheelFrame));
+		pos = mat.GetPosition();
+		mat.SetRotateY(flywheelRotation);
+		mat.Translate(pos);
+		mat.UpdateRW();
+	}
+#endif
+
 	if((GetModelIndex() == MI_PHEONIX || GetModelIndex() == MI_BFINJECT) &&
+
+#ifdef IMPROVED_VEHICLES
+		bEngineOn && m_aCarNodes[CAR_WING_LR]){
+#else
 	   GetStatus() == STATUS_PLAYER && m_aCarNodes[CAR_WING_LR]){
+#endif
+
+
 		float rotation = 0.0f;
 
 		if(GetModelIndex() == MI_BFINJECT)
@@ -3024,7 +3370,583 @@ CAutomobile::Render(void)
 {
 	CVehicleModelInfo *mi = (CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex());
 
+#if defined VEHICLE_MODS && defined IMPROVED_VEHICLES
+	uint8 color1 = CGarages::bPlayerInModGarage ? m_nTempColor1 : m_currentColour1;
+	uint8 color2 = CGarages::bPlayerInModGarage ? m_nTempColor2 : m_currentColour2;
+	uint8 color3 = CGarages::bPlayerInModGarage ? m_nTempColor3 : m_currentColour3;
+	uint8 color4 = CGarages::bPlayerInModGarage ? m_nTempColor4 : m_currentColour4;
+	mi->SetVehicleColour(color1, color2, color3, color4);
+
+	if (m_nSpoilerColor == -1) {
+		m_nSpoilerColor = color1;
+		m_nTempSpoilerColor = color1;
+	}
+
+	if (FindPlayerVehicle() == this && !CGarages::bPlayerInModGarage) {
+		m_nTempColor1 = m_currentColour1;
+		m_nTempColor2 = m_currentColour2;
+		m_nTempColor3 = m_currentColour3;
+		m_nTempColor4 = m_currentColour4;
+	}
+
+	// rims
+	for (int nodeID = CAR_WHEEL_RF; nodeID <= CAR_WHEEL_LB; nodeID++) {
+		if (!m_aCarNodes[nodeID])
+			continue;
+
+		RpAtomic* wheelAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[nodeID], GetCurrentAtomicObjectCB, &wheelAtomic);
+
+		if (!wheelAtomic)
+			continue;
+
+		int wheelColor = CGarages::bPlayerInModGarage ? m_nTempRimsColor : m_nRimsColor;
+		RpMaterial* material1 = wheelAtomic->geometry->matList.materials[0];
+		//RpMaterial* material2 = wheelAtomic->geometry->matList.materials[1];
+		material1->color = CVehicleModelInfo::ms_vehicleColourTable[wheelColor];
+		//material2->color = CVehicleModelInfo::ms_vehicleColourTable[wheelColor];
+	}
+
+	// spoiler
+	for (int frameID = CAR_SPOILER_OK; frameID <= CAR_SPOILER_DAM; frameID++) {
+		if (!m_aCarNodes[frameID])
+			continue;
+
+		RpAtomic* upgradeAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[frameID], GetCurrentAtomicObjectCB, &upgradeAtomic);
+		if (!upgradeAtomic)
+			continue;
+
+		RpMaterial* material = upgradeAtomic->geometry->matList.materials[0];
+		int color = CGarages::bPlayerInModGarage ? m_nTempSpoilerColor : m_nSpoilerColor;
+		material->color = CVehicleModelInfo::ms_vehicleColourTable[color];
+	}
+
+	// vehicle mods
+	for (int frameID = CAR_SKIRT_L; frameID <= CAR_VENT_R_DAM; frameID++) {
+		if (!m_aCarNodes[frameID])
+			continue;
+
+		RpAtomic* upgradeAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[frameID], GetCurrentAtomicObjectCB, &upgradeAtomic);
+		if (!upgradeAtomic)
+			continue;
+
+		RpMaterial* material = upgradeAtomic->geometry->matList.materials[0];
+		int color = CGarages::bPlayerInModGarage ? m_nTempColor1 : m_currentColour1;
+		material->color = CVehicleModelInfo::ms_vehicleColourTable[color];
+	}
+
+	// modified bonnet
+	if (m_aCarNodes[CAR_SUPERCHARGER]) {
+		RpAtomic* upgradeAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_BONNET], GetCurrentAtomicObjectCB, &upgradeAtomic);
+		if (upgradeAtomic) {
+			RpMaterial* material = upgradeAtomic->geometry->matList.materials[0];
+			int color = CGarages::bPlayerInModGarage ? m_nTempColor1 : m_currentColour1;
+			material->color = CVehicleModelInfo::ms_vehicleColourTable[color];
+		}
+	}
+
+	if (CGarages::IsCarTintable(this)) {
+		// windows alpha
+		CRGBA windowColor = mi->m_nDefaultWindowMaterialColor;
+		int tintLevel = CGarages::bPlayerInModGarage ? m_nTempWindowTintLevel : m_nWindowTintLevel;
+		if (tintLevel > 2 && FindPlayerVehicle() == this && TheCamera.Cams[TheCamera.ActiveCam].Mode == CCam::MODE_REAL_1ST_PERSON) {
+			windowColor = CRGBA(0, 0, 0, 150);
+		} else {
+			switch (tintLevel) {
+			case 2:
+				windowColor = CRGBA(0, 0, 0, 150);
+				break;
+			case 3:
+				windowColor = CRGBA(0, 0, 0, 187);
+				break;
+			case 4:
+				windowColor = CRGBA(0, 0, 0, 225);
+				break;
+			}
+		}
+
+		for (int frameID = CAR_WING_RF; frameID <= CAR_DOOR_LR; frameID++) {
+			if (!m_aCarNodes[frameID])
+				continue;
+
+			RpAtomic* atomic = nil;
+			RwFrameForAllObjects(m_aCarNodes[frameID], GetCurrentAtomicObjectCB, &atomic);
+
+			if (!atomic)
+				continue;
+
+			if (CVisibilityPlugins::GetAtomicId(atomic) & ATOMIC_FLAG_DAM)
+				continue;
+
+			for (int i = 0; i < atomic->geometry->matList.numMaterials; i++) {
+				RpMaterial* material = atomic->geometry->matList.materials[i];
+
+				if (material->color.alpha == 255)
+					continue;
+
+				RwRGBA color = windowColor;
+				material->color = color;
+			}
+		}
+		if (m_aCarNodes[CAR_WINDSCREEN] && Damage.GetPanelStatus(VEHPANEL_WINDSCREEN) == PANEL_STATUS_OK) {
+			RpAtomic* windscreenAtomic = nil;
+			RwFrameForAllObjects(m_aCarNodes[CAR_WINDSCREEN], GetCurrentAtomicObjectCB, &windscreenAtomic);
+			if (windscreenAtomic) {
+				for (int i = 0; i < windscreenAtomic->geometry->matList.numMaterials; i++) {
+					RpMaterial* material = windscreenAtomic->geometry->matList.materials[i];
+
+					if (material->color.alpha == 255)
+						continue;
+
+					RwRGBA color = windowColor;
+					material->color = color;
+				}
+			}
+		}
+		if (m_aCarNodes[CAR_BOOT]) {
+			RpAtomic* windscreenAtomic = nil;
+			RwFrameForAllObjects(m_aCarNodes[CAR_BOOT], GetCurrentAtomicObjectCB, &windscreenAtomic);
+			if (windscreenAtomic) {
+				for (int i = 0; i < windscreenAtomic->geometry->matList.numMaterials; i++) {
+					RpMaterial* material = windscreenAtomic->geometry->matList.materials[i];
+
+					if (material->color.alpha == 255)
+						continue;
+
+					RwRGBA color = windowColor;
+					material->color = color;
+				}
+			}
+		}
+		// chassis windows
+		RwObjectNameAssociation assoc;
+		assoc.frame = nil;
+		assoc.name = "chassis_hi";
+		RwFrameForAllChildren(RpClumpGetFrame(GetClump()), CClumpModelInfo::FindFrameFromNameWithoutIdCB, &assoc);
+		if (assoc.frame != nil) {
+			RpAtomic* chassisAtomic = nil;
+			RwFrameForAllObjects(assoc.frame, GetCurrentAtomicObjectCB, &chassisAtomic);
+			if (chassisAtomic) {
+				for (int i = 0; i < chassisAtomic->geometry->matList.numMaterials; i++) {
+					RpMaterial* material = chassisAtomic->geometry->matList.materials[i];
+
+					if (material->color.alpha == 255)
+						continue;
+
+					RwRGBA color = windowColor;
+					material->color = color;
+				}
+			}
+		}
+	}
+#else
 	mi->SetVehicleColour(m_currentColour1, m_currentColour2);
+#endif
+
+#ifdef IMPROVED_VEHICLES_2 // change the color, ambient and material texture
+	// indicators
+	if (pDriver && !pDriver->DyingOrDead() && this != FindPlayerVehicle() && AutoPilot.m_nDrivingStyle < DRIVINGSTYLE_AVOID_CARS && !bRenderScorched) {
+		CVector2D vehicleRight = GetRight();
+		CVector2D nextPathLinkForward = AutoPilot.m_nNextDirection * ThePaths.m_carPathLinks[AutoPilot.m_nNextPathNodeInfo].GetDirection();
+		float angle = DotProduct2D(vehicleRight, nextPathLinkForward);
+		m_bIndicatorState[INDICATORS_LEFT] = angle < -0.5f;
+		m_bIndicatorState[INDICATORS_RIGHT] = angle > 0.5f;
+	} else if (pDriver && pDriver != FindPlayerPed() && AutoPilot.m_nDrivingStyle >= DRIVINGSTYLE_AVOID_CARS || bRenderScorched) {
+		m_bIndicatorState[INDICATORS_LEFT] = false;
+		m_bIndicatorState[INDICATORS_RIGHT] = false;
+	} else if (this == FindPlayerVehicle()) {
+		CPad* pad = CPad::GetPad(0);
+
+		if (pad->LeftTurnSignalsJustDown()) {
+			m_bIndicatorState[INDICATORS_LEFT] = !m_bIndicatorState[INDICATORS_LEFT];
+			if (m_bIndicatorState[INDICATORS_LEFT]) m_bIndicatorState[INDICATORS_RIGHT] = false;
+		}
+		
+		if (pad->RightTurnSignalsJustDown()) {
+			m_bIndicatorState[INDICATORS_RIGHT] = !m_bIndicatorState[INDICATORS_RIGHT];
+			if (m_bIndicatorState[INDICATORS_RIGHT]) m_bIndicatorState[INDICATORS_LEFT] = false;
+		}
+
+		if (pad->EmergencyLightsJustDown()) {
+			if (m_bIndicatorState[INDICATORS_LEFT] == m_bIndicatorState[INDICATORS_RIGHT]) {
+				m_bIndicatorState[INDICATORS_LEFT] = !m_bIndicatorState[INDICATORS_LEFT];
+				m_bIndicatorState[INDICATORS_RIGHT] = !m_bIndicatorState[INDICATORS_RIGHT];
+			} else {
+				m_bIndicatorState[INDICATORS_LEFT] = true;
+				m_bIndicatorState[INDICATORS_RIGHT] = true;
+			}
+		}
+	}
+
+	bool bLightsBroken = false;
+	float ambientOff = 1.0f;
+	float ambientOn = 10.0f;
+
+	// headlights
+	if (m_aCarNodes[CAR_HEADLIGHT_L]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_HEADLIGHT_L], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			if (!m_aCarNodes[CAR_INDICATOR_LF] && !m_aCarNodes[CAR_INDICATOR_2_LF] && m_bIndicatorState[INDICATORS_LEFT] == true) {
+				material->surfaceProps.ambient = CTimer::GetTimeInMilliseconds() & 512 ? ambientOn : ambientOff;
+				material = CTimer::GetTimeInMilliseconds() & 512 ? RpMaterialSetTexture(material, mi->lightsOnTexture) : RpMaterialSetTexture(material, mi->lightsOffTexture);
+			} else {
+				material->surfaceProps.ambient = bLightsOn ? ambientOn : ambientOff;
+				material = bLightsOn ? RpMaterialSetTexture(material, mi->lightsOnTexture) : RpMaterialSetTexture(material, mi->lightsOffTexture);
+			}
+		}
+	}
+	if (m_aCarNodes[CAR_HEADLIGHT_R]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_HEADLIGHT_R], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			if (!m_aCarNodes[CAR_INDICATOR_RF] && !m_aCarNodes[CAR_INDICATOR_2_RF] && m_bIndicatorState[INDICATORS_RIGHT] == true) {
+				material->surfaceProps.ambient = CTimer::GetTimeInMilliseconds() & 512 ? ambientOn : ambientOff;
+				material = CTimer::GetTimeInMilliseconds() & 512 ? RpMaterialSetTexture(material, mi->lightsOnTexture) : RpMaterialSetTexture(material, mi->lightsOffTexture);
+			} else {
+				material->surfaceProps.ambient = bLightsOn ? ambientOn : ambientOff;
+				material = bLightsOn ? RpMaterialSetTexture(material, mi->lightsOnTexture) : RpMaterialSetTexture(material, mi->lightsOffTexture);
+			}
+		}
+	}
+
+	// taillights
+	if (m_aCarNodes[CAR_TAILLIGHT_L]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_TAILLIGHT_L], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			if (!m_aCarNodes[CAR_INDICATOR_LR] && m_bIndicatorState[INDICATORS_LEFT] == true) {
+				material->surfaceProps.ambient = CTimer::GetTimeInMilliseconds() & 512 ? ambientOn : ambientOff;
+				material = CTimer::GetTimeInMilliseconds() & 512 ? RpMaterialSetTexture(material, mi->lightsOnTexture) : RpMaterialSetTexture(material, mi->lightsOffTexture);
+			} else {
+				material->surfaceProps.ambient = bLightsOn ? ambientOn : ambientOff;
+				material = bLightsOn ? RpMaterialSetTexture(material, mi->lightsOnTexture) : RpMaterialSetTexture(material, mi->lightsOffTexture);
+			}
+		}
+	}
+	if (m_aCarNodes[CAR_TAILLIGHT_R]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_TAILLIGHT_R], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			if (!m_aCarNodes[CAR_INDICATOR_RR] && m_bIndicatorState[INDICATORS_RIGHT] == true) {
+				material->surfaceProps.ambient = CTimer::GetTimeInMilliseconds() & 512 ? ambientOn : ambientOff;
+				material = CTimer::GetTimeInMilliseconds() & 512 ? RpMaterialSetTexture(material, mi->lightsOnTexture) : RpMaterialSetTexture(material, mi->lightsOffTexture);
+			} else {
+				material->surfaceProps.ambient = bLightsOn ? ambientOn : ambientOff;
+				material = bLightsOn ? RpMaterialSetTexture(material, mi->lightsOnTexture) : RpMaterialSetTexture(material, mi->lightsOffTexture);
+			}
+		}
+	}
+	
+	// reversing lights
+	if (m_aCarNodes[CAR_REVERSINGLIGHT_L]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_REVERSINGLIGHT_L], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			bool bLightOn = m_fGasPedal < 0.0f && !bRenderScorched;
+
+			material->surfaceProps.ambient = bLightOn ? ambientOn : ambientOff;
+			material = bLightOn ? RpMaterialSetTexture(material, mi->lightsOnTexture) : RpMaterialSetTexture(material, mi->lightsOffTexture);
+		}
+	}
+	if (m_aCarNodes[CAR_REVERSINGLIGHT_R]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_REVERSINGLIGHT_R], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			bool bLightOn = m_fGasPedal < 0.0f && !bRenderScorched;
+
+			material->surfaceProps.ambient = bLightOn ? ambientOn : ambientOff;
+			material = bLightOn ? RpMaterialSetTexture(material, mi->lightsOnTexture) : RpMaterialSetTexture(material, mi->lightsOffTexture);
+		}
+	}
+
+	// brake lights
+	if (m_aCarNodes[CAR_BRAKELIGHT_L]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_BRAKELIGHT_L], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			bool bLightOn = GetStatus() != STATUS_ABANDONED && m_fBrakePedal > 0.0f && !bRenderScorched;
+
+			material->surfaceProps.ambient = bLightOn ? ambientOn : ambientOff;
+			material = bLightOn ? RpMaterialSetTexture(material, mi->lightsOnTexture) : RpMaterialSetTexture(material, mi->lightsOffTexture);
+		}
+	}
+	if (m_aCarNodes[CAR_BRAKELIGHT_R]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_BRAKELIGHT_R], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			bool bLightOn = GetStatus() != STATUS_ABANDONED && m_fBrakePedal > 0.0f && !bRenderScorched;
+
+			material->surfaceProps.ambient = bLightOn ? ambientOn : ambientOff;
+			material = bLightOn ? RpMaterialSetTexture(material, mi->lightsOnTexture) : RpMaterialSetTexture(material, mi->lightsOffTexture);
+		}
+	}
+
+	CRGBA indicatorOffColor = CRGBA(150, 125, 0, 255);
+	CRGBA indicatorOnColor = CRGBA(255, 225, 0, 255);
+	
+	// forward indicators
+	if (m_aCarNodes[CAR_INDICATOR_LF]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_INDICATOR_LF], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			bool bindicatorOn = m_bIndicatorState[INDICATORS_LEFT] == true && CTimer::GetTimeInMilliseconds() & 512;
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			material->surfaceProps.ambient = bindicatorOn ? ambientOn : ambientOff;
+			RwRGBA color = bindicatorOn ? indicatorOnColor : indicatorOffColor;
+			material->color = color;
+		}
+	}
+	if (m_aCarNodes[CAR_INDICATOR_RF]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_INDICATOR_RF], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			bool bindicatorOn = m_bIndicatorState[INDICATORS_RIGHT] == true && CTimer::GetTimeInMilliseconds() & 512;
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			material->surfaceProps.ambient = bindicatorOn ? ambientOn : ambientOff;
+			RwRGBA color = bindicatorOn ? indicatorOnColor : indicatorOffColor;
+			material->color = color;
+		}
+	}
+	if (m_aCarNodes[CAR_INDICATOR_2_LF]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_INDICATOR_2_LF], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			bool bindicatorOn = m_bIndicatorState[INDICATORS_LEFT] == true && CTimer::GetTimeInMilliseconds() & 512;
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			material->surfaceProps.ambient = bindicatorOn ? ambientOn : ambientOff;
+			RwRGBA color = bindicatorOn ? indicatorOnColor : indicatorOffColor;
+			material->color = color;
+		}
+	}
+	if (m_aCarNodes[CAR_INDICATOR_2_RF]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_INDICATOR_2_RF], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			bool bindicatorOn = m_bIndicatorState[INDICATORS_RIGHT] == true && CTimer::GetTimeInMilliseconds() & 512;
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			material->surfaceProps.ambient = bindicatorOn ? ambientOn : ambientOff;
+			RwRGBA color = bindicatorOn ? indicatorOnColor : indicatorOffColor;
+			material->color = color;
+		}
+	}
+
+	// rear indicators
+	if (m_aCarNodes[CAR_INDICATOR_LR]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_INDICATOR_LR], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			bool bindicatorOn = m_bIndicatorState[INDICATORS_LEFT] == true && CTimer::GetTimeInMilliseconds() & 512;
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			material->surfaceProps.ambient = bindicatorOn ? ambientOn : ambientOff;
+			RwRGBA color = bindicatorOn ? indicatorOnColor : indicatorOffColor;
+			material->color = color;
+		}
+	}
+	if (m_aCarNodes[CAR_INDICATOR_RR]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_INDICATOR_RR], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			bool bindicatorOn = m_bIndicatorState[INDICATORS_RIGHT] == true && CTimer::GetTimeInMilliseconds() & 512;
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			material->surfaceProps.ambient = bindicatorOn ? ambientOn : ambientOff;
+			RwRGBA color = bindicatorOn ? indicatorOnColor : indicatorOffColor;
+			material->color = color;
+		}
+	}
+	if (m_aCarNodes[CAR_INDICATOR_2_LR]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_INDICATOR_2_LR], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			bool bindicatorOn = m_bIndicatorState[INDICATORS_LEFT] == true && CTimer::GetTimeInMilliseconds() & 512;
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			material->surfaceProps.ambient = bindicatorOn ? ambientOn : ambientOff;
+			RwRGBA color = bindicatorOn ? indicatorOnColor : indicatorOffColor;
+			material->color = color;
+		}
+	}
+	if (m_aCarNodes[CAR_INDICATOR_2_RR]) {
+		RpAtomic* lightAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_INDICATOR_2_RR], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			bool bindicatorOn = m_bIndicatorState[INDICATORS_RIGHT] == true && CTimer::GetTimeInMilliseconds() & 512;
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			material->surfaceProps.ambient = bindicatorOn ? ambientOn : ambientOff;
+			RwRGBA color = bindicatorOn ? indicatorOnColor : indicatorOffColor;
+			material->color = color;
+		}
+	}
+
+	// windows alpha
+	CRGBA windowColor;
+
+	int tintLevel = CGarages::bPlayerInModGarage ? m_nTempWindowTintLevel : m_nWindowTintLevel;
+	switch (tintLevel) {
+		case 2:
+			windowColor = CRGBA(0, 0, 0, 150);
+			break;
+		case 3:
+			windowColor = CRGBA(0, 0, 0, 187);
+			break;
+		case 4:
+			windowColor = CRGBA(0, 0, 0, 225);
+			break;
+		default:
+			windowColor = mi->m_nDefaultWindowMaterialColor;
+			break;
+	}
+	
+	if (m_aCarNodes[CAR_DOOR_LF]) {
+		RpAtomic* windowAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_DOOR_LF], GetWindowAtomicObjectCB, &windowAtomic);
+		if (windowAtomic) {
+			RpMaterial* material = windowAtomic->geometry->matList.materials[0];
+
+			RwRGBA color = windowColor;
+			material->color = color;
+		}
+	}
+	if (m_aCarNodes[CAR_DOOR_RF]) {
+		RpAtomic* windowAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_DOOR_RF], GetWindowAtomicObjectCB, &windowAtomic);
+		if (windowAtomic) {
+			RpMaterial* material = windowAtomic->geometry->matList.materials[0];
+
+			RwRGBA color = windowColor;
+			material->color = color;
+		}
+	}
+	if (m_aCarNodes[CAR_DOOR_LR]) {
+		RpAtomic* windowAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_DOOR_LR], GetWindowAtomicObjectCB, &windowAtomic);
+		if (windowAtomic) {
+			RpMaterial* material = windowAtomic->geometry->matList.materials[0];
+
+			RwRGBA color = windowColor;
+			material->color = color;
+		}
+	}
+	if (m_aCarNodes[CAR_DOOR_RR]) {
+		RpAtomic* windowAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_DOOR_RR], GetWindowAtomicObjectCB, &windowAtomic);
+		if (windowAtomic) {
+			RpMaterial* material = windowAtomic->geometry->matList.materials[0];
+
+			RwRGBA color = windowColor;
+			material->color = color;
+		}
+	}
+	if (m_aCarNodes[CAR_BOOT]) {
+		RpAtomic* windowAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_BOOT], GetWindowAtomicObjectCB, &windowAtomic);
+		if (windowAtomic) {
+			RpMaterial* material = windowAtomic->geometry->matList.materials[0];
+
+			RwRGBA color = windowColor;
+			material->color = color;
+		}
+	}
+	if (m_aCarNodes[CAR_WINDOW_REAR]) {
+		RpAtomic* windowAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_WINDOW_REAR], GetCurrentAtomicObjectCB, &windowAtomic);
+		if (windowAtomic) {
+			RpMaterial* material = windowAtomic->geometry->matList.materials[0];
+
+			RwRGBA color = windowColor;
+			material->color = color;
+		}
+	}
+	if (m_aCarNodes[CAR_WINDOW_L_MISC]) {
+		RpAtomic* windowAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_WINDOW_L_MISC], GetCurrentAtomicObjectCB, &windowAtomic);
+		if (windowAtomic) {
+			RpMaterial* material = windowAtomic->geometry->matList.materials[0];
+
+			RwRGBA color = windowColor;
+			material->color = color;
+		}
+	}
+	if (m_aCarNodes[CAR_WINDOW_R_MISC]) {
+		RpAtomic* windowAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_WINDOW_R_MISC], GetCurrentAtomicObjectCB, &windowAtomic);
+		if (windowAtomic) {
+			RpMaterial* material = windowAtomic->geometry->matList.materials[0];
+
+			RwRGBA color = windowColor;
+			material->color = color;
+		}
+	}
+#endif
+
+#ifdef IMPROVED_VEHICLES // Service lights for service cars and cleareance lights
+	if (UsesSiren()) {
+		int curObjectForServiceLights = 0;
+
+		for (int i = 0; i < 4; i++) {
+			if (m_aCarNodes[CAR_SERVICELIGHTS_0 + curObjectForServiceLights]) {
+				RpAtomic* atomic = nil;
+				RwFrameForAllObjects(m_aCarNodes[CAR_SERVICELIGHTS_0 + curObjectForServiceLights], GetCurrentAtomicObjectCB, &atomic);
+				if (atomic) {
+					for (int i = 0; i < atomic->geometry->matList.numMaterials; i++) {
+						RpMaterial* material = atomic->geometry->matList.materials[i];
+
+						if (!material)
+							continue;
+
+						int ambientOn = 3.0f;
+
+						if (m_bSirenOrAlarm) {
+							if (i == 0) {
+								RwTexture* currentTexture = CTimer::GetTimeInMilliseconds() & 512 ? mi->serviceLightsOnTexture : mi->serviceLightsOffTexture;
+								material = RpMaterialSetTexture(material, currentTexture);
+								material->surfaceProps.ambient = CTimer::GetTimeInMilliseconds() & 512 ? ambientOn : 1.0f;
+							} else if (i == 1) {
+								RwTexture* currentTexture = CTimer::GetTimeInMilliseconds() & 512 ? mi->serviceLightsOffTexture : mi->serviceLightsOnTexture;
+								material = RpMaterialSetTexture(material, currentTexture);
+								material->surfaceProps.ambient = CTimer::GetTimeInMilliseconds() & 512 ? 1.0f : ambientOn;
+							} else if (i == 2) {
+								RwTexture* currentTexture = CTimer::GetTimeInMilliseconds() & 256 ? mi->serviceLightsOnTexture : mi->serviceLightsOffTexture;
+								material = RpMaterialSetTexture(material, currentTexture);
+								material->surfaceProps.ambient = CTimer::GetTimeInMilliseconds() & 256 ? ambientOn : 1.0f;
+							} else if (i == 3) {
+								RwTexture* currentTexture = CTimer::GetTimeInMilliseconds() & 256 ? mi->serviceLightsOffTexture : mi->serviceLightsOnTexture;
+								material = RpMaterialSetTexture(material, currentTexture);
+								material->surfaceProps.ambient = CTimer::GetTimeInMilliseconds() & 256 ? 1.0f : ambientOn;
+							}
+						} else {
+							material = RpMaterialSetTexture(material, mi->serviceLightsOffTexture);
+							material->surfaceProps.ambient = 1.0f;
+						}
+					}
+				}
+			}
+
+			curObjectForServiceLights++;
+		}
+	}
+
+	if (m_aCarNodes[CAR_CLEARANCE_LIGHTS]) {
+		RpAtomic* atomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_CLEARANCE_LIGHTS], GetCurrentAtomicObjectCB, &atomic);
+		if (atomic) {
+			for (int i = 0; i < atomic->geometry->matList.numMaterials; i++) {
+				RpMaterial* material = atomic->geometry->matList.materials[i];
+				material->surfaceProps.ambient = bEngineOn ? 3.0f : 1.0f;
+			}
+		}
+	}
+#endif
 
 	if(IsRealHeli()){
 		RpAtomic *atomic = nil;
@@ -4314,12 +5236,75 @@ CAutomobile::VehicleDamage(float impulse, uint16 damagedPiece)
 		if(GetUp().z > 0.0f || m_vecMoveSpeed.MagnitudeSqr() > 0.1f){
 			float impulseMult = bMoreResistantToDamage ? 0.5f : 4.0f;
 
+#ifdef IMPROVED_VEHICLES // the wheels fall off when you hit it hard
+			if (impulse * pHandling->fCollisionDamageMultiplier > 900.0f ||
+				m_pDamageEntity && m_pDamageEntity->IsVehicle() && (((CVehicle*)m_pDamageEntity)->m_fDamageImpulse + impulse) * pHandling->fCollisionDamageMultiplier > 1000.0f) {
+
+				switch (damagedPiece) {
+					case CAR_PIECE_BUMP_FRONT: {
+						CVector2D leftWheelPos2D = CVector2D(m_aWheelColPoints[0].point.x, m_aWheelColPoints[0].point.y);
+						CVector2D rightWheelPos2D = CVector2D(m_aWheelColPoints[2].point.x, m_aWheelColPoints[2].point.y);
+						CVector2D impulsePos2D = CVector2D(GetPosition().x + m_vecDamageNormal.x, GetPosition().y + m_vecDamageNormal.y);
+						if (DistanceSqr2D(impulsePos2D, leftWheelPos2D.x, leftWheelPos2D.y) < DistanceSqr2D(impulsePos2D, rightWheelPos2D.x, rightWheelPos2D.y))
+							SetWheelMissing(CARWHEEL_FRONT_RIGHT);
+						else
+							SetWheelMissing(CARWHEEL_FRONT_LEFT);
+						break;
+					}
+					case CAR_PIECE_WING_LF:
+						SetWheelMissing(CARWHEEL_FRONT_LEFT);
+						break;
+					case CAR_PIECE_WING_RF:
+						SetWheelMissing(CARWHEEL_FRONT_LEFT);
+						break;
+					case CAR_PIECE_BUMP_REAR: {
+						CVector2D leftWheelPos2D = CVector2D(m_aWheelColPoints[1].point.x, m_aWheelColPoints[1].point.y);
+						CVector2D rightWheelPos2D = CVector2D(m_aWheelColPoints[3].point.x, m_aWheelColPoints[3].point.y);
+						CVector2D impulsePos2D = CVector2D(GetPosition().x + m_vecDamageNormal.x, GetPosition().y + m_vecDamageNormal.y);
+						if (DistanceSqr2D(impulsePos2D, leftWheelPos2D.x, leftWheelPos2D.y) > DistanceSqr2D(impulsePos2D, rightWheelPos2D.x, rightWheelPos2D.y))
+							SetWheelMissing(CARWHEEL_REAR_RIGHT);
+						else
+							SetWheelMissing(CARWHEEL_REAR_LEFT);
+						break;
+					}
+				}
+			}
+#endif
+
+#ifdef IMPROVED_VEHICLES_2 // remove lights
+			float maxImpulse = 600.0f;
+			float comparedValue = maxImpulse - impulse;
+#endif
+
 			switch(damagedPiece){
 			case CAR_PIECE_BUMP_FRONT:
 				GetComponentWorldPosition(CAR_BUMP_FRONT, pos);
 				dmgDrawCarCollidingParticles(pos, impulse*damageMultiplier);
-				if(Damage.ApplyDamage(COMPONENT_BUMPER_FRONT, impulse*impulseMult, pHandling->fCollisionDamageMultiplier))
+
+#ifdef IMPROVED_VEHICLES_2 // remove lights when front bumper is damaged
+				if (Damage.ApplyDamage(COMPONENT_BUMPER_FRONT, impulse * impulseMult, pHandling->fCollisionDamageMultiplier)) {
+					SetBumperDamage(CAR_BUMP_FRONT, VEHBUMPER_FRONT);
+
+					CVehicleModelInfo* modelInfo = GetModelInfo();
+					if (modelInfo->newLightsData.bBumperHeadlights) {
+						SetFrameLightStatus(CAR_HEADLIGHT_L, LIGHT_STATUS_BROKEN);
+						SetFrameLightStatus(CAR_HEADLIGHT_R, LIGHT_STATUS_BROKEN);
+					}
+					if (modelInfo->newLightsData.bBumperForwardIndicators1) {
+						SetFrameLightStatus(CAR_INDICATOR_LF, LIGHT_STATUS_BROKEN);
+						SetFrameLightStatus(CAR_INDICATOR_RF, LIGHT_STATUS_BROKEN);
+					}
+					if (modelInfo->newLightsData.bBumperForwardIndicators2) {
+						SetFrameLightStatus(CAR_INDICATOR_2_LF, LIGHT_STATUS_BROKEN);
+						SetFrameLightStatus(CAR_INDICATOR_2_RF, LIGHT_STATUS_BROKEN);
+					}
+				}
+#else
+				if (Damage.ApplyDamage(COMPONENT_BUMPER_FRONT, impulse * impulseMult, pHandling->fCollisionDamageMultiplier))
 					SetBumperDamage(CAR_BUMP_FRONT, VEHBUMPER_FRONT);
+#endif
+
+
 				if(m_aCarNodes[CAR_BONNET] && Damage.GetPanelStatus(VEHBUMPER_FRONT) == PANEL_STATUS_MISSING){
 			case CAR_PIECE_BONNET:
 					GetComponentWorldPosition(CAR_BONNET, pos);
@@ -4328,21 +5313,81 @@ CAutomobile::VehicleDamage(float impulse, uint16 damagedPiece)
 					if(Damage.ApplyDamage(COMPONENT_DOOR_BONNET, impulse*impulseMult, pHandling->fCollisionDamageMultiplier))
 						SetDoorDamage(CAR_BONNET, DOOR_BONNET);
 				}
-				break;
 
-			case CAR_PIECE_BUMP_REAR:
-				GetComponentWorldPosition(CAR_BUMP_REAR, pos);
-				dmgDrawCarCollidingParticles(pos, impulse*damageMultiplier);
-				if(Damage.ApplyDamage(COMPONENT_BUMPER_REAR, impulse*impulseMult, pHandling->fCollisionDamageMultiplier))
-					SetBumperDamage(CAR_BUMP_REAR, VEHBUMPER_REAR);
-				if(m_aCarNodes[CAR_BOOT] && Damage.GetPanelStatus(VEHBUMPER_REAR) == PANEL_STATUS_MISSING){
-			case CAR_PIECE_BOOT:
+#ifdef IMPROVED_VEHICLES_2 // remove lights
+				if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_HEADLIGHT_L, LIGHT_STATUS_BROKEN);
+				if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_HEADLIGHT_R, LIGHT_STATUS_BROKEN);
+				if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_INDICATOR_LF, LIGHT_STATUS_BROKEN);
+				if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_INDICATOR_RF, LIGHT_STATUS_BROKEN);
+				if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_INDICATOR_2_LF, LIGHT_STATUS_BROKEN);
+				if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_INDICATOR_2_RF, LIGHT_STATUS_BROKEN);
+#endif
+
+				break;
+
+#ifdef IMPROVED_VEHICLES_2 // remove lights
+				case CAR_PIECE_BUMP_REAR:
+					GetComponentWorldPosition(CAR_BUMP_REAR, pos);
+					dmgDrawCarCollidingParticles(pos, impulse * damageMultiplier);
+					if (Damage.ApplyDamage(COMPONENT_BUMPER_REAR, impulse * impulseMult, pHandling->fCollisionDamageMultiplier)) {
+						SetBumperDamage(CAR_BUMP_REAR, VEHBUMPER_REAR);
+	
+						CVehicleModelInfo* modelInfo = GetModelInfo();
+						if (modelInfo->newLightsData.bBumperTaillights) {
+							SetFrameLightStatus(CAR_TAILLIGHT_L, LIGHT_STATUS_BROKEN);
+							SetFrameLightStatus(CAR_TAILLIGHT_R, LIGHT_STATUS_BROKEN);
+						}
+						if (modelInfo->newLightsData.bBumperRearIndicators1) {
+							SetFrameLightStatus(CAR_INDICATOR_LR, LIGHT_STATUS_BROKEN);
+							SetFrameLightStatus(CAR_INDICATOR_RR, LIGHT_STATUS_BROKEN);
+						}
+						if (modelInfo->newLightsData.bBumperRearIndicators2) {
+							SetFrameLightStatus(CAR_INDICATOR_2_LR, LIGHT_STATUS_BROKEN);
+							SetFrameLightStatus(CAR_INDICATOR_2_RR, LIGHT_STATUS_BROKEN);
+						}
+						if (modelInfo->newLightsData.bBumperBrakelights) {
+							SetFrameLightStatus(CAR_BRAKELIGHT_L, LIGHT_STATUS_BROKEN);
+							SetFrameLightStatus(CAR_BRAKELIGHT_R, LIGHT_STATUS_BROKEN);
+						}
+						if (modelInfo->newLightsData.bBumperReversinglights) {
+							SetFrameLightStatus(CAR_REVERSINGLIGHT_L, LIGHT_STATUS_BROKEN);
+							SetFrameLightStatus(CAR_REVERSINGLIGHT_R, LIGHT_STATUS_BROKEN);
+						}
+					}
+					if (m_aCarNodes[CAR_BOOT] && Damage.GetPanelStatus(VEHBUMPER_REAR) == PANEL_STATUS_MISSING) {
+				case CAR_PIECE_BOOT:
 					GetComponentWorldPosition(CAR_BOOT, pos);
-					dmgDrawCarCollidingParticles(pos, impulse*damageMultiplier);
-					if(Damage.ApplyDamage(COMPONENT_DOOR_BOOT, impulse*impulseMult, pHandling->fCollisionDamageMultiplier))
+					dmgDrawCarCollidingParticles(pos, impulse * damageMultiplier);
+					if (Damage.ApplyDamage(COMPONENT_DOOR_BOOT, impulse * impulseMult, pHandling->fCollisionDamageMultiplier))
 						SetDoorDamage(CAR_BOOT, DOOR_BOOT);
-				}
-				break;
+					}
+					
+					if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_TAILLIGHT_L, LIGHT_STATUS_BROKEN);
+					if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_TAILLIGHT_R, LIGHT_STATUS_BROKEN);
+					if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_BRAKELIGHT_L, LIGHT_STATUS_BROKEN);
+					if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_BRAKELIGHT_R, LIGHT_STATUS_BROKEN);
+					if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_REVERSINGLIGHT_L, LIGHT_STATUS_BROKEN);
+					if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_REVERSINGLIGHT_R, LIGHT_STATUS_BROKEN);
+					if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_INDICATOR_LR, LIGHT_STATUS_BROKEN);
+					if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_INDICATOR_RR, LIGHT_STATUS_BROKEN);
+					if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_INDICATOR_2_LR, LIGHT_STATUS_BROKEN);
+					if (CGeneral::GetRandomNumberInRange(0.0f, maxImpulse) > comparedValue) SetFrameLightStatus(CAR_INDICATOR_2_RR, LIGHT_STATUS_BROKEN);
+					break;
+#else
+				case CAR_PIECE_BUMP_REAR:
+					GetComponentWorldPosition(CAR_BUMP_REAR, pos);
+					dmgDrawCarCollidingParticles(pos, impulse*damageMultiplier);
+					if(Damage.ApplyDamage(COMPONENT_BUMPER_REAR, impulse*impulseMult, pHandling->fCollisionDamageMultiplier))
+						SetBumperDamage(CAR_BUMP_REAR, VEHBUMPER_REAR);
+					if(m_aCarNodes[CAR_BOOT] && Damage.GetPanelStatus(VEHBUMPER_REAR) == PANEL_STATUS_MISSING){
+				case CAR_PIECE_BOOT:
+						GetComponentWorldPosition(CAR_BOOT, pos);
+						dmgDrawCarCollidingParticles(pos, impulse*damageMultiplier);
+						if(Damage.ApplyDamage(COMPONENT_DOOR_BOOT, impulse*impulseMult, pHandling->fCollisionDamageMultiplier))
+							SetDoorDamage(CAR_BOOT, DOOR_BOOT);
+					}
+					break;
+#endif
 
 			case CAR_PIECE_DOOR_LF:
 				GetComponentWorldPosition(CAR_DOOR_LF, pos);
@@ -4369,18 +5414,55 @@ CAutomobile::VehicleDamage(float impulse, uint16 damagedPiece)
 					SetDoorDamage(CAR_DOOR_RR, DOOR_REAR_RIGHT);
 				break;
 
-			case CAR_PIECE_WING_LF:
-				GetComponentWorldPosition(CAR_WING_LF, pos);
-				dmgDrawCarCollidingParticles(pos, impulse*damageMultiplier);
-				if(Damage.ApplyDamage(COMPONENT_PANEL_FRONT_LEFT, impulse*impulseMult, pHandling->fCollisionDamageMultiplier))
-					SetPanelDamage(CAR_WING_LF, VEHPANEL_FRONT_LEFT);
-				break;
-			case CAR_PIECE_WING_RF:
-				GetComponentWorldPosition(CAR_WING_RF, pos);
-				dmgDrawCarCollidingParticles(pos, impulse*damageMultiplier);
-				if(Damage.ApplyDamage(COMPONENT_PANEL_FRONT_RIGHT, impulse*impulseMult, pHandling->fCollisionDamageMultiplier))
-					SetPanelDamage(CAR_WING_RF, VEHPANEL_FRONT_RIGHT);
-				break;
+
+#ifdef IMPROVED_VEHICLES_2 // remove lights when wing is damaged
+				case CAR_PIECE_WING_LF:
+					GetComponentWorldPosition(CAR_WING_LF, pos);
+					dmgDrawCarCollidingParticles(pos, impulse * damageMultiplier);
+					if (Damage.ApplyDamage(COMPONENT_PANEL_FRONT_LEFT, impulse * impulseMult, pHandling->fCollisionDamageMultiplier)) {
+						SetPanelDamage(CAR_WING_LF, VEHPANEL_FRONT_LEFT);
+	
+						CVehicleModelInfo* modelInfo = GetModelInfo();
+						if (modelInfo->newLightsData.bWingHeadlights)
+							SetFrameLightStatus(CAR_HEADLIGHT_L, LIGHT_STATUS_BROKEN);
+						if (modelInfo->newLightsData.bWingIndicators1)
+							SetFrameLightStatus(CAR_INDICATOR_LF, LIGHT_STATUS_BROKEN);
+						if (modelInfo->newLightsData.bWingIndicators2)
+							SetFrameLightStatus(CAR_INDICATOR_2_LF, LIGHT_STATUS_BROKEN);
+					}
+					break;
+				case CAR_PIECE_WING_RF:
+					GetComponentWorldPosition(CAR_WING_RF, pos);
+					dmgDrawCarCollidingParticles(pos, impulse * damageMultiplier);
+					if (Damage.ApplyDamage(COMPONENT_PANEL_FRONT_RIGHT, impulse * impulseMult, pHandling->fCollisionDamageMultiplier)) {
+						SetPanelDamage(CAR_WING_RF, VEHPANEL_FRONT_RIGHT);
+	
+						CVehicleModelInfo* modelInfo = GetModelInfo();
+						if (modelInfo->newLightsData.bWingHeadlights)
+							SetFrameLightStatus(CAR_HEADLIGHT_R, LIGHT_STATUS_BROKEN);
+						if (modelInfo->newLightsData.bWingIndicators1)
+							SetFrameLightStatus(CAR_INDICATOR_RF, LIGHT_STATUS_BROKEN);
+						if (modelInfo->newLightsData.bWingIndicators2)
+							SetFrameLightStatus(CAR_INDICATOR_2_RF, LIGHT_STATUS_BROKEN);
+					}
+					break;
+#else
+				case CAR_PIECE_WING_LF:
+					GetComponentWorldPosition(CAR_WING_LF, pos);
+					dmgDrawCarCollidingParticles(pos, impulse*damageMultiplier);
+					if(Damage.ApplyDamage(COMPONENT_PANEL_FRONT_LEFT, impulse*impulseMult, pHandling->fCollisionDamageMultiplier))
+						SetPanelDamage(CAR_WING_LF, VEHPANEL_FRONT_LEFT);
+					break;
+				case CAR_PIECE_WING_RF:
+					GetComponentWorldPosition(CAR_WING_RF, pos);
+					dmgDrawCarCollidingParticles(pos, impulse*damageMultiplier);
+					if(Damage.ApplyDamage(COMPONENT_PANEL_FRONT_RIGHT, impulse*impulseMult, pHandling->fCollisionDamageMultiplier))
+						SetPanelDamage(CAR_WING_RF, VEHPANEL_FRONT_RIGHT);
+					break;
+#endif
+
+
+
 			case CAR_PIECE_WING_LR:
 				GetComponentWorldPosition(CAR_WING_LR, pos);
 				dmgDrawCarCollidingParticles(pos, impulse*damageMultiplier);
@@ -4414,6 +5496,27 @@ CAutomobile::VehicleDamage(float impulse, uint16 damagedPiece)
 
 		float damage = (impulse-minImpulse)*pHandling->fCollisionDamageMultiplier*0.6f*damageMultiplier;
 
+
+#ifdef VEHICLE_MODS // armor
+		float absorbedDamage = 1.0f;
+		switch (m_nArmorLevel)
+		{
+		case 1:
+			absorbedDamage = 1.25f;
+			break;
+		case 2:
+			absorbedDamage = 1.5f;
+			break;
+		case 3:
+			absorbedDamage = 1.75f;
+			break;
+		case 4:
+			absorbedDamage = 2.0f;
+			break;
+		}
+		damage /= absorbedDamage;
+#endif
+
 		if(GetModelIndex() == MI_SECURICA && m_pDamageEntity && m_pDamageEntity->GetStatus() == STATUS_PLAYER)
 			damage *= 7.0f;
 
@@ -4525,6 +5628,107 @@ float fSpeedMult[] = {
 void
 CAutomobile::AddDamagedVehicleParticles(void)
 {
+#ifdef IMPROVED_VEHICLES_2 // change engine fire position
+	if (m_fHealth < 250.0f && GetStatus() != STATUS_WRECKED) {
+		// Car is on fire
+		CVector enginePos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->m_positions[CAR_POS_ENGINE];
+		CVector overheatPos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->m_positions[CAR_POS_OVERHEAT];
+		CVector overheat2Pos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->m_positions[CAR_POS_OVERHEAT_2];
+
+		if (enginePos.IsZero() && overheatPos.IsZero() && overheat2Pos.IsZero()) {
+			// Process car on fire
+			// A similar calculation of damagePos is done elsewhere for smoke
+
+			CVector damagePos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->m_positions[CAR_POS_HEADLIGHTS];
+
+			switch (Damage.GetDoorStatus(DOOR_BONNET)) {
+			case DOOR_STATUS_OK:
+			case DOOR_STATUS_SMASHED:
+				// Bonnet is still there, smoke comes out at the edge
+				damagePos += vecDAMAGE_ENGINE_POS_SMALL;
+				break;
+			case DOOR_STATUS_SWINGING:
+			case DOOR_STATUS_MISSING:
+				// Bonnet is gone, smoke comes out at the engine
+				damagePos += vecDAMAGE_ENGINE_POS_BIG;
+				break;
+			}
+
+			// move fire forward if in first person
+			if (this == FindPlayerVehicle() && TheCamera.GetLookingForwardFirstPerson())
+				if (m_fHealth < 250.0f && GetStatus() != STATUS_WRECKED) {
+					if (GetModelIndex() == MI_FIRETRUCK)
+						damagePos += CVector(0.0f, 3.0f, -0.2f);
+					else
+						damagePos += CVector(0.0f, 1.2f, -0.8f);
+				}
+
+			damagePos = GetMatrix() * damagePos;
+			damagePos.z += 0.15f;
+
+			// Car is on fire
+
+			CParticle::AddParticle(PARTICLE_CARFLAME, damagePos,
+				CVector(0.0f, 0.0f, CGeneral::GetRandomNumberInRange(0.01125f, 0.09f)),
+				nil, 0.63f);
+
+			CVector coors = damagePos;
+			coors.x += CGeneral::GetRandomNumberInRange(-0.5625f, 0.5625f),
+				coors.y += CGeneral::GetRandomNumberInRange(-0.5625f, 0.5625f),
+				coors.z += CGeneral::GetRandomNumberInRange(0.5625f, 2.25f);
+			CParticle::AddParticle(PARTICLE_CARFLAME_SMOKE, coors, CVector(0.0f, 0.0f, 0.0f));
+
+			CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2, damagePos, CVector(0.0f, 0.0f, 0.0f), nil, 0.5f);
+		} else {
+			CVector direction = m_vecMoveSpeed + GetUp() * m_vecMoveSpeed.Magnitude() * 0.15f;
+			bool bBonnetOpenOrMissing = false;
+			switch (Damage.GetDoorStatus(DOOR_BONNET)) {
+			case DOOR_STATUS_OK:
+			case DOOR_STATUS_SMASHED:
+				direction += GetForward() * 0.03f;
+				break;
+			case DOOR_STATUS_SWINGING:
+			case DOOR_STATUS_MISSING:
+				bBonnetOpenOrMissing = true;
+				break;
+			}
+
+			if (enginePos.y < 0.0 || overheatPos.y < 0.0 || overheat2Pos.y < 0.0) // Rear engine
+				bBonnetOpenOrMissing = false;
+
+			if (!enginePos.IsZero()) enginePos = GetMatrix() * enginePos;
+			if (!overheatPos.IsZero()) overheatPos = GetMatrix() * overheatPos;
+			if (!overheat2Pos.IsZero()) overheat2Pos = GetMatrix() * overheat2Pos;
+
+			if (!enginePos.IsZero() && bBonnetOpenOrMissing) {
+				CParticle::AddParticle(PARTICLE_CARFLAME, enginePos,
+					CVector(0.0f, 0.0f, CGeneral::GetRandomNumberInRange(0.01125f, 0.09f)),
+					nil, 0.63f);
+
+				CVector coors = enginePos;
+				coors.x += CGeneral::GetRandomNumberInRange(-0.5625f, 0.5625f),
+					coors.y += CGeneral::GetRandomNumberInRange(-0.5625f, 0.5625f),
+					coors.z += CGeneral::GetRandomNumberInRange(0.5625f, 2.25f);
+				CParticle::AddParticle(PARTICLE_CARFLAME_SMOKE, coors, CVector(0.0f, 0.0f, 0.0f));
+
+				CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2, enginePos, CVector(0.0f, 0.0f, 0.0f), nil, 0.5f);
+			} 
+
+			if (!overheatPos.IsZero() && !bBonnetOpenOrMissing) {
+				CParticle::AddParticle(PARTICLE_CARFLAME_SMALL, overheatPos, direction);
+				CParticle::AddParticle(PARTICLE_CARFLAME_SMOKE_SMALL, overheatPos, direction);
+				CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2_SMALL, overheatPos, direction);
+			}
+
+			if (!overheat2Pos.IsZero() && !bBonnetOpenOrMissing) {
+				CParticle::AddParticle(PARTICLE_CARFLAME_SMALL, overheat2Pos, direction);
+				CParticle::AddParticle(PARTICLE_CARFLAME_SMOKE_SMALL, overheat2Pos, direction);
+				CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2_SMALL, overheat2Pos, direction);
+			}
+		}
+	}
+#endif
+
 	int i, n;
 
 	if(this == FindPlayerVehicle() && TheCamera.GetLookingForwardFirstPerson())
@@ -4534,91 +5738,290 @@ CAutomobile::AddDamagedVehicleParticles(void)
 	if(m_fHealth >= 650.0f)
 		return;
 
-	CVector direction = fSpeedMult[5]*m_vecMoveSpeed;
-	CVector damagePos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->m_positions[CAR_POS_HEADLIGHTS];
-
-	switch(Damage.GetDoorStatus(DOOR_BONNET)){
-	case DOOR_STATUS_OK:
-	case DOOR_STATUS_SMASHED:
-		// Bonnet is still there, smoke comes out at the edge
-		damagePos += vecDAMAGE_ENGINE_POS_SMALL;
-		break;
-	case DOOR_STATUS_SWINGING:
-	case DOOR_STATUS_MISSING:
-		// Bonnet is gone, smoke comes out at the engine
-		damagePos += vecDAMAGE_ENGINE_POS_BIG;
-		break;
-	}
-
-	if(GetModelIndex() == MI_BFINJECT)
-		damagePos = CVector(0.3f, -1.5f, -0.1f);
-	else if(GetModelIndex() == MI_CADDY)
-		damagePos = CVector(0.6f, -1.0f, -0.25f);
-	else if(IsRealHeli()){
-		damagePos.x = 0.4f*GetColModel()->boundingBox.max.x;
-		damagePos.y = 0.2f*GetColModel()->boundingBox.min.y;
-		damagePos.z = 0.3f*GetColModel()->boundingBox.max.z;
-	}else
-		damagePos.z += fDamagePosSpeedShift*(GetColModel()->boundingBox.max.z-damagePos.z) * DotProduct(GetForward(), m_vecMoveSpeed);
-	damagePos = GetMatrix()*damagePos;
-	damagePos.z += 0.15f;
-
-	bool electric = pHandling->Transmission.nEngineType == 'E';
-
-	if(electric && m_fHealth < 320.0f && m_fHealth > 1.0f){
-		direction = 0.85f*m_vecMoveSpeed;
-		direction += GetRight() * CGeneral::GetRandomNumberInRange(0.0f, 0.04f) * (1.0f - 2.0f*m_vecMoveSpeed.Magnitude());
-		direction.z += 0.001f;
-		n = (CGeneral::GetRandomNumber() & 7) + 2;
-		for(i = 0; i < n; i++)
-			CParticle::AddParticle(PARTICLE_SPARK_SMALL, damagePos, direction);
-		if(((CTimer::GetFrameCounter() + m_randomSeed) & 7) == 0)
-			CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2, damagePos, 0.8f*m_vecMoveSpeed, nil, 0.1f, 0, 0, 0, 1000);
-	}else if(electric && m_fHealth < 460.0f){
-		direction = 0.85f*m_vecMoveSpeed;
-		direction += GetRight() * CGeneral::GetRandomNumberInRange(0.0f, 0.04f) * (1.0f - 2.0f*m_vecMoveSpeed.Magnitude());
-		direction.z += 0.001f;
-		n = (CGeneral::GetRandomNumber() & 3) + 1;
-		for(i = 0; i < n; i++)
-			CParticle::AddParticle(PARTICLE_SPARK_SMALL, damagePos, direction);
-		if(((CTimer::GetFrameCounter() + m_randomSeed) & 0xF) == 0)
-			CParticle::AddParticle(PARTICLE_ENGINE_SMOKE, damagePos, 0.8f*m_vecMoveSpeed, nil, 0.1f, 0, 0, 0, 1000);
-	}else if(m_fHealth < 250.0f){
-		// nothing
-	}else if(m_fHealth < 320.0f){
-		CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2, damagePos, fSpeedMult[0]*direction);
-	}else if(m_fHealth < 390.0f){
-		CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, fSpeedMult[1]*direction);
-		CParticle::AddParticle(PARTICLE_ENGINE_SMOKE, damagePos, fSpeedMult[2]*direction);
-	}else if(m_fHealth < 460.0f){
-		if(((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 0 ||
-		   ((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 2)
-			CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, fSpeedMult[3]*direction);
-	}else{
-		int rnd = CTimer::GetFrameCounter() + m_randomSeed;
-		if(rnd < 10 ||
-		   rnd < 70 && rnd > 25 ||
-		   rnd < 160 && rnd > 100 ||
-		   rnd < 200 && rnd > 175 ||
-		   rnd > 235)
-			return;
-		direction.z += 0.05f*Max(1.0f - 1.6f*m_vecMoveSpeed.Magnitude(), 0.0f);
-		if(electric){
+#ifdef IMPROVED_VEHICLES_2 // change engine smoke position
+		CVector enginePos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->m_positions[CAR_POS_ENGINE];
+		CVector overheatPos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->m_positions[CAR_POS_OVERHEAT];
+		CVector overheat2Pos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->m_positions[CAR_POS_OVERHEAT_2];
+		
+		if (enginePos.IsZero() && overheatPos.IsZero() && overheat2Pos.IsZero()) {
+			CVector direction = fSpeedMult[5]*m_vecMoveSpeed;
+			CVector damagePos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->m_positions[CAR_POS_HEADLIGHTS];
+	
+			switch(Damage.GetDoorStatus(DOOR_BONNET)){
+			case DOOR_STATUS_OK:
+			case DOOR_STATUS_SMASHED:
+				// Bonnet is still there, smoke comes out at the edge
+				damagePos += vecDAMAGE_ENGINE_POS_SMALL;
+				break;
+			case DOOR_STATUS_SWINGING:
+			case DOOR_STATUS_MISSING:
+				// Bonnet is gone, smoke comes out at the engine
+				damagePos += vecDAMAGE_ENGINE_POS_BIG;
+				break;
+			}
+	
+			if(GetModelIndex() == MI_BFINJECT)
+				damagePos = CVector(0.3f, -1.5f, -0.1f);
+			else if(GetModelIndex() == MI_CADDY)
+				damagePos = CVector(0.6f, -1.0f, -0.25f);
+			else if(IsRealHeli()){
+				damagePos.x = 0.4f*GetColModel()->boundingBox.max.x;
+				damagePos.y = 0.2f*GetColModel()->boundingBox.min.y;
+				damagePos.z = 0.3f*GetColModel()->boundingBox.max.z;
+			}else
+				damagePos.z += fDamagePosSpeedShift*(GetColModel()->boundingBox.max.z-damagePos.z) * DotProduct(GetForward(), m_vecMoveSpeed);
+			damagePos = GetMatrix()*damagePos;
+			damagePos.z += 0.15f;
+	
+			bool electric = pHandling->Transmission.nEngineType == 'E';
+	
+			if(electric && m_fHealth < 320.0f && m_fHealth > 1.0f){
+				direction = 0.85f*m_vecMoveSpeed;
+				direction += GetRight() * CGeneral::GetRandomNumberInRange(0.0f, 0.04f) * (1.0f - 2.0f*m_vecMoveSpeed.Magnitude());
+				direction.z += 0.001f;
+				n = (CGeneral::GetRandomNumber() & 7) + 2;
+				for(i = 0; i < n; i++)
+					CParticle::AddParticle(PARTICLE_SPARK_SMALL, damagePos, direction);
+				if(((CTimer::GetFrameCounter() + m_randomSeed) & 7) == 0)
+					CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2, damagePos, 0.8f*m_vecMoveSpeed, nil, 0.1f, 0, 0, 0, 1000);
+			}else if(electric && m_fHealth < 460.0f){
+				direction = 0.85f*m_vecMoveSpeed;
+				direction += GetRight() * CGeneral::GetRandomNumberInRange(0.0f, 0.04f) * (1.0f - 2.0f*m_vecMoveSpeed.Magnitude());
+				direction.z += 0.001f;
+				n = (CGeneral::GetRandomNumber() & 3) + 1;
+				for(i = 0; i < n; i++)
+					CParticle::AddParticle(PARTICLE_SPARK_SMALL, damagePos, direction);
+				if(((CTimer::GetFrameCounter() + m_randomSeed) & 0xF) == 0)
+					CParticle::AddParticle(PARTICLE_ENGINE_SMOKE, damagePos, 0.8f*m_vecMoveSpeed, nil, 0.1f, 0, 0, 0, 1000);
+			}else if(m_fHealth < 250.0f){
+				// nothing
+			}else if(m_fHealth < 320.0f){
+				CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2, damagePos, fSpeedMult[0]*direction);
+			}else if(m_fHealth < 390.0f){
+				CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, fSpeedMult[1]*direction);
+				CParticle::AddParticle(PARTICLE_ENGINE_SMOKE, damagePos, fSpeedMult[2]*direction);
+			}else if(m_fHealth < 460.0f){
+				if(((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 0 ||
+				   ((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 2)
+					CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, fSpeedMult[3]*direction);
+			}else{
+				int rnd = CTimer::GetFrameCounter() + m_randomSeed;
+				if(rnd < 10 ||
+				   rnd < 70 && rnd > 25 ||
+				   rnd < 160 && rnd > 100 ||
+				   rnd < 200 && rnd > 175 ||
+				   rnd > 235)
+					return;
+				direction.z += 0.05f*Max(1.0f - 1.6f*m_vecMoveSpeed.Magnitude(), 0.0f);
+				if(electric){
+					direction = 0.85f*m_vecMoveSpeed;
+					direction += GetRight() * CGeneral::GetRandomNumberInRange(0.0f, 0.04f) * (1.0f - 2.0f*m_vecMoveSpeed.Magnitude());
+					direction.z += 0.001f;
+					n = (CGeneral::GetRandomNumber() & 2) + 2;
+					for(i = 0; i < n; i++)
+						CParticle::AddParticle(PARTICLE_SPARK_SMALL, damagePos, direction);
+					if(((CTimer::GetFrameCounter() + m_randomSeed) & 0xF) == 0)
+						CParticle::AddParticle(PARTICLE_ENGINE_SMOKE, damagePos, 0.8f*m_vecMoveSpeed, nil, 0.1f, 0, 0, 0, 1000);
+				}else{
+					if(TheCamera.GetLookDirection() != LOOKING_FORWARD)
+						CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, direction);
+					else if(((CTimer::GetFrameCounter() + m_randomSeed) & 1) == 0)
+						CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, fSpeedMult[4]*m_vecMoveSpeed);
+				}
+			}
+		} else {
+			CVector direction = m_vecMoveSpeed + GetUp() * m_vecMoveSpeed.Magnitude() * 0.1f;
+			bool bBonnetOpenOrMissing = false;
+			switch (Damage.GetDoorStatus(DOOR_BONNET)) {
+				case DOOR_STATUS_OK:
+				case DOOR_STATUS_SMASHED:
+					direction += GetForward() * 0.02f;
+					break;
+				case DOOR_STATUS_SWINGING:
+				case DOOR_STATUS_MISSING:
+					bBonnetOpenOrMissing = true;
+					break;
+			}
+	
+			if (enginePos.y < 0.0 || overheatPos.y < 0.0 || overheat2Pos.y < 0.0) // Rear engine
+				bBonnetOpenOrMissing = false;
+	
+			if (!enginePos.IsZero()) enginePos = GetMatrix() * enginePos;
+			if (!overheatPos.IsZero()) overheatPos = GetMatrix() * overheatPos;
+			if (!overheat2Pos.IsZero()) overheat2Pos = GetMatrix() * overheat2Pos;
+	
+			bool electric = pHandling->Transmission.nEngineType == 'E';
+	
+			if(!enginePos.IsZero() && electric && m_fHealth < 320.0f && m_fHealth > 1.0f){
+				direction = 0.85f*m_vecMoveSpeed;
+				direction += GetRight() * CGeneral::GetRandomNumberInRange(0.0f, 0.04f) * (1.0f - 2.0f*m_vecMoveSpeed.Magnitude());
+				direction.z += 0.001f;
+				n = (CGeneral::GetRandomNumber() & 7) + 2;
+				for(i = 0; i < n; i++)
+					CParticle::AddParticle(PARTICLE_SPARK_SMALL, enginePos, direction);
+				if(((CTimer::GetFrameCounter() + m_randomSeed) & 7) == 0)
+					CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2, enginePos, 0.8f*m_vecMoveSpeed, nil, 0.1f, 0, 0, 0, 1000);
+			}else if(!enginePos.IsZero() && electric && m_fHealth < 460.0f){
+				direction = 0.85f*m_vecMoveSpeed;
+				direction += GetRight() * CGeneral::GetRandomNumberInRange(0.0f, 0.04f) * (1.0f - 2.0f*m_vecMoveSpeed.Magnitude());
+				direction.z += 0.001f;
+				n = (CGeneral::GetRandomNumber() & 3) + 1;
+				for(i = 0; i < n; i++)
+					CParticle::AddParticle(PARTICLE_SPARK_SMALL, enginePos, direction);
+				if(((CTimer::GetFrameCounter() + m_randomSeed) & 0xF) == 0)
+					CParticle::AddParticle(PARTICLE_ENGINE_SMOKE, enginePos, 0.8f*m_vecMoveSpeed, nil, 0.1f, 0, 0, 0, 1000);
+			}else if(m_fHealth < 250.0f){
+				// nothing
+			}else if(m_fHealth < 320.0f){
+				if (!enginePos.IsZero() && bBonnetOpenOrMissing) CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2, enginePos, fSpeedMult[0] * direction);
+				if (!overheatPos.IsZero() && !bBonnetOpenOrMissing)CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2_SMALL, overheatPos, direction);
+				if (!overheat2Pos.IsZero() && !bBonnetOpenOrMissing) CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2_SMALL, overheat2Pos, direction);
+			}else if(m_fHealth < 390.0f){
+				if (!enginePos.IsZero() && bBonnetOpenOrMissing) {
+					CParticle::AddParticle(PARTICLE_ENGINE_STEAM, enginePos, fSpeedMult[1] * direction);
+					CParticle::AddParticle(PARTICLE_ENGINE_SMOKE, enginePos, fSpeedMult[2] * direction);
+				}
+	
+				if (!overheatPos.IsZero() && !bBonnetOpenOrMissing) {
+					CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheatPos, direction);
+					CParticle::AddParticle(PARTICLE_ENGINE_SMOKE_SMALL, overheatPos, direction);
+				}
+	
+				if (!overheat2Pos.IsZero() && !bBonnetOpenOrMissing) {
+					CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheat2Pos, direction);
+					CParticle::AddParticle(PARTICLE_ENGINE_SMOKE_SMALL, overheat2Pos, direction);
+				}
+			}else if(m_fHealth < 460.0f){
+				if (((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 0 ||
+					((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 2) {
+	
+					if (!enginePos.IsZero() && bBonnetOpenOrMissing) CParticle::AddParticle(PARTICLE_ENGINE_STEAM, enginePos, fSpeedMult[3] * direction);
+					if (!overheatPos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheatPos, direction);
+					if (!overheat2Pos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheat2Pos, direction);
+				}
+			}else{
+				int rnd = CTimer::GetFrameCounter() + m_randomSeed;
+				if(rnd < 10 ||
+				   rnd < 70 && rnd > 25 ||
+				   rnd < 160 && rnd > 100 ||
+				   rnd < 200 && rnd > 175 ||
+				   rnd > 235)
+					return;
+				direction.z += 0.05f*Max(1.0f - 1.6f*m_vecMoveSpeed.Magnitude(), 0.0f);
+				if(electric){
+					direction = 0.85f*m_vecMoveSpeed;
+					direction += GetRight() * CGeneral::GetRandomNumberInRange(0.0f, 0.04f) * (1.0f - 2.0f*m_vecMoveSpeed.Magnitude());
+					direction.z += 0.001f;
+					n = (CGeneral::GetRandomNumber() & 2) + 2;
+					for(i = 0; i < n; i++)
+						CParticle::AddParticle(PARTICLE_SPARK_SMALL, enginePos, direction);
+					if(((CTimer::GetFrameCounter() + m_randomSeed) & 0xF) == 0)
+						CParticle::AddParticle(PARTICLE_ENGINE_SMOKE, enginePos, 0.8f*m_vecMoveSpeed, nil, 0.1f, 0, 0, 0, 1000);
+				}else{
+					if (!enginePos.IsZero() && bBonnetOpenOrMissing) {
+						if (TheCamera.GetLookDirection() != LOOKING_FORWARD)
+							CParticle::AddParticle(PARTICLE_ENGINE_STEAM, enginePos, direction);
+						else if (((CTimer::GetFrameCounter() + m_randomSeed) & 1) == 0)
+							CParticle::AddParticle(PARTICLE_ENGINE_STEAM, enginePos, fSpeedMult[4] * m_vecMoveSpeed);
+					} else {
+						if (TheCamera.GetLookDirection() != LOOKING_FORWARD) {
+							if (!overheatPos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheatPos, direction);
+							if (!overheat2Pos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheat2Pos, direction);
+						} else if (((CTimer::GetFrameCounter() + m_randomSeed) & 1) == 0) {
+							if (!overheatPos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheatPos, direction);
+							if (!overheat2Pos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheat2Pos, direction);
+						}
+					}
+				}
+			}
+		}
+#else
+		CVector direction = fSpeedMult[5]*m_vecMoveSpeed;
+		CVector damagePos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->m_positions[CAR_POS_HEADLIGHTS];
+	
+		switch(Damage.GetDoorStatus(DOOR_BONNET)){
+		case DOOR_STATUS_OK:
+		case DOOR_STATUS_SMASHED:
+			// Bonnet is still there, smoke comes out at the edge
+			damagePos += vecDAMAGE_ENGINE_POS_SMALL;
+			break;
+		case DOOR_STATUS_SWINGING:
+		case DOOR_STATUS_MISSING:
+			// Bonnet is gone, smoke comes out at the engine
+			damagePos += vecDAMAGE_ENGINE_POS_BIG;
+			break;
+		}
+	
+		if(GetModelIndex() == MI_BFINJECT)
+			damagePos = CVector(0.3f, -1.5f, -0.1f);
+		else if(GetModelIndex() == MI_CADDY)
+			damagePos = CVector(0.6f, -1.0f, -0.25f);
+		else if(IsRealHeli()){
+			damagePos.x = 0.4f*GetColModel()->boundingBox.max.x;
+			damagePos.y = 0.2f*GetColModel()->boundingBox.min.y;
+			damagePos.z = 0.3f*GetColModel()->boundingBox.max.z;
+		}else
+			damagePos.z += fDamagePosSpeedShift*(GetColModel()->boundingBox.max.z-damagePos.z) * DotProduct(GetForward(), m_vecMoveSpeed);
+		damagePos = GetMatrix()*damagePos;
+		damagePos.z += 0.15f;
+	
+		bool electric = pHandling->Transmission.nEngineType == 'E';
+	
+		if(electric && m_fHealth < 320.0f && m_fHealth > 1.0f){
+			direction = 0.85f*m_vecMoveSpeed;
+			direction += GetRight() * CGeneral::GetRandomNumberInRange(0.0f, 0.04f) * (1.0f - 2.0f*m_vecMoveSpeed.Magnitude());
+			direction.z += 0.001f;
+			n = (CGeneral::GetRandomNumber() & 7) + 2;
+			for(i = 0; i < n; i++)
+				CParticle::AddParticle(PARTICLE_SPARK_SMALL, damagePos, direction);
+			if(((CTimer::GetFrameCounter() + m_randomSeed) & 7) == 0)
+				CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2, damagePos, 0.8f*m_vecMoveSpeed, nil, 0.1f, 0, 0, 0, 1000);
+		}else if(electric && m_fHealth < 460.0f){
 			direction = 0.85f*m_vecMoveSpeed;
 			direction += GetRight() * CGeneral::GetRandomNumberInRange(0.0f, 0.04f) * (1.0f - 2.0f*m_vecMoveSpeed.Magnitude());
 			direction.z += 0.001f;
-			n = (CGeneral::GetRandomNumber() & 2) + 2;
+			n = (CGeneral::GetRandomNumber() & 3) + 1;
 			for(i = 0; i < n; i++)
 				CParticle::AddParticle(PARTICLE_SPARK_SMALL, damagePos, direction);
 			if(((CTimer::GetFrameCounter() + m_randomSeed) & 0xF) == 0)
 				CParticle::AddParticle(PARTICLE_ENGINE_SMOKE, damagePos, 0.8f*m_vecMoveSpeed, nil, 0.1f, 0, 0, 0, 1000);
+		}else if(m_fHealth < 250.0f){
+			// nothing
+		}else if(m_fHealth < 320.0f){
+			CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2, damagePos, fSpeedMult[0]*direction);
+		}else if(m_fHealth < 390.0f){
+			CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, fSpeedMult[1]*direction);
+			CParticle::AddParticle(PARTICLE_ENGINE_SMOKE, damagePos, fSpeedMult[2]*direction);
+		}else if(m_fHealth < 460.0f){
+			if(((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 0 ||
+			   ((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 2)
+				CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, fSpeedMult[3]*direction);
 		}else{
-			if(TheCamera.GetLookDirection() != LOOKING_FORWARD)
-				CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, direction);
-			else if(((CTimer::GetFrameCounter() + m_randomSeed) & 1) == 0)
-				CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, fSpeedMult[4]*m_vecMoveSpeed);
+			int rnd = CTimer::GetFrameCounter() + m_randomSeed;
+			if(rnd < 10 ||
+			   rnd < 70 && rnd > 25 ||
+			   rnd < 160 && rnd > 100 ||
+			   rnd < 200 && rnd > 175 ||
+			   rnd > 235)
+				return;
+			direction.z += 0.05f*Max(1.0f - 1.6f*m_vecMoveSpeed.Magnitude(), 0.0f);
+			if(electric){
+				direction = 0.85f*m_vecMoveSpeed;
+				direction += GetRight() * CGeneral::GetRandomNumberInRange(0.0f, 0.04f) * (1.0f - 2.0f*m_vecMoveSpeed.Magnitude());
+				direction.z += 0.001f;
+				n = (CGeneral::GetRandomNumber() & 2) + 2;
+				for(i = 0; i < n; i++)
+					CParticle::AddParticle(PARTICLE_SPARK_SMALL, damagePos, direction);
+				if(((CTimer::GetFrameCounter() + m_randomSeed) & 0xF) == 0)
+					CParticle::AddParticle(PARTICLE_ENGINE_SMOKE, damagePos, 0.8f*m_vecMoveSpeed, nil, 0.1f, 0, 0, 0, 1000);
+			}else{
+				if(TheCamera.GetLookDirection() != LOOKING_FORWARD)
+					CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, direction);
+				else if(((CTimer::GetFrameCounter() + m_randomSeed) & 1) == 0)
+					CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, fSpeedMult[4]*m_vecMoveSpeed);
+			}
 		}
-	}
+#endif
 }
 
 int32
@@ -5543,6 +6946,21 @@ CAutomobile::ProcessSwingingDoor(int32 component, eDoors door)
 		SetComponentVisibility(m_aCarNodes[CAR_BONNET], ATOMIC_FLAG_NONE);
 		Damage.SetDoorStatus(DOOR_BONNET, DOOR_STATUS_MISSING);
 
+#ifdef VEHICLE_MODS // hide bonnet upgrades after bonnet rip off
+		if (m_aCarNodes[CAR_BNT_SCOOP_OK] && GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_OK]))
+			RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_OK]), 0);
+		if (m_aCarNodes[CAR_BNT_SCOOP_DAM] && GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_DAM]))
+			RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_DAM]), 0);
+		if (m_aCarNodes[CAR_VENT_L_OK] && GetFirstObject(m_aCarNodes[CAR_VENT_L_OK]))
+			RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_L_OK]), 0);
+		if (m_aCarNodes[CAR_VENT_L_DAM] && GetFirstObject(m_aCarNodes[CAR_VENT_L_DAM]))
+			RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_L_DAM]), 0);
+		if (m_aCarNodes[CAR_VENT_R_OK] && GetFirstObject(m_aCarNodes[CAR_VENT_R_OK]))
+			RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_R_OK]), 0);
+		if (m_aCarNodes[CAR_VENT_R_DAM] && GetFirstObject(m_aCarNodes[CAR_VENT_R_DAM]))
+			RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_R_DAM]), 0);
+#endif
+
 		if(comp){
 			if(CGeneral::GetRandomNumber() & 1)
 				comp->m_vecMoveSpeed = 0.4f*m_vecMoveSpeed + 0.1f*GetRight() + 0.5f*GetUp();
@@ -5571,6 +6989,16 @@ CAutomobile::Fix(void)
 	RpClumpForAllAtomics((RpClump*)m_rwObject, CVehicleModelInfo::HideAllComponentsAtomicCB, (void*)ATOMIC_FLAG_DAM);
 
 	for(component = CAR_BUMP_FRONT; component < NUM_CAR_NODES; component++){
+#ifdef VEHICLE_MODS // not to change matrix upgrades after car fix
+		if (component >= CAR_SPOILER_OK && component <= CAR_SUPERCHARGER)
+			continue;
+#endif
+
+#ifdef IMPROVED_VEHICLES_2
+		if (component == CAR_STEERINGWHEEL)
+			continue;
+#endif
+
 		if(m_aCarNodes[component]){
 			CMatrix mat(RwFrameGetMatrix(m_aCarNodes[component]));
 			mat.SetTranslate(mat.GetPosition());
@@ -5631,6 +7059,16 @@ GetCurrentAtomicObjectCB(RwObject *object, void *data)
 	return object;
 }
 
+#ifdef IMPROVED_VEHICLES_2
+RwObject* GetWindowAtomicObjectCB(RwObject* object, void* data)
+{
+	RpAtomic* atomic = (RpAtomic*)object;
+	if(CVisibilityPlugins::GetAtomicId(atomic) & ATOMIC_FLAG_DOORWINDOW)
+		((RpAtomic**)data)[0] = atomic;
+	return object;
+}
+#endif
+
 CObject*
 CAutomobile::SpawnFlyingComponent(int32 component, uint32 type)
 {
@@ -5800,6 +7238,31 @@ CAutomobile::SetPanelDamage(int32 component, ePanels panel, bool noFlyingCompone
 			DMAudio.PlayOneShot(m_audioEntityId, SOUND_CAR_WINDSHIELD_CRACK, 0.0f);
 		// show damaged part
 		SetComponentVisibility(m_aCarNodes[component], ATOMIC_FLAG_DAM);
+
+#ifdef VEHICLE_MODS // show damaged upgrade after hit
+		if (component == CAR_BOOT) {
+			if (m_aCarNodes[CAR_SPOILER_DAM]) {
+				if (m_aCarNodes[CAR_SPOILER_OK] && GetFirstObject(m_aCarNodes[CAR_SPOILER_OK]))
+					RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SPOILER_OK]), 0);
+				if (GetFirstObject(m_aCarNodes[CAR_SPOILER_DAM]))
+					RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SPOILER_DAM]), rpATOMICRENDER);
+			}
+		} else if (component == CAR_BONNET) {
+			if (m_aCarNodes[CAR_BNT_SCOOP_OK] && GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_OK]))
+				RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_OK]), 0);
+			if (m_aCarNodes[CAR_BNT_SCOOP_DAM] && GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_DAM]))
+				RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_DAM]), rpATOMICRENDER);
+			if (m_aCarNodes[CAR_VENT_L_OK] && GetFirstObject(m_aCarNodes[CAR_VENT_L_OK]))
+				RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_L_OK]), 0);
+			if (m_aCarNodes[CAR_VENT_L_DAM] && GetFirstObject(m_aCarNodes[CAR_VENT_L_DAM]))
+				RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_L_DAM]), rpATOMICRENDER);
+			if (m_aCarNodes[CAR_VENT_R_OK] && GetFirstObject(m_aCarNodes[CAR_VENT_R_OK]))
+				RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_R_OK]), 0);
+			if (m_aCarNodes[CAR_VENT_R_DAM] && GetFirstObject(m_aCarNodes[CAR_VENT_R_DAM]))
+				RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_R_DAM]), rpATOMICRENDER);
+		}
+#endif
+
 	}else if(status == PANEL_STATUS_MISSING){
 		if(!noFlyingComponents)
 			SpawnFlyingComponent(component, COMPGROUP_PANEL);
@@ -5870,17 +7333,93 @@ CAutomobile::SetDoorDamage(int32 component, eDoors door, bool noFlyingComponents
 		}
 		// hide both
 		SetComponentVisibility(m_aCarNodes[component], ATOMIC_FLAG_NONE);
+
+#ifdef VEHICLE_MODS // hide ok and dam upgrade after hit
+		if (component == CAR_BOOT) {
+			if (m_aCarNodes[CAR_SPOILER_DAM]) {
+				if (m_aCarNodes[CAR_SPOILER_OK] && GetFirstObject(m_aCarNodes[CAR_SPOILER_OK]))
+					RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SPOILER_OK]), 0);
+				if (GetFirstObject(m_aCarNodes[CAR_SPOILER_DAM]))
+					RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SPOILER_DAM]), 0);
+			}
+		} else if (component == CAR_BONNET) {
+			if (m_aCarNodes[CAR_BNT_SCOOP_OK] && GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_OK]))
+				RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_OK]), 0);
+			if (m_aCarNodes[CAR_BNT_SCOOP_DAM] && GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_DAM]))
+				RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_DAM]), 0);
+			if (m_aCarNodes[CAR_VENT_L_OK] && GetFirstObject(m_aCarNodes[CAR_VENT_L_OK]))
+				RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_L_OK]), 0);
+			if (m_aCarNodes[CAR_VENT_L_DAM] && GetFirstObject(m_aCarNodes[CAR_VENT_L_DAM]))
+				RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_L_DAM]), 0);
+			if (m_aCarNodes[CAR_VENT_R_OK] && GetFirstObject(m_aCarNodes[CAR_VENT_R_OK]))
+				RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_R_OK]), 0);
+			if (m_aCarNodes[CAR_VENT_R_DAM] && GetFirstObject(m_aCarNodes[CAR_VENT_R_DAM]))
+				RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_R_DAM]), 0);
+		}
+#endif
+
+#ifdef IMPROVED_VEHICLES_2
+		if (component == CAR_DOOR_LF || component == CAR_DOOR_RF || component == CAR_DOOR_LR || component == CAR_DOOR_RR) {
+			RpAtomic* windowAtomic = nil;
+			RwFrameForAllObjects(m_aCarNodes[component], GetWindowAtomicObjectCB, &windowAtomic);
+			if (windowAtomic) RpAtomicSetFlags(windowAtomic, 0);
+		}
+#endif
+
 		break;
 	}
 }
 
+#ifdef IMPROVED_VEHICLES
+void CAutomobile::SetWheelMissing(int32 wheel)
+{
+	if (Damage.m_wheelStatus[wheel] == WHEEL_STATUS_MISSING)
+		return;
+
+	Damage.m_wheelStatus[wheel] = WHEEL_STATUS_MISSING;
+	RpAtomic* atomic = nil;
+
+	switch (wheel)
+	{
+		case CARWHEEL_FRONT_LEFT:
+			SpawnFlyingComponent(CAR_WHEEL_LF, COMPGROUP_WHEEL);
+			RwFrameForAllObjects(m_aCarNodes[CAR_WHEEL_LF], GetCurrentAtomicObjectCB, &atomic);
+			if (atomic) RpAtomicSetFlags(atomic, 0);
+			break;
+		case CARWHEEL_REAR_LEFT:
+			SpawnFlyingComponent(CAR_WHEEL_LB, COMPGROUP_WHEEL);
+			RwFrameForAllObjects(m_aCarNodes[CAR_WHEEL_LB], GetCurrentAtomicObjectCB, &atomic);
+			if (atomic) RpAtomicSetFlags(atomic, 0);
+			break;
+		case CARWHEEL_FRONT_RIGHT:
+			SpawnFlyingComponent(CAR_WHEEL_RF, COMPGROUP_WHEEL);
+			RwFrameForAllObjects(m_aCarNodes[CAR_WHEEL_RF], GetCurrentAtomicObjectCB, &atomic);
+			if (atomic) RpAtomicSetFlags(atomic, 0);
+			break;
+		case CARWHEEL_REAR_RIGHT:
+			SpawnFlyingComponent(CAR_WHEEL_RB, COMPGROUP_WHEEL);
+			RwFrameForAllObjects(m_aCarNodes[CAR_WHEEL_RB], GetCurrentAtomicObjectCB, &atomic);
+			if (atomic) RpAtomicSetFlags(atomic, 0);
+			break;
+	}
+	
+}
+#endif
 
 static RwObject*
 SetVehicleAtomicVisibilityCB(RwObject *object, void *data)
 {
 	uint32 flags = (uint32)(uintptr)data;
 	RpAtomic *atomic = (RpAtomic*)object;
+
+#ifdef IMPROVED_VEHICLES_2 // remove window after door missing
+	if((CVisibilityPlugins::GetAtomicId(atomic) & (ATOMIC_FLAG_OK|ATOMIC_FLAG_DAM|ATOMIC_FLAG_DOORWINDOW)) == flags)
+		RpAtomicSetFlags(atomic, rpATOMICRENDER);
+	else if((CVisibilityPlugins::GetAtomicId(atomic) & (ATOMIC_FLAG_OK|ATOMIC_FLAG_DAM)) == flags)
+#else
 	if((CVisibilityPlugins::GetAtomicId(atomic) & (ATOMIC_FLAG_OK|ATOMIC_FLAG_DAM)) == flags)
+#endif
+
 		RpAtomicSetFlags(atomic, rpATOMICRENDER);
 	else
 		RpAtomicSetFlags(atomic, 0);
@@ -5935,6 +7474,1900 @@ CAutomobile::ReduceHornCounter(void)
 		m_nCarHornTimer--;
 }
 
+#ifdef IMPROVED_VEHICLES_2
+void CAutomobile::DoVehicleLights()
+{
+	// from CAutomobile::PreRender, modified
+
+	CVehicleModelInfo* mi = (CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex());
+
+	// Turn lights on/off
+	bool shouldLightsBeOn = 
+		CClock::GetHours() > 20 ||
+		CClock::GetHours() > 19 && CClock::GetMinutes() > (m_randomSeed & 0x3F) ||
+		CClock::GetHours() < 7 ||
+		CClock::GetHours() < 8 && CClock::GetMinutes() < (m_randomSeed & 0x3F) ||
+		m_randomSeed/50000.0f < CWeather::Foggyness ||
+		m_randomSeed/50000.0f < CWeather::WetRoads;
+	if(shouldLightsBeOn != bLightsOn && GetStatus() != STATUS_WRECKED){
+#ifdef IMPROVED_TECH_PART // Vehicles are muted when the exit button is held down
+		if(GetStatus() == STATUS_ABANDONED || GetStatus() == STATUS_PLAYER_DISABLED){
+#else
+		if(GetStatus() == STATUS_ABANDONED){
+#endif
+			// Turn off lights on abandoned vehicles only when we they're far away
+			if(bLightsOn &&
+				Abs(TheCamera.GetPosition().x - GetPosition().x) + Abs(TheCamera.GetPosition().y - GetPosition().y) > 100.0f)
+				bLightsOn = false;
+		}else
+			bLightsOn = shouldLightsBeOn;
+	}
+
+	// Actually render the lights
+	bool alarmOn = false;
+	bool alarmOff = false;
+	if(IsAlarmOn()){
+		if(CTimer::GetTimeInMilliseconds() & 0x100)
+			alarmOn = true;
+		else
+			alarmOff = true;
+	}
+
+	if (mi->bNewLights) {
+		CVector headLightPos = mi->m_positions[CAR_POS_HEADLIGHTS];
+		eCarNodes headlightLeftFrame = CAR_HEADLIGHT_L;
+		eCarNodes headlightRightFrame = CAR_HEADLIGHT_R;
+
+		CVector reversingLightPos = mi->m_positions[CAR_POS_REVERSINGLIGHTS];
+		CVector reversingLightPos2 = mi->m_positions[CAR_POS_REVERSINGLIGHTS_2];
+		eCarNodes reversingLeftFrame = CAR_REVERSINGLIGHT_L;
+		eCarNodes reversingRightFrame = CAR_REVERSINGLIGHT_R;
+
+		CVector brakeLightPos = mi->m_positions[CAR_POS_BRAKELIGHTS];
+		eCarNodes brakeLeftFrame = CAR_BRAKELIGHT_L;
+		eCarNodes brakeRightFrame = CAR_BRAKELIGHT_R;
+
+		CVector brakeLightPos2 = mi->m_positions[CAR_POS_BRAKELIGHTS_2];
+
+		CVector lookVector = GetPosition() - TheCamera.GetPosition();
+		float camDist = lookVector.Magnitude();
+		if (camDist != 0.0f)
+			lookVector *= 1.0f / camDist;
+		else
+			lookVector = CVector(1.0f, 0.0f, 0.0f);
+
+		// 1.0 if directly behind car, -1.0 if in front
+		float behindness = DotProduct(lookVector, GetForward());
+		behindness = Clamp(behindness, -1.0f, 1.0f);	// shouldn't be necessary
+		// 0.0 if behind car, PI if in front
+		// Abs not necessary
+		float angle = Abs(Acos(behindness));
+
+		bool bLeftFwdLightsLikeIndicators = !m_aCarNodes[CAR_INDICATOR_LF] && !m_aCarNodes[CAR_INDICATOR_2_LF] && m_bIndicatorState[INDICATORS_LEFT] == true;
+		bool bRightFwdLightsLikeIndicators = !m_aCarNodes[CAR_INDICATOR_RF] && !m_aCarNodes[CAR_INDICATOR_2_RF] && m_bIndicatorState[INDICATORS_RIGHT] == true;
+		bool bLeftFwdLightsOn = bLeftFwdLightsLikeIndicators && CTimer::GetTimeInMilliseconds() & 512 || !bLeftFwdLightsLikeIndicators && bLightsOn;
+		bool bRightFwdLightsOn = bRightFwdLightsLikeIndicators && CTimer::GetTimeInMilliseconds() & 512 || !bRightFwdLightsLikeIndicators && bLightsOn;
+
+		bool bLeftBackLightsLikeIndicators = !m_aCarNodes[CAR_INDICATOR_LR] && !m_aCarNodes[CAR_INDICATOR_2_LR] && m_bIndicatorState[INDICATORS_LEFT] == true;
+		bool bRightBackLightsLikeIndicators = !m_aCarNodes[CAR_INDICATOR_RR] && !m_aCarNodes[CAR_INDICATOR_2_RR] && m_bIndicatorState[INDICATORS_RIGHT] == true;
+		bool bLeftBackLightsOn = bLeftBackLightsLikeIndicators && CTimer::GetTimeInMilliseconds() & 512 || !bLeftBackLightsLikeIndicators && bLightsOn;
+		bool bRightBackLightsOn = bRightBackLightsLikeIndicators && CTimer::GetTimeInMilliseconds() & 512 || !bRightBackLightsLikeIndicators && bLightsOn;
+
+		if(bEngineOn && (bLightsOn || bLeftFwdLightsOn || bRightFwdLightsOn || bLeftBackLightsOn || bRightBackLightsOn) || alarmOn || alarmOff) {
+			// Headlights
+		
+			CVector lightR = GetMatrix() * headLightPos;
+			CVector lightL = lightR;
+			lightL -= GetRight()*2.0f*headLightPos.x;
+
+			// Headlight coronas
+			if(DotProduct(lightR-TheCamera.GetPosition(), GetForward()) < 0.0f &&
+			   (TheCamera.Cams[TheCamera.ActiveCam].Mode != CCam::MODE_1STPERSON || this != FindPlayerVehicle())){
+				// In front of car
+				float intensity = -0.5f*behindness + 0.3f;
+				float size = 0.0f - behindness;
+
+				if (!mi->m_positions[CAR_POS_HEADLIGHTS_2].IsZero())
+					size -= 0.3f;
+
+				if(alarmOff){
+					if(GetFrameLightStatus(headlightLeftFrame) == LIGHT_STATUS_OK)
+						CCoronas::RegisterCorona((uintptr)this, 0, 0, 0, 0,
+							lightL, size, 0.0f,
+							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					if(GetFrameLightStatus(headlightRightFrame) == LIGHT_STATUS_OK)
+						CCoronas::RegisterCorona((uintptr)this + 1, 0, 0, 0, 0,
+							lightR, size, 0.0f,
+							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+				}else{
+					if (pHandling->Flags & HANDLING_HALOGEN_LIGHTS) {
+						if (GetFrameLightStatus(headlightLeftFrame) == LIGHT_STATUS_OK && bLeftFwdLightsOn)
+							CCoronas::RegisterCorona((uintptr)this, 190 * intensity, 190 * intensity, 255 * intensity, 255,
+								lightL, size, 50.0f * TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+						if (GetFrameLightStatus(headlightRightFrame) == LIGHT_STATUS_OK && bRightFwdLightsOn)
+							CCoronas::RegisterCorona((uintptr)this + 1, 190 * intensity, 190 * intensity, 255 * intensity, 255,
+								lightR, size, 50.0f * TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					} else {
+						if (GetFrameLightStatus(headlightLeftFrame) == LIGHT_STATUS_OK && bLeftFwdLightsOn)
+							CCoronas::RegisterCorona((uintptr)this, 210 * intensity, 210 * intensity, 195 * intensity, 255,
+								lightL, size, 50.0f * TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+						if (GetFrameLightStatus(headlightRightFrame) == LIGHT_STATUS_OK && bRightFwdLightsOn)
+							CCoronas::RegisterCorona((uintptr)this + 1, 210 * intensity, 210 * intensity, 195 * intensity, 255,
+								lightR, size, 50.0f * TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					}
+				}
+			}else{
+				// Behind car
+				if(GetFrameLightStatus(headlightLeftFrame) == LIGHT_STATUS_OK && bLeftFwdLightsOn)
+					CCoronas::UpdateCoronaCoors((uintptr)this, lightL, 50.0f*TheCamera.LODDistMultiplier, angle);
+				if(GetFrameLightStatus(headlightRightFrame) == LIGHT_STATUS_OK && bRightFwdLightsOn)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 1, lightR, 50.0f*TheCamera.LODDistMultiplier, angle);
+			}
+
+			// Headlights 2
+			if (!mi->m_positions[CAR_POS_HEADLIGHTS_2].IsZero()) {
+				lightR = GetMatrix() * mi->m_positions[CAR_POS_HEADLIGHTS_2];
+				lightL = lightR;
+				lightL -= GetRight()*2.0f*mi->m_positions[CAR_POS_HEADLIGHTS_2].x;
+
+				// Headlight coronas
+				if(DotProduct(lightR-TheCamera.GetPosition(), GetForward()) < 0.0f &&
+				   (TheCamera.Cams[TheCamera.ActiveCam].Mode != CCam::MODE_1STPERSON || this != FindPlayerVehicle())){
+					// In front of car
+					float intensity = -0.5f*behindness + 0.3f;
+					float size = 0.0f - behindness;
+
+					size -= 0.3f;
+
+					if(alarmOff){
+						if(GetFrameLightStatus(headlightLeftFrame) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 26, 0, 0, 0, 0,
+								lightL, size, 0.0f,
+								CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+						if(GetFrameLightStatus(headlightRightFrame) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 27, 0, 0, 0, 0,
+								lightR, size, 0.0f,
+								CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					}else{
+						if (pHandling->Flags & HANDLING_HALOGEN_LIGHTS) {
+							if (GetFrameLightStatus(headlightLeftFrame) == LIGHT_STATUS_OK && bLeftFwdLightsOn)
+								CCoronas::RegisterCorona((uintptr)this + 26, 190 * intensity, 190 * intensity, 255 * intensity, 255,
+									lightL, size, 50.0f * TheCamera.LODDistMultiplier,
+									CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+									CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+							if (GetFrameLightStatus(headlightRightFrame) == LIGHT_STATUS_OK && bRightFwdLightsOn)
+								CCoronas::RegisterCorona((uintptr)this + 27, 190 * intensity, 190 * intensity, 255 * intensity, 255,
+									lightR, size, 50.0f * TheCamera.LODDistMultiplier,
+									CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+									CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+						} else {
+							if (GetFrameLightStatus(headlightLeftFrame) == LIGHT_STATUS_OK && bLeftFwdLightsOn)
+								CCoronas::RegisterCorona((uintptr)this + 26, 210 * intensity, 210 * intensity, 195 * intensity, 255,
+									lightL, size, 50.0f * TheCamera.LODDistMultiplier,
+									CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+									CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+							if (GetFrameLightStatus(headlightRightFrame) == LIGHT_STATUS_OK && bRightFwdLightsOn)
+								CCoronas::RegisterCorona((uintptr)this + 27, 210 * intensity, 210 * intensity, 195 * intensity, 255,
+									lightR, size, 50.0f * TheCamera.LODDistMultiplier,
+									CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+									CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+						}
+					}
+				}else{
+					// Behind car
+					if(GetFrameLightStatus(headlightLeftFrame) == LIGHT_STATUS_OK && bLeftFwdLightsOn)
+						CCoronas::UpdateCoronaCoors((uintptr)this + 26, lightL, 50.0f*TheCamera.LODDistMultiplier, angle);
+					if(GetFrameLightStatus(headlightRightFrame) == LIGHT_STATUS_OK && bRightFwdLightsOn)
+						CCoronas::UpdateCoronaCoors((uintptr)this + 27, lightR, 50.0f*TheCamera.LODDistMultiplier, angle);
+				}
+			}
+
+			// Taillights
+
+			CVector tailLightPos = mi->m_positions[CAR_POS_TAILLIGHTS];
+			lightR = GetMatrix() * tailLightPos;
+			lightL = lightR;
+			lightL -= GetRight()*2.0f*tailLightPos.x;
+
+			// Taillight coronas
+			if(DotProduct(lightR-TheCamera.GetPosition(), GetForward()) > 0.0f){
+				// Behind car
+				float intensity = (behindness + 1.0f)*0.4f;
+				float size = (behindness + 1.0f)*0.5f;
+
+				if (!mi->m_positions[CAR_POS_TAILLIGHTS_2].IsZero() || !mi->m_positions[CAR_POS_BRAKELIGHTS_2].IsZero())
+					size -= 0.3f;
+
+				if(alarmOff){
+					if(GetFrameLightStatus(CAR_TAILLIGHT_L) == LIGHT_STATUS_OK)
+						CCoronas::RegisterCorona((uintptr)this + 14, 0, 0, 0, 0,
+							lightL, size, 0.0f,
+							CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					if(GetFrameLightStatus(CAR_TAILLIGHT_R) == LIGHT_STATUS_OK)
+						CCoronas::RegisterCorona((uintptr)this + 15, 0, 0, 0, 0,
+							lightR, size, 0.0f,
+							CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+				}else{
+					if(GetFrameLightStatus(CAR_TAILLIGHT_L) == LIGHT_STATUS_OK && bLeftBackLightsOn)
+						CCoronas::RegisterCorona((uintptr)this + 14, 128*intensity, 0, 0, 255,
+							lightL, size, 50.0f*TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					if(GetFrameLightStatus(CAR_TAILLIGHT_R) == LIGHT_STATUS_OK && bRightBackLightsOn)
+						CCoronas::RegisterCorona((uintptr)this + 15, 128*intensity, 0, 0, 255,
+							lightR, size, 50.0f*TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+				}
+
+				// Taillights 2
+				CVector tailLight2Pos = mi->m_positions[CAR_POS_TAILLIGHTS_2];
+				if (!tailLight2Pos.IsZero()) {
+					lightR = GetMatrix() * tailLight2Pos;
+					lightL = lightR;
+					lightL -= GetRight() * 2.0f * tailLight2Pos.x;
+					if(alarmOff){
+						if(GetFrameLightStatus(CAR_TAILLIGHT_L) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 28, 0, 0, 0, 0,
+								lightL, size, 0.0f,
+								CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+						if(GetFrameLightStatus(CAR_TAILLIGHT_R) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 29, 0, 0, 0, 0,
+								lightR, size, 0.0f,
+								CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					}else{
+						if(GetFrameLightStatus(CAR_TAILLIGHT_L) == LIGHT_STATUS_OK && bLeftBackLightsOn)
+							CCoronas::RegisterCorona((uintptr)this + 28, 128*intensity, 0, 0, 255,
+								lightL, size, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+						if(GetFrameLightStatus(CAR_TAILLIGHT_R) == LIGHT_STATUS_OK && bRightBackLightsOn)
+							CCoronas::RegisterCorona((uintptr)this + 29, 128*intensity, 0, 0, 255,
+								lightR, size, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					}
+				}
+
+				if (mi->m_positions[CAR_POS_TAILLIGHTS_2].IsZero() || mi->m_positions[CAR_POS_BRAKELIGHTS_2].IsZero())
+					size -= 0.3f;
+
+				// reversing
+				lightR = GetMatrix() * reversingLightPos;
+				lightL = lightR;
+				lightL -= GetRight() * 2.0f * reversingLightPos.x;
+				if (m_fGasPedal < 0.0f) {
+					if (GetFrameLightStatus(reversingLeftFrame) == LIGHT_STATUS_OK)
+						CCoronas::RegisterCorona((uintptr)this + 16, 128 * intensity, 128 * intensity, 128 * intensity, 255,
+							lightL, size, 50.0f * TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					if (GetFrameLightStatus(reversingRightFrame) == LIGHT_STATUS_OK)
+						CCoronas::RegisterCorona((uintptr)this + 17, 128 * intensity, 128 * intensity, 128 * intensity, 255,
+							lightR, size, 50.0f * TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+				} else {
+					if (GetFrameLightStatus(reversingLeftFrame) == LIGHT_STATUS_OK)
+						CCoronas::UpdateCoronaCoors((uintptr)this + 16, lightL, 50.0f, angle);
+					if (GetFrameLightStatus(reversingRightFrame) == LIGHT_STATUS_OK)
+						CCoronas::UpdateCoronaCoors((uintptr)this + 17, lightR, 50.0f, angle);
+				}
+
+				// reversing 2
+				if (!reversingLightPos2.IsZero()) {
+					lightR = GetMatrix() * reversingLightPos2;
+					lightL = lightR;
+					lightL -= GetRight() * 2.0f * reversingLightPos2.x;
+					if (m_fGasPedal < 0.0f) {
+						if (GetFrameLightStatus(reversingLeftFrame) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 24, 128 * intensity, 128 * intensity, 128 * intensity, 255,
+								lightL, size, 50.0f * TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+						if (GetFrameLightStatus(reversingRightFrame) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 33, 128 * intensity, 128 * intensity, 128 * intensity, 255,
+								lightR, size, 50.0f * TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					} else {
+						if (GetFrameLightStatus(reversingLeftFrame) == LIGHT_STATUS_OK)
+							CCoronas::UpdateCoronaCoors((uintptr)this + 24, lightL, 50.0f, angle);
+						if (GetFrameLightStatus(reversingRightFrame) == LIGHT_STATUS_OK)
+							CCoronas::UpdateCoronaCoors((uintptr)this + 33, lightR, 50.0f, angle);
+					}
+				}
+
+				// braking
+				lightR = GetMatrix() * brakeLightPos;
+				lightL = lightR;
+				lightL -= GetRight() * 2.0f * brakeLightPos.x;
+				if (m_fBrakePedal > 0.0f && GetStatus() != STATUS_ABANDONED) {
+					if (GetFrameLightStatus(brakeLeftFrame) == LIGHT_STATUS_OK)
+						CCoronas::RegisterCorona((uintptr)this + 18, 128 * intensity, 0, 0, 255,
+							lightL, size, 50.0f * TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					if (GetFrameLightStatus(brakeRightFrame) == LIGHT_STATUS_OK)
+						CCoronas::RegisterCorona((uintptr)this + 19, 128 * intensity, 0, 0, 255,
+							lightR, size, 50.0f * TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+				} else {
+					if (GetFrameLightStatus(brakeLeftFrame) == LIGHT_STATUS_OK)
+						CCoronas::UpdateCoronaCoors((uintptr)this + 18, lightL, 50.0f, angle);
+					if (GetFrameLightStatus(brakeRightFrame) == LIGHT_STATUS_OK)
+						CCoronas::UpdateCoronaCoors((uintptr)this + 19, lightR, 50.0f, angle);
+				}
+
+				// braking 2
+				if (!brakeLightPos2.IsZero()) {
+					lightR = GetMatrix() * brakeLightPos2;
+					lightL = lightR;
+					lightL -= GetRight() * 2.0f * brakeLightPos.x;
+					if (m_fBrakePedal > 0.0f && GetStatus() != STATUS_ABANDONED) {
+						if (GetFrameLightStatus(brakeLeftFrame) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 30, 128 * intensity, 0, 0, 255,
+								lightL, size, 50.0f * TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+						if (GetFrameLightStatus(brakeRightFrame) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 31, 128 * intensity, 0, 0, 255,
+								lightR, size, 50.0f * TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					} else {
+						if (GetFrameLightStatus(brakeLeftFrame) == LIGHT_STATUS_OK)
+							CCoronas::UpdateCoronaCoors((uintptr)this + 30, lightL, 50.0f, angle);
+						if (GetFrameLightStatus(brakeRightFrame) == LIGHT_STATUS_OK)
+							CCoronas::UpdateCoronaCoors((uintptr)this + 31, lightR, 50.0f, angle);
+					}
+				}
+			}else{
+				// In front of car
+				// missing LODDistMultiplier probably a BUG
+				if(GetFrameLightStatus(CAR_TAILLIGHT_L) == LIGHT_STATUS_OK && bLeftBackLightsOn)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 14, lightL, 50.0f, angle);
+				if(GetFrameLightStatus(CAR_TAILLIGHT_R) == LIGHT_STATUS_OK && bRightBackLightsOn)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 15, lightR, 50.0f, angle);
+				if (GetFrameLightStatus(CAR_TAILLIGHT_L) == LIGHT_STATUS_OK && bLeftBackLightsOn)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 28, lightL, 50.0f, angle);
+				if (GetFrameLightStatus(CAR_TAILLIGHT_R) == LIGHT_STATUS_OK && bRightBackLightsOn)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 29, lightR, 50.0f, angle);
+			}
+
+			// Light shadows
+			// Headlight texture now divided into two parts, reversing lights have texture of light (thanks to Alex_Delphi)
+			if(!alarmOff){
+				CVector2D fwd(GetForward());
+				fwd.Normalise();
+				float f = tailLightPos.y + 2.0f;
+				
+				if(shouldLightsBeOn && m_fGasPedal >= 0.0f && GetFrameLightStatus(CAR_TAILLIGHT_L) == LIGHT_STATUS_OK && bLeftBackLightsOn) {
+					lightL += CVector(f * fwd.x, f * fwd.y, 2.0f);
+					CShadows::StoreCarLightShadow(this, (uintptr)this + 29, gpShadowExplosionTex, &lightL, 1.0f, 0.0f, 0.0f, -1.0f, 35, 0, 0, 4.0f);
+				} else if (shouldLightsBeOn && m_fGasPedal < 0.0f && GetFrameLightStatus(CAR_REVERSINGLIGHT_L) == LIGHT_STATUS_OK) {
+					lightL += CVector(f * fwd.x, f * fwd.y, 2.0f);
+					CShadows::StoreCarLightShadow(this, (uintptr)this + 29, gpShadowExplosionTex, &lightL, 1.0f, 0.0f, 0.0f, -1.0f, 35, 35, 35, 4.0f);
+				}
+
+				if(shouldLightsBeOn && m_fGasPedal >= 0.0f && GetFrameLightStatus(CAR_TAILLIGHT_R) == LIGHT_STATUS_OK && bRightBackLightsOn) {
+					lightR += CVector(f * fwd.x, f * fwd.y, 2.0f);
+					CShadows::StoreCarLightShadow(this, (uintptr)this + 27, gpShadowExplosionTex, &lightR, 1.0f, 0.0f, 0.0f, -1.0f, 35, 0, 0, 4.0f);
+				} else if (shouldLightsBeOn && m_fGasPedal < 0.0f && GetFrameLightStatus(CAR_REVERSINGLIGHT_R) == LIGHT_STATUS_OK) {
+					lightR += CVector(f * fwd.x, f * fwd.y, 2.0f);
+					CShadows::StoreCarLightShadow(this, (uintptr)this + 27, gpShadowExplosionTex, &lightR, 1.0f, 0.0f, 0.0f, -1.0f, 35, 35, 35, 4.0f);
+				}
+
+				lightR = GetMatrix() * headLightPos;
+				lightL = lightR;
+				lightL -= GetRight() * 2.0f * headLightPos.x;
+				f = headLightPos.y + 6.0f;
+				
+				if (GetFrameLightStatus(headlightLeftFrame) == LIGHT_STATUS_OK && bLeftFwdLightsOn) {
+					lightL += CVector(f * fwd.x, f * fwd.y, 2.0f);
+					CShadows::StoreCarLightShadow(this, (uintptr)this + 25, gpShadowHeadLightsTex, &lightL, 8.0f * fwd.x, 8.0f * fwd.y,
+						4.5f * fwd.y, -4.5f * fwd.x, 45, 45, 45, 7.0f);
+				}
+				
+				if(GetFrameLightStatus(headlightRightFrame) == LIGHT_STATUS_OK && bRightFwdLightsOn) {
+					lightR += CVector(f * fwd.x, f * fwd.y, 2.0f);
+					CShadows::StoreCarLightShadow(this, (uintptr)this + 22, gpShadowHeadLightsTex, &lightR, 8.0f * fwd.x, 8.0f * fwd.y,
+					4.5f * fwd.y, -4.5f * fwd.x, 45, 45, 45, 7.0f);
+				}
+			}
+
+			if(this == FindPlayerVehicle() && !alarmOff){
+				if(GetFrameLightStatus(headlightLeftFrame) == LIGHT_STATUS_OK ||
+					GetFrameLightStatus(headlightRightFrame) == LIGHT_STATUS_OK) {
+
+					CPointLights::AddLight(CPointLights::LIGHT_DIRECTIONAL, GetPosition(), GetForward(),
+						20.0f, 1.0f, 1.0f, 1.0f,
+						FindPlayerVehicle()->m_vecMoveSpeed.MagnitudeSqr2D() < sq(0.45f) ? CPointLights::FOG_NORMAL : CPointLights::FOG_NONE,
+						false);
+				}
+				CVector pos = GetPosition() - 4.0f*GetForward();
+				if(m_fBrakePedal > 0.0f && GetFrameLightStatus(CAR_TAILLIGHT_L) == LIGHT_STATUS_OK)
+					CPointLights::AddLight(CPointLights::LIGHT_POINT, pos, CVector(0.0f, 0.0f, 0.0f),
+						10.0f, 0.4f, 0.0f, 0.0f,
+						CPointLights::FOG_NONE, false);
+				else if (m_fBrakePedal <= 0.0f && GetFrameLightStatus(CAR_TAILLIGHT_R) == LIGHT_STATUS_OK)
+					CPointLights::AddLight(CPointLights::LIGHT_POINT, pos, CVector(0.0f, 0.0f, 0.0f),
+						7.0f, 0.2f, 0.0f, 0.0f,
+						CPointLights::FOG_NONE, false);
+			}
+		}else if(GetStatus() != STATUS_ABANDONED && GetStatus() != STATUS_WRECKED){
+			// Lights off
+
+			CVector tailLightPos = mi->m_positions[CAR_POS_TAILLIGHTS];
+			CVector lightR = GetMatrix() * tailLightPos;
+			CVector lightL = lightR;
+			lightL -= GetRight() * 2.0f * tailLightPos.x;
+
+			if(m_fBrakePedal > 0.0f || m_fGasPedal < 0.0f){
+				CVector lookVector = GetPosition() - TheCamera.GetPosition();
+				lookVector.Normalise();
+				float behindness = DotProduct(lookVector, GetForward());
+				if(behindness > 0.0f){
+					if(m_fGasPedal < 0.0f){
+						// reversing
+						lightR = GetMatrix() * reversingLightPos;
+						lightL = lightR;
+						lightL -= GetRight() * 2.0f * reversingLightPos.x;
+						if(GetFrameLightStatus(reversingLeftFrame) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 16, 120, 120, 120, 255,
+								lightL, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, 0.0f);
+						if(GetFrameLightStatus(reversingRightFrame) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 17, 120, 120, 120, 255,
+								lightR, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, 0.0f);
+
+						// reversing 2
+						if (!reversingLightPos2.IsZero()) {
+							lightR = GetMatrix() * reversingLightPos2;
+							lightL = lightR;
+							lightL -= GetRight() * 2.0f * reversingLightPos2.x;
+							if(GetFrameLightStatus(reversingLeftFrame) == LIGHT_STATUS_OK)
+								CCoronas::RegisterCorona((uintptr)this + 24, 120, 120, 120, 255,
+									lightL, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
+									CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+									CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, 0.0f);
+							if(GetFrameLightStatus(reversingRightFrame) == LIGHT_STATUS_OK)
+								CCoronas::RegisterCorona((uintptr)this + 33, 120, 120, 120, 255,
+									lightR, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
+									CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+									CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, 0.0f);
+						}
+					} else {
+						float size = 1.2f;
+						if (!mi->m_positions[CAR_POS_BRAKELIGHTS_2].IsZero())
+							size -= 0.5f;
+
+						// braking
+						lightR = GetMatrix() * brakeLightPos;
+						lightL = lightR;
+						lightL -= GetRight() * 2.0f * brakeLightPos.x;
+						if(GetFrameLightStatus(brakeLeftFrame) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 18, 120, 0, 0, 255,
+								lightL, size, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, 0.0f);
+						if(GetFrameLightStatus(brakeRightFrame) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 19, 120, 0, 0, 255,
+								lightR, size, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, 0.0f);
+
+						// braking 2
+						if (!brakeLightPos2.IsZero()) {
+							lightR = GetMatrix() * brakeLightPos2;
+							lightL = lightR;
+							lightL -= GetRight() * 2.0f * brakeLightPos2.x;
+							if(GetFrameLightStatus(brakeLeftFrame) == LIGHT_STATUS_OK)
+								CCoronas::RegisterCorona((uintptr)this + 30, 120, 0, 0, 255,
+									lightL, size, 50.0f*TheCamera.LODDistMultiplier,
+									CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+									CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, 0.0f);
+							if(GetFrameLightStatus(brakeRightFrame) == LIGHT_STATUS_OK)
+								CCoronas::RegisterCorona((uintptr)this + 31, 120, 0, 0, 255,
+									lightR, size, 50.0f*TheCamera.LODDistMultiplier,
+									CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+									CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, 0.0f);
+						}
+					}
+				}else{
+					if(GetFrameLightStatus(CAR_TAILLIGHT_L) == LIGHT_STATUS_OK)
+						CCoronas::UpdateCoronaCoors((uintptr)this + 14, lightL, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
+					if(GetFrameLightStatus(CAR_TAILLIGHT_R) == LIGHT_STATUS_OK)
+						CCoronas::UpdateCoronaCoors((uintptr)this + 15, lightR, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
+				}
+			}else{
+				if(GetFrameLightStatus(CAR_TAILLIGHT_L) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 14, lightL, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
+				if(GetFrameLightStatus(CAR_TAILLIGHT_R) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 15, lightR, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
+
+				lightR = GetMatrix() * reversingLightPos;
+				lightL = lightR;
+				lightL -= GetRight() * 2.0f * reversingLightPos.x;
+				if (GetFrameLightStatus(reversingLeftFrame) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 16, lightL, 50.0f * TheCamera.LODDistMultiplier, 0.0f);
+				if (GetFrameLightStatus(reversingRightFrame) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 17, lightR, 50.0f * TheCamera.LODDistMultiplier, 0.0f);
+
+				lightR = GetMatrix() * reversingLightPos2;
+				lightL = lightR;
+				lightL -= GetRight() * 2.0f * reversingLightPos2.x;
+				if (GetFrameLightStatus(reversingLeftFrame) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 24, lightL, 50.0f * TheCamera.LODDistMultiplier, 0.0f);
+				if (GetFrameLightStatus(reversingRightFrame) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 33, lightR, 50.0f * TheCamera.LODDistMultiplier, 0.0f);
+
+				lightR = GetMatrix() * brakeLightPos;
+				lightL = lightR;
+				lightL -= GetRight() * 2.0f * brakeLightPos.x;
+				if (GetFrameLightStatus(brakeLeftFrame) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 18, lightL, 50.0f * TheCamera.LODDistMultiplier, 0.0f);
+				if (GetFrameLightStatus(brakeRightFrame) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 19, lightR, 50.0f * TheCamera.LODDistMultiplier, 0.0f);
+
+				lightR = GetMatrix() * brakeLightPos2;
+				lightL = lightR;
+				lightL -= GetRight() * 2.0f * brakeLightPos2.x;
+				if (GetFrameLightStatus(brakeLeftFrame) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 30, lightL, 50.0f * TheCamera.LODDistMultiplier, 0.0f);
+				if (GetFrameLightStatus(brakeRightFrame) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 31, lightR, 50.0f * TheCamera.LODDistMultiplier, 0.0f);
+			}
+		}
+
+		// forward indicators
+		CVector lightR = GetMatrix() * mi->m_positions[CAR_POS_INDICATORS_F];
+		CVector lightL = lightR;
+		lightL -= GetRight() * 2.0f * mi->m_positions[CAR_POS_INDICATORS_F].x;
+		if (DotProduct(lightR - TheCamera.GetPosition(), GetForward()) < 0.0f) {
+			if (m_bIndicatorState[INDICATORS_LEFT] && CTimer::GetTimeInMilliseconds() & 512) {
+				if (GetFrameLightStatus(CAR_INDICATOR_LF) == LIGHT_STATUS_OK)
+					CCoronas::RegisterCorona((uintptr)this + 20, 255, 127, 0, 255,
+						lightL, 0.2f, 50.0f * TheCamera.LODDistMultiplier,
+						CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+			} else {
+				if (GetFrameLightStatus(CAR_INDICATOR_LF) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 20, lightL, 50.0f * TheCamera.LODDistMultiplier, angle);
+			}
+			if (m_bIndicatorState[INDICATORS_RIGHT] && CTimer::GetTimeInMilliseconds() & 512) {
+				if (GetFrameLightStatus(CAR_INDICATOR_RF) == LIGHT_STATUS_OK)
+					CCoronas::RegisterCorona((uintptr)this + 32, 255, 127, 0, 255,
+						lightR, 0.2f, 50.0f * TheCamera.LODDistMultiplier,
+						CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+			} else {
+				if (GetFrameLightStatus(CAR_INDICATOR_RF) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 32, lightR, 50.0f * TheCamera.LODDistMultiplier, angle);
+			}
+		} else {
+			if (GetFrameLightStatus(CAR_INDICATOR_LF) == LIGHT_STATUS_OK)
+				CCoronas::UpdateCoronaCoors((uintptr)this + 20, lightL, 50.0f * TheCamera.LODDistMultiplier, angle);
+			if (GetFrameLightStatus(CAR_INDICATOR_RF) == LIGHT_STATUS_OK)
+				CCoronas::UpdateCoronaCoors((uintptr)this + 32, lightR, 50.0f * TheCamera.LODDistMultiplier, angle);
+		}
+
+		// forward indicators 2
+		if (!mi->m_positions[CAR_POS_INDICATORS_2_F].IsZero()) {
+			lightR = GetMatrix() * mi->m_positions[CAR_POS_INDICATORS_2_F];
+			lightL = lightR;
+			lightL -= GetRight() * 2.0f * mi->m_positions[CAR_POS_INDICATORS_2_F].x;
+			if (DotProduct(lightR - TheCamera.GetPosition(), GetRight()) > 0.0f) {
+				if (m_bIndicatorState[INDICATORS_LEFT] && CTimer::GetTimeInMilliseconds() & 512) {
+					if (GetFrameLightStatus(CAR_INDICATOR_2_LF) == LIGHT_STATUS_OK)
+						CCoronas::RegisterCorona((uintptr)this + 34, 255, 127, 0, 255,
+							lightL, 0.2f, 50.0f * TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+				} else {
+					if (GetFrameLightStatus(CAR_INDICATOR_2_LF) == LIGHT_STATUS_OK)
+						CCoronas::UpdateCoronaCoors((uintptr)this + 34, lightL, 50.0f * TheCamera.LODDistMultiplier, angle);
+				}
+			} else {
+				if (GetFrameLightStatus(CAR_INDICATOR_2_LF) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 34, lightL, 50.0f * TheCamera.LODDistMultiplier, angle);
+			}
+			if (DotProduct(lightR - TheCamera.GetPosition(), GetRight()) < 0.0f) {
+				if (m_bIndicatorState[INDICATORS_RIGHT] && CTimer::GetTimeInMilliseconds() & 512) {
+					if (GetFrameLightStatus(CAR_INDICATOR_2_RF) == LIGHT_STATUS_OK)
+						CCoronas::RegisterCorona((uintptr)this + 35, 255, 127, 0, 255,
+							lightR, 0.2f, 50.0f * TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+				} else {
+					if (GetFrameLightStatus(CAR_INDICATOR_2_RF) == LIGHT_STATUS_OK)
+						CCoronas::UpdateCoronaCoors((uintptr)this + 35, lightR, 50.0f * TheCamera.LODDistMultiplier, angle);
+				}
+			} else {
+				if (GetFrameLightStatus(CAR_INDICATOR_2_RF) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 35, lightR, 50.0f * TheCamera.LODDistMultiplier, angle);
+			}
+		}
+
+		// rear indicators
+		lightR = GetMatrix() * mi->m_positions[CAR_POS_INDICATORS_R];
+		lightL = lightR;
+		lightL -= GetRight() * 2.0f * mi->m_positions[CAR_POS_INDICATORS_R].x;
+		if (DotProduct(lightR - TheCamera.GetPosition(), GetForward()) > 0.0f) {
+			if (m_bIndicatorState[INDICATORS_LEFT] && CTimer::GetTimeInMilliseconds() & 512) {
+				if (GetFrameLightStatus(CAR_INDICATOR_LR) == LIGHT_STATUS_OK)
+					CCoronas::RegisterCorona((uintptr)this + 25, 255, 127, 0, 255,
+						lightL, 0.2f, 50.0f * TheCamera.LODDistMultiplier,
+						CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+			} else {
+				if (GetFrameLightStatus(CAR_INDICATOR_LR) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 25, lightL, 50.0f * TheCamera.LODDistMultiplier, angle);
+			}
+			if (m_bIndicatorState[INDICATORS_RIGHT] && CTimer::GetTimeInMilliseconds() & 512) {
+				if (GetFrameLightStatus(CAR_INDICATOR_RR) == LIGHT_STATUS_OK)
+					CCoronas::RegisterCorona((uintptr)this + 23, 255, 127, 0, 255,
+						lightR, 0.2f, 50.0f * TheCamera.LODDistMultiplier,
+						CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+			} else {
+				if (GetFrameLightStatus(CAR_INDICATOR_RR) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 23, lightR, 50.0f * TheCamera.LODDistMultiplier, angle);
+			}
+		} else {
+			if (GetFrameLightStatus(CAR_INDICATOR_LR) == LIGHT_STATUS_OK)
+				CCoronas::UpdateCoronaCoors((uintptr)this + 25, lightL, 50.0f * TheCamera.LODDistMultiplier, angle);
+			if (GetFrameLightStatus(CAR_INDICATOR_RR) == LIGHT_STATUS_OK)
+				CCoronas::UpdateCoronaCoors((uintptr)this + 23, lightR, 50.0f * TheCamera.LODDistMultiplier, angle);
+		}
+
+		// rear indicators 2
+		if (!mi->m_positions[CAR_POS_INDICATORS_2_R].IsZero()) {
+			lightR = GetMatrix() * mi->m_positions[CAR_POS_INDICATORS_2_R];
+			lightL = lightR;
+			lightL -= GetRight() * 2.0f * mi->m_positions[CAR_POS_INDICATORS_2_R].x;
+			if (DotProduct(lightR - TheCamera.GetPosition(), GetRight()) > 0.0f) {
+				if (m_bIndicatorState[INDICATORS_LEFT] && CTimer::GetTimeInMilliseconds() & 512) {
+					if (GetFrameLightStatus(CAR_INDICATOR_2_LR) == LIGHT_STATUS_OK)
+						CCoronas::RegisterCorona((uintptr)this + 36, 255, 127, 0, 255,
+							lightL, 0.2f, 50.0f * TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+				} else {
+					if (GetFrameLightStatus(CAR_INDICATOR_2_LR) == LIGHT_STATUS_OK)
+						CCoronas::UpdateCoronaCoors((uintptr)this + 36, lightL, 50.0f * TheCamera.LODDistMultiplier, angle);
+				}
+			} else {
+				if (GetFrameLightStatus(CAR_INDICATOR_2_LR) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 36, lightL, 50.0f * TheCamera.LODDistMultiplier, angle);
+			}
+			if (DotProduct(lightR - TheCamera.GetPosition(), GetRight()) < 0.0f) {
+				if (m_bIndicatorState[INDICATORS_RIGHT] && CTimer::GetTimeInMilliseconds() & 512) {
+					if (GetFrameLightStatus(CAR_INDICATOR_2_RR) == LIGHT_STATUS_OK)
+						CCoronas::RegisterCorona((uintptr)this + 37, 255, 127, 0, 255,
+							lightR, 0.2f, 50.0f * TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+				} else {
+					if (GetFrameLightStatus(CAR_INDICATOR_2_RR) == LIGHT_STATUS_OK)
+						CCoronas::UpdateCoronaCoors((uintptr)this + 37, lightR, 50.0f * TheCamera.LODDistMultiplier, angle);
+				}
+			} else {
+				if (GetFrameLightStatus(CAR_INDICATOR_2_RR) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 37, lightR, 50.0f * TheCamera.LODDistMultiplier, angle);
+			}
+		}
+	} else {
+		// default vehicle lights
+
+#ifdef FEATURES_INI // StandardCarsUseTurnSignals
+#endif
+		bool bLeftFwdLightsLikeIndicators = bStandardCarsUseTurnSignals && !m_aCarNodes[CAR_INDICATOR_LF] && !m_aCarNodes[CAR_INDICATOR_2_LF] && m_bIndicatorState[INDICATORS_LEFT] == true;
+		bool bRightFwdLightsLikeIndicators = bStandardCarsUseTurnSignals && !m_aCarNodes[CAR_INDICATOR_RF] && !m_aCarNodes[CAR_INDICATOR_2_RF] && m_bIndicatorState[INDICATORS_RIGHT] == true;
+		bool bLeftFwdLightsOn = bLeftFwdLightsLikeIndicators && CTimer::GetTimeInMilliseconds() & 512 || !bLeftFwdLightsLikeIndicators && bLightsOn;
+		bool bRightFwdLightsOn = bRightFwdLightsLikeIndicators && CTimer::GetTimeInMilliseconds() & 512 || !bRightFwdLightsLikeIndicators && bLightsOn;
+
+		bool bLeftBackLightsLikeIndicators = bStandardCarsUseTurnSignals && !m_aCarNodes[CAR_INDICATOR_LR] && !m_aCarNodes[CAR_INDICATOR_2_LR] && m_bIndicatorState[INDICATORS_LEFT] == true;
+		bool bRightBackLightsLikeIndicators = bStandardCarsUseTurnSignals && !m_aCarNodes[CAR_INDICATOR_RR] && !m_aCarNodes[CAR_INDICATOR_2_RR] && m_bIndicatorState[INDICATORS_RIGHT] == true;
+		bool bLeftBackLightsOn = bLeftBackLightsLikeIndicators && CTimer::GetTimeInMilliseconds() & 512 || !bLeftBackLightsLikeIndicators && bLightsOn;
+		bool bRightBackLightsOn = bRightBackLightsLikeIndicators && CTimer::GetTimeInMilliseconds() & 512 || !bRightBackLightsLikeIndicators && bLightsOn;
+
+		if (bEngineOn && (bLightsOn || bLeftFwdLightsOn || bRightFwdLightsOn || bLeftBackLightsOn || bRightBackLightsOn) || alarmOn || alarmOff) {
+			CVector lookVector = GetPosition() - TheCamera.GetPosition();
+			float camDist = lookVector.Magnitude();
+			if(camDist != 0.0f)
+				lookVector *= 1.0f/camDist;
+			else
+				lookVector = CVector(1.0f, 0.0f, 0.0f);
+
+			// 1.0 if directly behind car, -1.0 if in front
+			float behindness = DotProduct(lookVector, GetForward());
+			behindness = Clamp(behindness, -1.0f, 1.0f);	// shouldn't be necessary
+			// 0.0 if behind car, PI if in front
+			// Abs not necessary
+			float angle = Abs(Acos(behindness));
+
+			// Headlights
+
+			CVector headLightPos = mi->m_positions[CAR_POS_HEADLIGHTS];
+			CVector lightR = GetMatrix() * headLightPos;
+			CVector lightL = lightR;
+			lightL -= GetRight()*2.0f*headLightPos.x;
+
+			// Headlight coronas
+			if(DotProduct(lightR-TheCamera.GetPosition(), GetForward()) < 0.0f &&
+			   (TheCamera.Cams[TheCamera.ActiveCam].Mode != CCam::MODE_1STPERSON || this != FindPlayerVehicle())){
+				// In front of car
+				float intensity = -0.5f*behindness + 0.3f;
+				float size = 1.0f - behindness;
+
+				if(behindness < -0.97f && camDist < 30.0f){
+					// Directly in front and not too far away
+					if(pHandling->Flags & HANDLING_HALOGEN_LIGHTS){
+						if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK && bLeftFwdLightsOn)
+							CCoronas::RegisterCorona((uintptr)this + 6, 150, 150, 195, 255,
+								lightL, 1.2f, 45.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_HEADLIGHT, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+						if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK && bRightFwdLightsOn)
+							CCoronas::RegisterCorona((uintptr)this + 7, 150, 150, 195, 255,
+								lightR, 1.2f, 45.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_HEADLIGHT, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					}else{
+						if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK && bLeftFwdLightsOn)
+							CCoronas::RegisterCorona((uintptr)this + 6, 160, 160, 140, 255,
+								lightL, 1.2f, 45.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_HEADLIGHT, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+						if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK && bRightFwdLightsOn)
+							CCoronas::RegisterCorona((uintptr)this + 7, 160, 160, 140, 255,
+								lightR, 1.2f, 45.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_HEADLIGHT, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					}
+				}
+
+				if(alarmOff){
+					if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK)
+						CCoronas::RegisterCorona((uintptr)this, 0, 0, 0, 0,
+							lightL, size, 0.0f,
+							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
+						CCoronas::RegisterCorona((uintptr)this + 1, 0, 0, 0, 0,
+							lightR, size, 0.0f,
+							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+				}else{
+					if(pHandling->Flags & HANDLING_HALOGEN_LIGHTS){
+						if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK && bLeftFwdLightsOn)
+							CCoronas::RegisterCorona((uintptr)this, 190*intensity, 190*intensity, 255*intensity, 255,
+								lightL, size, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+						if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK && bRightFwdLightsOn)
+							CCoronas::RegisterCorona((uintptr)this + 1, 190*intensity, 190*intensity, 255*intensity, 255,
+								lightR, size, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					}else{
+						if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK && bLeftFwdLightsOn)
+							CCoronas::RegisterCorona((uintptr)this, 210*intensity, 210*intensity, 195*intensity, 255,
+								lightL, size, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+						if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK && bRightFwdLightsOn)
+							CCoronas::RegisterCorona((uintptr)this + 1, 210*intensity, 210*intensity, 195*intensity, 255,
+								lightR, size, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					}
+				}
+			}else{
+				// Behind car
+				if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK && bLeftFwdLightsOn)
+					CCoronas::UpdateCoronaCoors((uintptr)this, lightL, 50.0f*TheCamera.LODDistMultiplier, angle);
+				if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK && bRightFwdLightsOn)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 1, lightR, 50.0f*TheCamera.LODDistMultiplier, angle);
+			}
+
+			// Taillights
+
+			CVector tailLightPos = mi->m_positions[CAR_POS_TAILLIGHTS];
+			lightR = GetMatrix() * tailLightPos;
+			lightL = lightR;
+			lightL -= GetRight()*2.0f*tailLightPos.x;
+
+			// Taillight coronas
+			if(DotProduct(lightR-TheCamera.GetPosition(), GetForward()) > 0.0f){
+				// Behind car
+				float intensity = (behindness + 1.0f)*0.4f;
+				float size = (behindness + 1.0f)*0.5f;
+
+				if(m_fGasPedal < 0.0f){
+					// reversing
+					intensity += 0.4f;
+					size += 0.3f;
+
+					if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK && bLeftBackLightsOn)
+						CCoronas::RegisterCorona((uintptr)this + 14, 128*intensity, 128*intensity, 128*intensity, 255,
+							lightL, size, 50.0f*TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK && bRightBackLightsOn)
+						CCoronas::RegisterCorona((uintptr)this + 15, 128*intensity, 128*intensity, 128*intensity, 255,
+							lightR, size, 50.0f*TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+				}else{
+					if (m_fBrakePedal > 0.0f) {
+						intensity += 0.4f;
+						size += 0.3f;
+					}
+
+					if(alarmOff){
+						if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 14, 0, 0, 0, 0,
+								lightL, size, 0.0f,
+								CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+						if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 15, 0, 0, 0, 0,
+								lightR, size, 0.0f,
+								CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					}else{
+						if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK && bLeftBackLightsOn)
+							CCoronas::RegisterCorona((uintptr)this + 14, 128*intensity, 0, 0, 255,
+								lightL, size, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+						if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK && bRightBackLightsOn)
+							CCoronas::RegisterCorona((uintptr)this + 15, 128*intensity, 0, 0, 255,
+								lightR, size, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					}
+				}
+			}else{
+				// In front of car
+				// missing LODDistMultiplier probably a BUG
+				if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK && bLeftBackLightsOn)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 14, lightL, 50.0f, angle);
+				if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK && bRightBackLightsOn)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 15, lightR, 50.0f, angle);
+			}
+
+			// Light shadows
+			// Headlight texture now divided into two parts, reversing lights have texture of light (thanks to Alex_Delphi)
+			if(!alarmOff){
+				CVector2D fwd(GetForward());
+				fwd.Normalise();
+				float f = tailLightPos.y + 2.0f;
+				if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK) {
+					lightL += CVector(f * fwd.x, f * fwd.y, 2.0f);
+					if(m_fGasPedal < 0.0f && bLeftBackLightsOn) // reversing
+						CShadows::StoreCarLightShadow(this, (uintptr)this + 29, gpShadowExplosionTex, &lightL, 1.0f, 0.0f, 0.0f, -1.0f, 35, 35, 35, 4.0f);
+					else if(m_fGasPedal >= 0.0f && bLeftBackLightsOn)
+						CShadows::StoreCarLightShadow(this, (uintptr)this + 29, gpShadowExplosionTex, &lightL, 1.0f, 0.0f, 0.0f, -1.0f, 35, 0, 0, 4.0f);
+				}
+				if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK) {
+					lightR += CVector(f * fwd.x, f * fwd.y, 2.0f);
+					if(m_fGasPedal < 0.0f && bRightBackLightsOn) // reversing
+						CShadows::StoreCarLightShadow(this, (uintptr)this + 27, gpShadowExplosionTex, &lightR, 1.0f, 0.0f, 0.0f, -1.0f, 35, 35, 35, 4.0f);
+					else if(m_fGasPedal >= 0.0f && bRightBackLightsOn)
+						CShadows::StoreCarLightShadow(this, (uintptr)this + 27, gpShadowExplosionTex, &lightR, 1.0f, 0.0f, 0.0f, -1.0f, 35, 0, 0, 4.0f);
+				}
+
+				lightR = GetMatrix() * headLightPos;
+				lightL = lightR;
+				lightL -= GetRight() * 2.0f * headLightPos.x;
+				f = headLightPos.y + 6.0f;			
+				if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK && bLeftFwdLightsOn) {
+					lightL += CVector(f * fwd.x, f * fwd.y, 2.0f);
+					CShadows::StoreCarLightShadow(this, (uintptr)this + 25, gpShadowHeadLightsTex, &lightL, 8.0f * fwd.x, 8.0f * fwd.y,
+					4.5f * fwd.y, -4.5f * fwd.x, 45, 45, 45, 7.0f);
+				}
+				if(Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK && bRightFwdLightsOn) {
+					lightR += CVector(f * fwd.x, f * fwd.y, 2.0f);
+					CShadows::StoreCarLightShadow(this, (uintptr)this + 22, gpShadowHeadLightsTex, &lightR, 8.0f * fwd.x, 8.0f * fwd.y,
+					4.5f * fwd.y, -4.5f * fwd.x, 45, 45, 45, 7.0f);
+				}
+			}
+
+			if(this == FindPlayerVehicle() && !alarmOff){
+				if(Damage.GetLightStatus(VEHLIGHT_FRONT_LEFT) == LIGHT_STATUS_OK ||
+				   Damage.GetLightStatus(VEHLIGHT_FRONT_RIGHT) == LIGHT_STATUS_OK)
+					CPointLights::AddLight(CPointLights::LIGHT_DIRECTIONAL, GetPosition(), GetForward(),
+						20.0f, 1.0f, 1.0f, 1.0f,
+						FindPlayerVehicle()->m_vecMoveSpeed.MagnitudeSqr2D() < sq(0.45f) ? CPointLights::FOG_NORMAL : CPointLights::FOG_NONE,
+						false);
+				CVector pos = GetPosition() - 4.0f*GetForward();
+				if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK ||
+				   Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK) {
+					if(m_fBrakePedal > 0.0f)
+						CPointLights::AddLight(CPointLights::LIGHT_POINT, pos, CVector(0.0f, 0.0f, 0.0f),
+							10.0f, 1.0f, 0.0f, 0.0f,
+							CPointLights::FOG_NONE, false);
+					else
+						CPointLights::AddLight(CPointLights::LIGHT_POINT, pos, CVector(0.0f, 0.0f, 0.0f),
+							7.0f, 0.6f, 0.0f, 0.0f,
+							CPointLights::FOG_NONE, false);
+				}
+			}
+		}else if(GetStatus() != STATUS_ABANDONED && GetStatus() != STATUS_WRECKED){
+			// Lights off
+
+			CVector lightPos = mi->m_positions[CAR_POS_TAILLIGHTS];
+			CVector lightR = GetMatrix() * lightPos;
+			CVector lightL = lightR;
+			lightL -= GetRight()*2.0f*lightPos.x;
+
+			if(m_fBrakePedal > 0.0f || m_fGasPedal < 0.0f){
+				CVector lookVector = GetPosition() - TheCamera.GetPosition();
+				lookVector.Normalise();
+				float behindness = DotProduct(lookVector, GetForward());
+				if(behindness > 0.0f){
+					if(m_fGasPedal < 0.0f){
+						// reversing
+						if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 16, 120, 120, 120, 255,
+								lightL, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, 0.0f);
+						if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 17, 120, 120, 120, 255,
+								lightR, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, 0.0f);
+					}else{
+						// braking
+						if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 18, 120, 0, 0, 255,
+								lightL, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, 0.0f);
+						if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
+							CCoronas::RegisterCorona((uintptr)this + 19, 120, 0, 0, 255,
+								lightR, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
+								CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+								CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, 0.0f);
+					}
+				}else{
+					if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
+						CCoronas::UpdateCoronaCoors((uintptr)this + 14, lightL, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
+					if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
+						CCoronas::UpdateCoronaCoors((uintptr)this + 15, lightR, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
+				}
+			}else{
+				if(Damage.GetLightStatus(VEHLIGHT_REAR_LEFT) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 14, lightL, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
+				if(Damage.GetLightStatus(VEHLIGHT_REAR_RIGHT) == LIGHT_STATUS_OK)
+					CCoronas::UpdateCoronaCoors((uintptr)this + 15, lightR, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
+			}
+		}
+	}
+}
+
+void CAutomobile::SetFrameLightStatus(eCarNodes frameNode, eLightStatus status)
+{
+	if (!m_aCarNodes[frameNode])
+		return;
+
+	if (GetFrameLightStatus(frameNode) == status)
+		return;
+
+	if (status == LIGHT_STATUS_BROKEN)
+		DMAudio.PlayOneShot(m_audioEntityId, SOUND_CAR_LIGHT_BREAK, 0.0f);
+
+	RpAtomic* lightAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[frameNode]);
+
+	if (!lightAtomic)
+		return;
+
+	RpAtomicSetFlags(lightAtomic, LIGHT_STATUS_OK ? rpATOMICRENDER : 0);
+}
+
+eLightStatus CAutomobile::GetFrameLightStatus(eCarNodes frameNode)
+{
+	if (!m_aCarNodes[frameNode])
+		return LIGHT_STATUS_BROKEN;
+
+	eLightStatus status = LIGHT_STATUS_OK;
+
+	RpAtomic* lightAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[frameNode]);
+	if (lightAtomic)
+		if (RpAtomicGetFlags(lightAtomic) == 0)
+			status = LIGHT_STATUS_BROKEN;
+
+	return status;
+}
+#endif
+
+#if defined VEHICLE_MODS && defined IMPROVED_VEHICLES
+void CAutomobile::TrySetRandomCarMod(bool bForce)
+{
+#ifdef EX_RANDOM_VEHICLE_MODS_IN_TRAFFIC
+	if (!bRandomVehicleModsInTraffic)
+		return;
+#endif
+
+	if (!CGarages::IsCarModifiable(this))
+		return;
+
+	if (!bForce && CGeneral::GetRandomNumberInRange(0.0f, 1.0f) < 0.93f)
+		return;
+	
+	if (CGeneral::GetRandomNumberInRange(0.0f, 1.0f) < 0.5f) {
+		m_nWindowTintLevel = CGeneral::GetRandomNumberInRange(1, 5);
+		m_nTempWindowTintLevel = m_nWindowTintLevel;
+	}
+
+	if (CGeneral::GetRandomNumberInRange(0.0f, 1.0f) < 0.5f) {
+		m_nAddSuspensionForceLevel = CGeneral::GetRandomNumberInRange(0.0f, 0.5f);
+		m_nTempAddSuspensionForceLevel = m_nAddSuspensionForceLevel;
+	}
+
+	if (bForce || CGeneral::GetRandomNumberInRange(0.0f, 1.0f) < 0.5f) {
+		int wheels[] = { MI_WHEEL_RIM, MI_WHEEL_OFFROAD, MI_WHEEL_TRUCK, MI_WHEEL_SPORT, 
+						 MI_WHEEL_SALOON, MI_WHEEL_LIGHTVAN, MI_WHEEL_CLASSIC, MI_WHEEL_ALLOY,
+						 MI_WHEEL_LIGHTTRUCK, MI_WHEEL_SMALLCAR, 
+						 MI_WHEEL_CLASSIC2, MI_WHEEL_SALOON2, MI_WHEEL_LIGHTTRUCK2, MI_WHEEL_OFFROAD2, MI_WHEEL_SALOON3, 
+						 MI_WHEEL_16, MI_WHEEL_17, MI_WHEEL_18, MI_WHEEL_19, MI_WHEEL_20, MI_WHEEL_21, MI_WHEEL_22, MI_WHEEL_23, 
+						 MI_WHEEL_24, MI_WHEEL_25, MI_WHEEL_26, MI_WHEEL_27, MI_WHEEL_28, MI_WHEEL_29, MI_WHEEL_30, };
+		
+		//SetWheels(wheels[CGeneral::GetRandomNumberInRange(0, MAXWHEELMODELS)]);
+		SetWheels(wheels[CGeneral::GetRandomNumberInRange(0, Config::MAX_WHEELMODELS)]);
+	}
+
+	if (bForce || CGeneral::GetRandomNumberInRange(0.0f, 1.0f) < 0.5f) {
+		int colorID = CGeneral::GetRandomNumberInRange(0, 94);
+		m_currentColour1 = colorID;
+		m_currentColour2 = colorID;
+		m_currentColour3 = colorID;
+		m_currentColour4 = colorID;
+		m_nTempColor1 = colorID;
+		m_nTempColor2 = colorID;
+		m_nTempColor3 = colorID;
+		m_nTempColor4 = colorID;
+	}
+
+	if (bForce || CGeneral::GetRandomNumberInRange(0.0f, 1.0f) < 0.5f) {
+		int colorID = CGeneral::GetRandomNumberInRange(0, 94);
+		m_nRimsColor = colorID;
+		m_nTempRimsColor = colorID;
+	}
+
+	if (bForce || CGeneral::GetRandomNumberInRange(0.0f, 1.0f) < 0.5f) {
+		int colorID = CGeneral::GetRandomNumberInRange(0, 94);
+		m_nSpoilerColor = colorID;
+		m_nTempSpoilerColor = colorID;
+	}
+
+	if (bForce || CGeneral::GetRandomNumberInRange(0.0f, 1.0f) < 0.5f) {
+		int upgradeID = CGeneral::GetRandomNumberInRange(MI_SPOILER_1, MI_SPOILER_9);
+		SetUpgrade(upgradeID, false);
+	}
+
+	if (bForce || CGeneral::GetRandomNumberInRange(0.0f, 1.0f) < 0.5f) {
+		int upgradeID = CGeneral::GetRandomNumberInRange(MI_BNT_SCOOP_1, MI_BNT_SCOOP_4);
+		SetUpgrade(upgradeID, false);
+	}
+
+	if (bForce || CGeneral::GetRandomNumberInRange(0.0f, 1.0f) < 0.5f) {
+		SetUpgrade(MI_SIDE_SKIRT_L_1, false);
+	}
+
+	if (bForce || CGeneral::GetRandomNumberInRange(0.0f, 1.0f) < 0.5f) {
+		SetUpgrade(MI_RF_SCOOP_1, false);
+	}
+
+	if (bForce || CGeneral::GetRandomNumberInRange(0.0f, 1.0f) < 0.5f) {
+		if (CGeneral::GetRandomNumberInRange(0.0f, 1.0f) < 0.5f)
+			SetUpgrade(MI_BNT_VENT_L_1, false);
+		else
+			SetUpgrade(MI_BNT_VENT_L_2, false);
+	}
+}
+
+void CAutomobile::SetWheels(int modelIndex)
+{
+	SetWheelNumber(modelIndex);
+
+	for (int nodeID = CAR_WHEEL_RF; nodeID <= CAR_WHEEL_LB; nodeID++) {
+		if (!m_aCarNodes[nodeID])
+			continue;
+
+		RpAtomic* wheelAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[nodeID], GetCurrentAtomicObjectCB, &wheelAtomic);
+
+		if (!wheelAtomic)
+			continue;
+
+		RpAtomic* newWheelAtomic = (RpAtomic*)CModelInfo::GetModelInfo(modelIndex)->CreateInstance();
+
+		if (!newWheelAtomic)
+			continue;
+
+		RpClumpRemoveAtomic(GetClump(), wheelAtomic);
+		RpAtomicDestroy(wheelAtomic);
+
+		RwFrameDestroy(RpAtomicGetFrame(newWheelAtomic));
+		RpAtomicSetFrame(newWheelAtomic, m_aCarNodes[nodeID]);
+		RpClumpAddAtomic(GetClump(), newWheelAtomic);
+	}
+}
+void CAutomobile::SetWheelNumber(int modelIndex)
+{
+	switch (modelIndex) {
+		case MI_WHEEL_RIM:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 1;
+			break;
+		case MI_WHEEL_OFFROAD:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 2;
+			break;
+		case MI_WHEEL_TRUCK:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 3;
+			break;
+		case MI_WHEEL_SPORT:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 4;
+			break;
+		case MI_WHEEL_SALOON:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 5;
+			break;
+		case MI_WHEEL_LIGHTVAN:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 6;
+			break;
+		case MI_WHEEL_CLASSIC:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 7;
+			break;
+		case MI_WHEEL_ALLOY:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 8;
+			break;
+		case MI_WHEEL_LIGHTTRUCK:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 9;
+			break;
+		case MI_WHEEL_SMALLCAR:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 10;
+			break;
+		case MI_WHEEL_CLASSIC2:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 11;
+			break;
+		case MI_WHEEL_SALOON2:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 12;
+			break;
+		case MI_WHEEL_LIGHTTRUCK2:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 13;
+			break;
+		case MI_WHEEL_OFFROAD2:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 14;
+			break;
+		case MI_WHEEL_SALOON3:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 15;
+			break;
+		case MI_WHEEL_16:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 16;
+			break;
+		case MI_WHEEL_17:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 17;
+			break;
+		case MI_WHEEL_18:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 18;
+			break;
+		case MI_WHEEL_19:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 19;
+			break;
+		case MI_WHEEL_20:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 20;
+			break;
+		case MI_WHEEL_21:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 21;
+			break;
+		case MI_WHEEL_22:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 22;
+			break;
+		case MI_WHEEL_23:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 23;
+			break;
+		case MI_WHEEL_24:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 24;
+			break;
+		case MI_WHEEL_25:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 25;
+			break;
+		case MI_WHEEL_26:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 26;
+			break;
+		case MI_WHEEL_27:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 27;
+			break;
+		case MI_WHEEL_28:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 28;
+			break;
+		case MI_WHEEL_29:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 29;
+			break;
+		case MI_WHEEL_30:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 30;
+			break;
+		default:
+			m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber = 1;
+			break;
+	}
+}
+
+int CAutomobile::GetWheelModelIndexFromWheelNumber()
+{
+	switch (m_aUpgrades[UPGRADE_WHEELS].m_nUpgradeNumber) {
+		case 1:
+			return MI_WHEEL_RIM;
+		case 2:
+			return MI_WHEEL_OFFROAD;
+		case 3:
+			return MI_WHEEL_TRUCK;
+		case 4:
+			return MI_WHEEL_SPORT;
+		case 5:
+			return MI_WHEEL_SALOON;
+		case 6:
+			return MI_WHEEL_LIGHTVAN;
+		case 7:
+			return MI_WHEEL_CLASSIC;
+		case 8:
+			return MI_WHEEL_ALLOY;
+		case 9:
+			return MI_WHEEL_LIGHTTRUCK;
+		case 10:
+			return MI_WHEEL_SMALLCAR;
+		case 11:
+			return MI_WHEEL_CLASSIC2;
+		case 12:
+			return MI_WHEEL_SALOON2;
+		case 13:
+			return MI_WHEEL_LIGHTTRUCK2;
+		case 14:
+			return MI_WHEEL_OFFROAD2;
+		case 15:
+			return MI_WHEEL_SALOON3;
+		case 16:
+			return MI_WHEEL_16;
+		case 17:
+			return MI_WHEEL_17;
+		case 18:
+			return MI_WHEEL_18;
+		case 19:
+			return MI_WHEEL_19;
+		case 20:
+			return MI_WHEEL_20;
+		case 21:
+			return MI_WHEEL_21;
+		case 22:
+			return MI_WHEEL_22;
+		case 23:
+			return MI_WHEEL_23;
+		case 24:
+			return MI_WHEEL_24;
+		case 25:
+			return MI_WHEEL_25;
+		case 26:
+			return MI_WHEEL_26;
+		case 27:
+			return MI_WHEEL_27;
+		case 28:
+			return MI_WHEEL_28;
+		case 29:
+			return MI_WHEEL_29;
+		case 30:
+			return MI_WHEEL_30;
+		default:
+			return MI_WHEEL_RIM;
+	}
+}
+
+RwObject* GetOkAtomicObjectCB(RwObject* object, void* data)
+{
+	RpAtomic* atomic = (RpAtomic*)object;
+	if (CVisibilityPlugins::GetAtomicId(atomic) & ATOMIC_FLAG_OK)
+		((RpAtomic**)data)[0] = atomic;
+	return object;
+}
+
+RwObject* GetDamAtomicObjectCB(RwObject* object, void* data)
+{
+	RpAtomic* atomic = (RpAtomic*)object;
+	if (CVisibilityPlugins::GetAtomicId(atomic) & ATOMIC_FLAG_DAM)
+		((RpAtomic**)data)[0] = atomic;
+	return object;
+}
+
+void CAutomobile::SetUpgrade(int modelIndex, bool temporary)
+{
+	CMatrix mat;
+
+	// spoilers
+	if (modelIndex >= MI_SPOILER_1 && modelIndex <= MI_SPOILER_9) {
+		if (!m_aCarNodes[CAR_SPOILER_OK] && !m_aCarNodes[CAR_SPOILER_DAM])
+			return;
+
+		RpAtomic* newOkUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(modelIndex)->CreateInstance();
+		RpAtomic* newDamUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(modelIndex)->CreateInstance();
+
+		if (!newOkUpgradeAtomic || !newDamUpgradeAtomic)
+			return;
+
+		RwFrameDestroy(RpAtomicGetFrame(newOkUpgradeAtomic));
+		RwFrameDestroy(RpAtomicGetFrame(newDamUpgradeAtomic));
+
+		// ok upgrade
+		RpAtomic* currentOkUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SPOILER_OK]);
+
+		if (currentOkUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentOkUpgradeAtomic);
+			RpAtomicDestroy(currentOkUpgradeAtomic);
+		}
+
+		RpAtomicSetFrame(newOkUpgradeAtomic, m_aCarNodes[CAR_SPOILER_OK]);
+		RpClumpAddAtomic(GetClump(), newOkUpgradeAtomic);
+
+		CVehicleModelInfo::SetEnvironmentMapCB(newOkUpgradeAtomic, nil);
+
+		mat.Attach(RwFrameGetMatrix(m_aCarNodes[CAR_SPOILER_OK]));
+		mat.UpdateRW();
+
+		if (m_aCarNodes[CAR_SPOILER_DAM]) {
+			CVisibilityPlugins::SetAtomicFlag(newOkUpgradeAtomic, ATOMIC_FLAG_OK);
+			if (Damage.GetDoorStatus(DOOR_BOOT) == DOOR_STATUS_SMASHED)
+				RpAtomicSetFlags(newOkUpgradeAtomic, 0);
+
+			// dam upgrade
+			RpAtomic* currentDamUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SPOILER_DAM]);
+
+			if (currentDamUpgradeAtomic) {
+				RpClumpRemoveAtomic(GetClump(), currentDamUpgradeAtomic);
+				RpAtomicDestroy(currentDamUpgradeAtomic);
+			}
+
+			RpAtomicSetFrame(newDamUpgradeAtomic, m_aCarNodes[CAR_SPOILER_DAM]);
+			RpClumpAddAtomic(GetClump(), newDamUpgradeAtomic);
+
+			CVehicleModelInfo::SetEnvironmentMapCB(newDamUpgradeAtomic, nil);
+
+			mat.Attach(RwFrameGetMatrix(m_aCarNodes[CAR_SPOILER_DAM]));
+			mat.UpdateRW();
+
+			CVisibilityPlugins::SetAtomicFlag(newDamUpgradeAtomic, ATOMIC_FLAG_DAM);
+			if (Damage.GetDoorStatus(DOOR_BOOT) == DOOR_STATUS_OK)
+				RpAtomicSetFlags(newDamUpgradeAtomic, 0);
+		}
+
+		if (!temporary) {
+			m_aUpgrades[UPGRADE_SPOILER].m_nUpgradeModelIndex = modelIndex;
+			m_aUpgrades[UPGRADE_SPOILER].m_nTempUpgradeModelIndex = modelIndex;
+			m_aUpgrades[UPGRADE_SPOILER].m_nUpgradeNumber = (modelIndex + 1) - MI_SPOILER_1;
+		}
+
+		return;
+	}
+
+	// side skirts
+	if (modelIndex >= MI_SIDE_SKIRT_L_1 && modelIndex <= MI_SIDE_SKIRT_R_1) {
+		if (!m_aCarNodes[CAR_SKIRT_L] || !m_aCarNodes[CAR_SKIRT_R])
+			return;
+
+		RpAtomic* newLeftUpgradeAtomic = nil;
+		RpAtomic* newRightUpgradeAtomic = nil;
+		if (modelIndex == MI_SIDE_SKIRT_L_1 || modelIndex == MI_SIDE_SKIRT_R_1) {
+			newLeftUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(MI_SIDE_SKIRT_L_1)->CreateInstance();
+			newRightUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(MI_SIDE_SKIRT_R_1)->CreateInstance();
+		}
+
+		if (!newLeftUpgradeAtomic || !newRightUpgradeAtomic)
+			return;
+
+		RwFrameDestroy(RpAtomicGetFrame(newLeftUpgradeAtomic));
+		RwFrameDestroy(RpAtomicGetFrame(newRightUpgradeAtomic));
+
+		RpAtomic* currentLeftUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SKIRT_L]);
+		RpAtomic* currentRightUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SKIRT_R]);
+		if (currentLeftUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentLeftUpgradeAtomic);
+			RpAtomicDestroy(currentLeftUpgradeAtomic);
+		}
+		if (currentRightUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentRightUpgradeAtomic);
+			RpAtomicDestroy(currentRightUpgradeAtomic);
+		}
+
+		RpAtomicSetFrame(newLeftUpgradeAtomic, m_aCarNodes[CAR_SKIRT_L]);
+		RpClumpAddAtomic(GetClump(), newLeftUpgradeAtomic);
+
+		RpAtomicSetFrame(newRightUpgradeAtomic, m_aCarNodes[CAR_SKIRT_R]);
+		RpClumpAddAtomic(GetClump(), newRightUpgradeAtomic);
+
+		CVehicleModelInfo::SetEnvironmentMapCB(newLeftUpgradeAtomic, nil);
+		CVehicleModelInfo::SetEnvironmentMapCB(newRightUpgradeAtomic, nil);
+
+		mat.Attach(RwFrameGetMatrix(m_aCarNodes[CAR_SKIRT_L]));
+		mat.UpdateRW();
+
+		mat.Attach(RwFrameGetMatrix(m_aCarNodes[CAR_SKIRT_R]));
+		mat.UpdateRW();
+
+		if (!temporary) {
+			m_aUpgrades[UPGRADE_SKIRTS].m_nUpgradeModelIndex = modelIndex;
+			m_aUpgrades[UPGRADE_SKIRTS].m_nTempUpgradeModelIndex = modelIndex;
+			if (modelIndex == MI_SIDE_SKIRT_L_1 || modelIndex == MI_SIDE_SKIRT_R_1)
+				m_aUpgrades[UPGRADE_SKIRTS].m_nUpgradeNumber = 1;
+		}
+
+		return;
+	}
+
+	// bonnet scoop
+	if (modelIndex >= MI_BNT_SCOOP_1 && modelIndex <= MI_BNT_SCOOP_4) {
+		if (!m_aCarNodes[CAR_BNT_SCOOP_OK] || !m_aCarNodes[CAR_BNT_SCOOP_DAM])
+			return;
+
+		RpAtomic* newOkUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(modelIndex)->CreateInstance();
+		RpAtomic* newDamUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(modelIndex)->CreateInstance();
+
+		if (!newOkUpgradeAtomic || !newDamUpgradeAtomic)
+			return;
+
+		RwFrameDestroy(RpAtomicGetFrame(newOkUpgradeAtomic));
+		RwFrameDestroy(RpAtomicGetFrame(newDamUpgradeAtomic));
+
+		// ok upgrade
+		RpAtomic* currentOkUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_OK]);
+		if (currentOkUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentOkUpgradeAtomic);
+			RpAtomicDestroy(currentOkUpgradeAtomic);
+		}
+
+		RpAtomicSetFrame(newOkUpgradeAtomic, m_aCarNodes[CAR_BNT_SCOOP_OK]);
+		RpClumpAddAtomic(GetClump(), newOkUpgradeAtomic);
+
+		CVehicleModelInfo::SetEnvironmentMapCB(newOkUpgradeAtomic, nil);
+
+		mat.Attach(RwFrameGetMatrix(m_aCarNodes[CAR_BNT_SCOOP_OK]));
+		mat.UpdateRW();
+
+		CVisibilityPlugins::SetAtomicFlag(newOkUpgradeAtomic, ATOMIC_FLAG_OK);
+		if (Damage.GetDoorStatus(DOOR_BONNET) == DOOR_STATUS_SMASHED)
+			RpAtomicSetFlags(newOkUpgradeAtomic, 0);
+
+		// dam upgrade
+		RpAtomic* currentDamUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_DAM]);
+
+		if (currentDamUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentDamUpgradeAtomic);
+			RpAtomicDestroy(currentDamUpgradeAtomic);
+		}
+
+		RpAtomicSetFrame(newDamUpgradeAtomic, m_aCarNodes[CAR_BNT_SCOOP_DAM]);
+		RpClumpAddAtomic(GetClump(), newDamUpgradeAtomic);
+
+		CVehicleModelInfo::SetEnvironmentMapCB(newDamUpgradeAtomic, nil);
+
+		mat.Attach(RwFrameGetMatrix(m_aCarNodes[CAR_BNT_SCOOP_DAM]));
+		mat.UpdateRW();
+
+		CVisibilityPlugins::SetAtomicFlag(newDamUpgradeAtomic, ATOMIC_FLAG_DAM);
+		if (Damage.GetDoorStatus(DOOR_BONNET) == DOOR_STATUS_OK)
+			RpAtomicSetFlags(newDamUpgradeAtomic, 0);
+
+		if (!temporary) {
+			m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nUpgradeModelIndex = modelIndex;
+			m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nTempUpgradeModelIndex = modelIndex;
+			m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nUpgradeNumber = (modelIndex + 1) - MI_BNT_SCOOP_1;
+		}
+
+		return;
+	}
+
+	// roof scoop
+	if (modelIndex >= MI_RF_SCOOP_1 && modelIndex <= MI_RF_SCOOP_1) {
+		if (!m_aCarNodes[CAR_RF_SCOOP])
+			return;
+
+		RpAtomic* newUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(modelIndex)->CreateInstance();
+
+		if (!newUpgradeAtomic)
+			return;
+
+		RwFrameDestroy(RpAtomicGetFrame(newUpgradeAtomic));
+
+		RpAtomic* currentUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_RF_SCOOP]);
+		if (currentUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentUpgradeAtomic);
+			RpAtomicDestroy(currentUpgradeAtomic);
+		}
+
+		RpAtomicSetFrame(newUpgradeAtomic, m_aCarNodes[CAR_RF_SCOOP]);
+		RpClumpAddAtomic(GetClump(), newUpgradeAtomic);
+
+		CVehicleModelInfo::SetEnvironmentMapCB(newUpgradeAtomic, nil);
+
+		mat.Attach(RwFrameGetMatrix(m_aCarNodes[CAR_RF_SCOOP]));
+		mat.UpdateRW();
+
+		if (!temporary) {
+			m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nUpgradeModelIndex = modelIndex;
+			m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nTempUpgradeModelIndex = modelIndex;
+			m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nUpgradeNumber = (modelIndex + 1) - MI_RF_SCOOP_1;
+		}
+
+		return;
+	}
+
+	// bonnet vents
+	if (modelIndex >= MI_BNT_VENT_L_1 && modelIndex <= MI_BNT_VENT_R_2_DAM) {
+		if (!m_aCarNodes[CAR_VENT_L_OK] || !m_aCarNodes[CAR_VENT_L_DAM] ||
+			!m_aCarNodes[CAR_VENT_R_OK] || !m_aCarNodes[CAR_VENT_R_DAM])
+			return;
+
+		RpAtomic* newOkLeftUpgradeAtomic = nil;
+		RpAtomic* newDamLeftUpgradeAtomic = nil;
+		RpAtomic* newOkRightUpgradeAtomic = nil;
+		RpAtomic* newDamRightUpgradeAtomic = nil;
+		if (modelIndex == MI_BNT_VENT_L_1 || modelIndex == MI_BNT_VENT_R_1) {
+			newOkLeftUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(MI_BNT_VENT_L_1)->CreateInstance();
+			newDamLeftUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(MI_BNT_VENT_L_1_DAM)->CreateInstance();
+			newOkRightUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(MI_BNT_VENT_R_1)->CreateInstance();
+			newDamRightUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(MI_BNT_VENT_R_1_DAM)->CreateInstance();
+		} else if (modelIndex == MI_BNT_VENT_L_2 || modelIndex == MI_BNT_VENT_R_2) {
+			newOkLeftUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(MI_BNT_VENT_L_2)->CreateInstance();
+			newDamLeftUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(MI_BNT_VENT_L_2_DAM)->CreateInstance();
+			newOkRightUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(MI_BNT_VENT_R_2)->CreateInstance();
+			newDamRightUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(MI_BNT_VENT_R_2_DAM)->CreateInstance();
+		}
+
+		if (!newOkLeftUpgradeAtomic || !newDamLeftUpgradeAtomic || !newOkRightUpgradeAtomic || !newDamRightUpgradeAtomic)
+			return;
+
+		RwFrameDestroy(RpAtomicGetFrame(newOkLeftUpgradeAtomic));
+		RwFrameDestroy(RpAtomicGetFrame(newDamLeftUpgradeAtomic));
+		RwFrameDestroy(RpAtomicGetFrame(newOkRightUpgradeAtomic));
+		RwFrameDestroy(RpAtomicGetFrame(newDamRightUpgradeAtomic));
+
+		// ok upgrade
+		RpAtomic* currentOkLeftUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_L_OK]);
+		RpAtomic* currentOkRightUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_R_OK]);
+		if (currentOkLeftUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentOkLeftUpgradeAtomic);
+			RpAtomicDestroy(currentOkLeftUpgradeAtomic);
+		}
+		if (currentOkRightUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentOkRightUpgradeAtomic);
+			RpAtomicDestroy(currentOkRightUpgradeAtomic);
+		}
+
+		RpAtomicSetFrame(newOkLeftUpgradeAtomic, m_aCarNodes[CAR_VENT_L_OK]);
+		RpClumpAddAtomic(GetClump(), newOkLeftUpgradeAtomic);
+		RpAtomicSetFrame(newOkRightUpgradeAtomic, m_aCarNodes[CAR_VENT_R_OK]);
+		RpClumpAddAtomic(GetClump(), newOkRightUpgradeAtomic);
+
+		CVehicleModelInfo::SetEnvironmentMapCB(newOkLeftUpgradeAtomic, nil);
+		CVehicleModelInfo::SetEnvironmentMapCB(newOkRightUpgradeAtomic, nil);
+
+		mat.Attach(RwFrameGetMatrix(m_aCarNodes[CAR_VENT_L_OK]));
+		mat.UpdateRW();
+		mat.Attach(RwFrameGetMatrix(m_aCarNodes[CAR_VENT_R_OK]));
+		mat.UpdateRW();
+
+		CVisibilityPlugins::SetAtomicFlag(newOkLeftUpgradeAtomic, ATOMIC_FLAG_OK);
+		if (Damage.GetDoorStatus(DOOR_BONNET) == DOOR_STATUS_SMASHED)
+			RpAtomicSetFlags(newOkLeftUpgradeAtomic, 0);
+		CVisibilityPlugins::SetAtomicFlag(newOkRightUpgradeAtomic, ATOMIC_FLAG_OK);
+		if (Damage.GetDoorStatus(DOOR_BONNET) == DOOR_STATUS_SMASHED)
+			RpAtomicSetFlags(newOkRightUpgradeAtomic, 0);
+
+		// dam upgrade
+		RpAtomic* currentDamLeftUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_L_DAM]);
+		RpAtomic* currentDamRightUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_R_DAM]);
+		if (currentDamLeftUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentDamLeftUpgradeAtomic);
+			RpAtomicDestroy(currentDamLeftUpgradeAtomic);
+		}
+		if (currentDamRightUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentDamRightUpgradeAtomic);
+			RpAtomicDestroy(currentDamRightUpgradeAtomic);
+		}
+
+		RpAtomicSetFrame(newDamLeftUpgradeAtomic, m_aCarNodes[CAR_VENT_L_DAM]);
+		RpClumpAddAtomic(GetClump(), newDamLeftUpgradeAtomic);
+		RpAtomicSetFrame(newDamRightUpgradeAtomic, m_aCarNodes[CAR_VENT_R_DAM]);
+		RpClumpAddAtomic(GetClump(), newDamRightUpgradeAtomic);
+
+		CVehicleModelInfo::SetEnvironmentMapCB(newDamLeftUpgradeAtomic, nil);
+		CVehicleModelInfo::SetEnvironmentMapCB(newDamRightUpgradeAtomic, nil);
+
+		mat.Attach(RwFrameGetMatrix(m_aCarNodes[CAR_VENT_L_DAM]));
+		mat.UpdateRW();
+		mat.Attach(RwFrameGetMatrix(m_aCarNodes[CAR_VENT_R_DAM]));
+		mat.UpdateRW();
+		
+		CVisibilityPlugins::SetAtomicFlag(newDamLeftUpgradeAtomic, ATOMIC_FLAG_DAM);
+		if (Damage.GetDoorStatus(DOOR_BONNET) == DOOR_STATUS_OK)
+			RpAtomicSetFlags(newDamLeftUpgradeAtomic, 0);
+		CVisibilityPlugins::SetAtomicFlag(newDamRightUpgradeAtomic, ATOMIC_FLAG_DAM);
+		if (Damage.GetDoorStatus(DOOR_BONNET) == DOOR_STATUS_OK)
+			RpAtomicSetFlags(newDamRightUpgradeAtomic, 0);
+
+		if (!temporary) {
+			m_aUpgrades[UPGRADE_VENTS].m_nUpgradeModelIndex = modelIndex;
+			m_aUpgrades[UPGRADE_VENTS].m_nTempUpgradeModelIndex = modelIndex;
+
+			if (modelIndex == MI_BNT_VENT_L_1 || modelIndex == MI_BNT_VENT_R_1)
+				m_aUpgrades[UPGRADE_VENTS].m_nUpgradeNumber = 1;
+
+			if (modelIndex == MI_BNT_VENT_L_2 || modelIndex == MI_BNT_VENT_R_2)
+				m_aUpgrades[UPGRADE_VENTS].m_nUpgradeNumber = 2;
+		}
+
+		return;
+	}
+
+	// superchargers
+	if (modelIndex >= MI_SC_SABRE_BONNET_OK && modelIndex <= MI_SC_SABRE_BONNET_DAM) {
+		if (!m_aCarNodes[CAR_SUPERCHARGER])
+			return;
+
+		RpAtomic* newOkUpgradeAtomic = nil;
+		RpAtomic* newDamUpgradeAtomic = nil;
+
+		if (modelIndex == MI_SC_SABRE_BONNET_OK || modelIndex == MI_SC_SABRE_BONNET_DAM) {
+			newOkUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(MI_SC_SABRE_BONNET_OK)->CreateInstance();
+			newDamUpgradeAtomic = (RpAtomic*)CModelInfo::GetModelInfo(MI_SC_SABRE_BONNET_DAM)->CreateInstance();
+		}
+
+		if (!newOkUpgradeAtomic || !newDamUpgradeAtomic)
+			return;
+
+		RwFrameDestroy(RpAtomicGetFrame(newOkUpgradeAtomic));
+		RwFrameDestroy(RpAtomicGetFrame(newDamUpgradeAtomic));
+
+		// ok uprgrade
+		RpAtomic* currentOkUpgradeAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_BONNET], GetOkAtomicObjectCB, &currentOkUpgradeAtomic);
+
+		if (!currentOkUpgradeAtomic)
+			return;
+
+		m_aDefaultBonnetOkAtomic = RpAtomicClone(currentOkUpgradeAtomic);
+		//RwFrameDestroy(RpAtomicGetFrame(m_aDefaultBonnetOkAtomic));
+
+		RpClumpRemoveAtomic(GetClump(), currentOkUpgradeAtomic);
+		RpAtomicDestroy(currentOkUpgradeAtomic);
+
+		RpAtomicSetFrame(newOkUpgradeAtomic, m_aCarNodes[CAR_BONNET]);
+		RpClumpAddAtomic(GetClump(), newOkUpgradeAtomic);
+
+		CVisibilityPlugins::SetAtomicFlag(newOkUpgradeAtomic, ATOMIC_FLAG_OK);
+		CVisibilityPlugins::SetAtomicRenderCallback(newOkUpgradeAtomic, CVisibilityPlugins::RenderVehicleHiDetailCB);
+		if (Damage.GetDoorStatus(DOOR_BONNET) == DOOR_STATUS_SMASHED)
+			RpAtomicSetFlags(newOkUpgradeAtomic, 0);
+
+		// dam upgrade
+		RpAtomic* currentDamUpgradeAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_BONNET], GetDamAtomicObjectCB, &currentDamUpgradeAtomic);
+
+		if (!currentDamUpgradeAtomic)
+			return;
+
+		m_aDefaultBonnetDamAtomic = RpAtomicClone(currentDamUpgradeAtomic);
+		//RwFrameDestroy(RpAtomicGetFrame(m_aDefaultBonnetDamAtomic));
+
+		RpClumpRemoveAtomic(GetClump(), currentDamUpgradeAtomic);
+		RpAtomicDestroy(currentDamUpgradeAtomic);
+
+		RpAtomicSetFrame(newDamUpgradeAtomic, m_aCarNodes[CAR_BONNET]);
+		RpClumpAddAtomic(GetClump(), newDamUpgradeAtomic);
+
+		CVisibilityPlugins::SetAtomicFlag(newDamUpgradeAtomic, ATOMIC_FLAG_DAM);
+		CVisibilityPlugins::SetAtomicRenderCallback(newDamUpgradeAtomic, CVisibilityPlugins::RenderVehicleHiDetailCB);
+		if (Damage.GetDoorStatus(DOOR_BONNET) == DOOR_STATUS_OK)
+			RpAtomicSetFlags(newDamUpgradeAtomic, 0);
+
+		RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SUPERCHARGER]->child), rpATOMICRENDER); // supercharger
+		RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SUPERCHARGER]->child->child->child), rpATOMICRENDER); // carb
+		RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SUPERCHARGER]->child->child->next->child), rpATOMICRENDER); // flywheel
+
+		if (!temporary) {
+			m_aUpgrades[UPGRADE_SUPERCHARGER].m_nUpgradeModelIndex = modelIndex;
+			m_aUpgrades[UPGRADE_SUPERCHARGER].m_nTempUpgradeModelIndex = modelIndex;
+			m_aUpgrades[UPGRADE_SUPERCHARGER].m_nUpgradeNumber = 1;
+		}
+
+		return;
+	}
+}
+
+void CAutomobile::RemoveUpgrade(eUpgradeTypes upgradeType, bool temporary)
+{
+	if (upgradeType == UPGRADE_SPOILER) {
+		if (!m_aCarNodes[CAR_SPOILER_OK] && !m_aCarNodes[CAR_SPOILER_DAM])
+			return;
+
+		RpAtomic* currentOkUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SPOILER_OK]);
+		if (currentOkUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentOkUpgradeAtomic);
+			RpAtomicDestroy(currentOkUpgradeAtomic);
+		}
+
+		if (m_aCarNodes[CAR_SPOILER_DAM]) {
+			RpAtomic* currentDamUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SPOILER_DAM]);
+			if (currentDamUpgradeAtomic) {
+				RpClumpRemoveAtomic(GetClump(), currentDamUpgradeAtomic);
+				RpAtomicDestroy(currentDamUpgradeAtomic);
+			}
+		}
+
+		if (!temporary) {
+			m_aUpgrades[UPGRADE_SPOILER].m_nUpgradeModelIndex = 0;
+			m_aUpgrades[UPGRADE_SPOILER].m_nTempUpgradeModelIndex = 0;
+			m_aUpgrades[UPGRADE_SPOILER].m_nUpgradeNumber = 0;
+		}
+	} else if (upgradeType == UPGRADE_SKIRTS) {
+		if (!m_aCarNodes[CAR_SKIRT_L] || !m_aCarNodes[CAR_SKIRT_R])
+			return;
+
+		RpAtomic* currentLeftUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SKIRT_L]);
+		RpAtomic* currentRightUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SKIRT_R]);
+		if (currentLeftUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentLeftUpgradeAtomic);
+			RpAtomicDestroy(currentLeftUpgradeAtomic);
+		}
+		if (currentRightUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentRightUpgradeAtomic);
+			RpAtomicDestroy(currentRightUpgradeAtomic);
+		}
+
+		if (!temporary) {
+			m_aUpgrades[UPGRADE_SKIRTS].m_nUpgradeModelIndex = 0;
+			m_aUpgrades[UPGRADE_SKIRTS].m_nTempUpgradeModelIndex = 0;
+			m_aUpgrades[UPGRADE_SKIRTS].m_nUpgradeNumber = 0;
+		}
+	} else if (upgradeType == UPGRADE_ROOF_SCOOP) {
+		if (!m_aCarNodes[CAR_RF_SCOOP])
+			return;
+
+		RpAtomic* currentUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_RF_SCOOP]);
+		if (currentUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentUpgradeAtomic);
+			RpAtomicDestroy(currentUpgradeAtomic);
+		}
+
+		if (!temporary) {
+			m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nUpgradeModelIndex = 0;
+			m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nTempUpgradeModelIndex = 0;
+			m_aUpgrades[UPGRADE_ROOF_SCOOP].m_nUpgradeNumber = 0;
+		}
+	} else if (upgradeType == UPGRADE_BONNET_SCOOP) {
+		if (!m_aCarNodes[CAR_BNT_SCOOP_OK] || !m_aCarNodes[CAR_BNT_SCOOP_DAM])
+			return;
+
+		RpAtomic* currentOkUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_OK]);
+		RpAtomic* currentDamUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_BNT_SCOOP_DAM]);
+		if (currentOkUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentOkUpgradeAtomic);
+			RpAtomicDestroy(currentOkUpgradeAtomic);
+		}
+		if (currentDamUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentDamUpgradeAtomic);
+			RpAtomicDestroy(currentDamUpgradeAtomic);
+		}
+
+		if (!temporary) {
+			m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nUpgradeModelIndex = 0;
+			m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nTempUpgradeModelIndex = 0;
+			m_aUpgrades[UPGRADE_BONNET_SCOOP].m_nUpgradeNumber = 0;
+		}
+	} else if (upgradeType == UPGRADE_VENTS) {
+		if (!m_aCarNodes[CAR_VENT_L_OK] || !m_aCarNodes[CAR_VENT_L_DAM] ||
+			!m_aCarNodes[CAR_VENT_R_OK] || !m_aCarNodes[CAR_VENT_R_DAM])
+			return;
+
+		RpAtomic* currentOkLeftUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_L_OK]);
+		RpAtomic* currentDamLeftUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_L_DAM]);
+		RpAtomic* currentOkRightUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_R_OK]);
+		RpAtomic* currentDamRightUpgradeAtomic = (RpAtomic*)GetFirstObject(m_aCarNodes[CAR_VENT_R_DAM]);
+		if (currentOkLeftUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentOkLeftUpgradeAtomic);
+			RpAtomicDestroy(currentOkLeftUpgradeAtomic);
+		}
+		if (currentDamLeftUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentDamLeftUpgradeAtomic);
+			RpAtomicDestroy(currentDamLeftUpgradeAtomic);
+		}
+		if (currentOkRightUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentOkRightUpgradeAtomic);
+			RpAtomicDestroy(currentOkRightUpgradeAtomic);
+		}
+		if (currentDamRightUpgradeAtomic) {
+			RpClumpRemoveAtomic(GetClump(), currentDamRightUpgradeAtomic);
+			RpAtomicDestroy(currentDamRightUpgradeAtomic);
+		}
+
+		if (!temporary) {
+			m_aUpgrades[UPGRADE_VENTS].m_nUpgradeModelIndex = 0;
+			m_aUpgrades[UPGRADE_VENTS].m_nTempUpgradeModelIndex = 0;
+			m_aUpgrades[UPGRADE_VENTS].m_nUpgradeNumber = 0;
+		}
+	} else if (upgradeType == UPGRADE_SUPERCHARGER) {
+		if (!m_aCarNodes[CAR_SUPERCHARGER])
+			return;
+
+		// ok uprgrade
+		RpAtomic* currentOkUpgradeAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_BONNET], GetOkAtomicObjectCB, &currentOkUpgradeAtomic);
+
+		if (!currentOkUpgradeAtomic)
+			return;
+
+		RpClumpRemoveAtomic(GetClump(), currentOkUpgradeAtomic);
+		RpAtomicDestroy(currentOkUpgradeAtomic);
+
+		RpAtomicSetFrame(m_aDefaultBonnetOkAtomic, m_aCarNodes[CAR_BONNET]);
+		RpClumpAddAtomic(GetClump(), m_aDefaultBonnetOkAtomic);
+
+		CVisibilityPlugins::SetAtomicFlag(m_aDefaultBonnetOkAtomic, ATOMIC_FLAG_OK);
+		CVisibilityPlugins::SetAtomicRenderCallback(m_aDefaultBonnetOkAtomic, CVisibilityPlugins::RenderVehicleHiDetailCB);
+		if (Damage.GetDoorStatus(DOOR_BONNET) == DOOR_STATUS_SMASHED)
+			RpAtomicSetFlags(m_aDefaultBonnetOkAtomic, 0);
+
+		// dam upgrade
+		RpAtomic* currentDamUpgradeAtomic = nil;
+		RwFrameForAllObjects(m_aCarNodes[CAR_BONNET], GetDamAtomicObjectCB, &currentDamUpgradeAtomic);
+
+		if (!currentDamUpgradeAtomic)
+			return;
+
+		RpClumpRemoveAtomic(GetClump(), currentDamUpgradeAtomic);
+		RpAtomicDestroy(currentDamUpgradeAtomic);
+
+		RpAtomicSetFrame(m_aDefaultBonnetDamAtomic, m_aCarNodes[CAR_BONNET]);
+		RpClumpAddAtomic(GetClump(), m_aDefaultBonnetDamAtomic);
+
+		CVisibilityPlugins::SetAtomicFlag(m_aDefaultBonnetDamAtomic, ATOMIC_FLAG_DAM);
+		CVisibilityPlugins::SetAtomicRenderCallback(m_aDefaultBonnetDamAtomic, CVisibilityPlugins::RenderVehicleHiDetailCB);
+		if (Damage.GetDoorStatus(DOOR_BONNET) == DOOR_STATUS_OK)
+			RpAtomicSetFlags(m_aDefaultBonnetDamAtomic, 0);
+
+		RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SUPERCHARGER]->child), 0); // supercharger
+		RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SUPERCHARGER]->child->child->child), 0); // carb
+		RpAtomicSetFlags((RpAtomic*)GetFirstObject(m_aCarNodes[CAR_SUPERCHARGER]->child->child->next->child), 0); // flywheel
+
+		if (!temporary) {
+			m_aUpgrades[UPGRADE_SUPERCHARGER].m_nUpgradeModelIndex = 0;
+			m_aUpgrades[UPGRADE_SUPERCHARGER].m_nTempUpgradeModelIndex = 0;
+			m_aUpgrades[UPGRADE_SUPERCHARGER].m_nUpgradeNumber = 0;
+		}
+	}
+}
+#endif
+
 void
 CAutomobile::SetAllTaxiLights(bool set)
 {
diff --git a/src/vehicles/Automobile.h b/src/vehicles/Automobile.h
index e096c3ce..2a70dc2d 100644
--- a/src/vehicles/Automobile.h
+++ b/src/vehicles/Automobile.h
@@ -14,6 +14,25 @@ enum {
 	CARWHEEL_REAR_RIGHT
 };
 
+#ifdef VEHICLE_MODS // upgrade types
+enum eUpgradeTypes {
+	UPGRADE_WHEELS,
+	UPGRADE_SPOILER,
+	UPGRADE_SKIRTS,
+	UPGRADE_ROOF_SCOOP,
+	UPGRADE_BONNET_SCOOP,
+	UPGRADE_VENTS,
+	UPGRADE_SUPERCHARGER,
+	NUM_UPGRADES,
+};
+
+struct sUpgradeInfo {
+	int m_nUpgradeModelIndex;
+	int m_nTempUpgradeModelIndex;
+	int m_nUpgradeNumber;
+};
+#endif
+
 
 // TODO Figure out how to access these.
 class CAutomobile : public CVehicle
@@ -79,6 +98,27 @@ public:
 	float m_fGasPedalAudio;
 	tWheelState m_aWheelState[4];
 
+#ifdef IMPROVED_VEHICLES_2
+	bool m_bIndicatorState[2];
+#endif
+
+#ifdef VEHICLE_MODS
+	int m_nWindowTintLevel;
+	int m_nTempWindowTintLevel;
+	int m_nAddSuspensionForceLevel;
+	int m_nTempAddSuspensionForceLevel;
+	int m_nRimsColor;
+	int m_nTempRimsColor;
+	int m_nSpoilerColor;
+	int m_nTempSpoilerColor;
+	float m_fAddBrakeDeceleration;
+	sUpgradeInfo m_aUpgrades[NUM_UPGRADES];
+	float m_fCarbRotation;
+	RpAtomic* m_aDefaultBonnetOkAtomic;
+	RpAtomic* m_aDefaultBonnetDamAtomic;
+	bool bHasHydraulics;
+#endif
+
 	static bool m_sAllTaxiLights;
 
 	CAutomobile(int32 id, uint8 CreatedBy);
@@ -144,6 +184,10 @@ public:
 	void SetBumperDamage(int32 component, ePanels panel, bool noFlyingComponents = false);
 	void SetDoorDamage(int32 component, eDoors door, bool noFlyingComponents = false);
 
+#ifdef IMPROVED_VEHICLES
+	void SetWheelMissing(int32 wheel);
+#endif
+
 	void TellHeliToGoToCoors(float x, float y, float z, uint8 speed);
 	void TellPlaneToGoToCoors(float x, float y, float z, uint8 speed);
 	void SetHeliOrientation(float orient) { m_fHeliOrientation = orient; }
@@ -157,6 +201,21 @@ public:
 	void HideAllComps(void);
 	void ShowAllComps(void);
 	void ReduceHornCounter(void);
+	
+#ifdef IMPROVED_VEHICLES_2
+	void DoVehicleLights(void);
+	void SetFrameLightStatus(eCarNodes frameNode, eLightStatus status);
+	eLightStatus GetFrameLightStatus(eCarNodes frameNode);
+#endif
+
+#ifdef VEHICLE_MODS
+	void TrySetRandomCarMod(bool bForce = false);
+	void SetWheels(int modelIndex);
+	void SetWheelNumber(int modelIndex);
+	int GetWheelModelIndexFromWheelNumber();
+	void SetUpgrade(int modelIndex, bool temporary);
+	void RemoveUpgrade(eUpgradeTypes upgradeType, bool temporary);
+#endif
 
 	void PopBoot(void);
 	void PopBootUsingPhysics(void);
@@ -180,4 +239,12 @@ public:
 };
 
 extern CVector vecHunterGunPos;
-extern bool bAllCarCheat;
\ No newline at end of file
+extern bool bAllCarCheat;
+
+#ifdef VEHICLE_MODS
+RwObject* GetCurrentAtomicObjectCB(RwObject* object, void* data);
+#endif
+
+#ifdef IMPROVED_VEHICLES_2
+RwObject* GetWindowAtomicObjectCB(RwObject* object, void* data);
+#endif
\ No newline at end of file
diff --git a/src/vehicles/Bike.cpp b/src/vehicles/Bike.cpp
index c15ab9ab..7a727c18 100644
--- a/src/vehicles/Bike.cpp
+++ b/src/vehicles/Bike.cpp
@@ -38,6 +38,10 @@
 #include "Debug.h"
 #include "SaveBuf.h"
 
+#ifdef VEHICLE_MODS
+#include "Garages.h"
+#endif
+
 const uint32 CBike::nSaveStructSize =
 #ifdef COMPATIBLE_SAVES
 	1260;
@@ -99,7 +103,11 @@ CBike::CBike(int32 id, uint8 CreatedBy)
 	m_bike_unused1 = 20.0f;
 	m_bike_unused2 = 0;
 
+#ifdef IMPROVED_VEHICLES // More colors
+	mi->ChooseVehicleColour(m_currentColour1, m_currentColour2, m_currentColour3, m_currentColour4);
+#else
 	mi->ChooseVehicleColour(m_currentColour1, m_currentColour2);
+#endif
 
 	m_fRearForkLength = 0.0f;
 	m_fFrontForkY = 0.0;
@@ -719,7 +727,14 @@ CBike::ProcessControl(void)
 		fwdSpeed = DotProduct(m_vecMoveSpeed, GetForward());
 		if(!CVehicle::bCheat3)
 			gripCheat = false;
+		
+		
+#ifdef VEHICLE_MODS // engine acceleration
+		acceleration = pHandling->Transmission.CalculateDriveAcceleration(m_fGasPedal, m_nCurrentGear, m_fChangeGearTime, fwdSpeed, gripCheat, m_fAddEngineAcceleration);
+#else
 		acceleration = pHandling->Transmission.CalculateDriveAcceleration(m_fGasPedal, m_nCurrentGear, m_fChangeGearTime, fwdSpeed, gripCheat);
+#endif
+		
 		acceleration /= m_fForceMultiplier;
 
 		brake = m_fBrakePedal * pHandling->fBrakeDeceleration * CTimer::GetTimeStep();
@@ -1099,6 +1114,15 @@ CBike::ProcessControl(void)
 		}
 	}
 
+#ifdef IMPROVED_VEHICLES_2 // move engine fire particles to AddDamagedVehicleParticles
+	if (m_fHealth < 250.0f && GetStatus() != STATUS_WRECKED) {
+		// Blow up car after 5 seconds
+		m_fFireBlowUpTimer += CTimer::GetTimeStepInMilliseconds();
+		if (m_fFireBlowUpTimer > 5000.0f)
+			BlowUpCar(m_pSetOnFireEntity);
+	}else
+		m_fFireBlowUpTimer = 0.0f;
+#else
 	if(m_fHealth < 250.0f && GetStatus() != STATUS_WRECKED){
 		// Car is on fire
 
@@ -1133,7 +1157,9 @@ CBike::ProcessControl(void)
 			BlowUpCar(m_pSetOnFireEntity);
 	}else
 		m_fFireBlowUpTimer = 0.0f;
+#endif
 
+		//
 	ProcessDelayedExplosion();
 
 	// Find out how much to shake the pad depending on suspension and ground surface
@@ -1334,6 +1360,9 @@ CBike::PreRender(void)
 
 	// Process lights
 
+#ifdef IMPROVED_VEHICLES_2
+	DoVehicleLights();
+#else
 	// Turn lights on/off
 	bool shouldLightsBeOn = 
 		CClock::GetHours() > 20 ||
@@ -1531,6 +1560,9 @@ CBike::PreRender(void)
 			CCoronas::UpdateCoronaCoors((uintptr)this + 14, light, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
 		}
 	}
+#endif
+
+	//
 
 
 	// Wheel particles
@@ -1749,7 +1781,136 @@ CBike::Render(void)
 	CVehicleModelInfo *mi = (CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex());
 
 	m_nSetPieceExtendedRangeTime = CTimer::GetTimeInMilliseconds() + 3000;
+
+#if defined VEHICLE_MODS && defined IMPROVED_VEHICLES
+	uint8 color1 = CGarages::bPlayerInModGarage ? m_nTempColor1 : m_currentColour1;
+	uint8 color2 = CGarages::bPlayerInModGarage ? m_nTempColor2 : m_currentColour2;
+	uint8 color3 = CGarages::bPlayerInModGarage ? m_nTempColor3 : m_currentColour3;
+	uint8 color4 = CGarages::bPlayerInModGarage ? m_nTempColor4 : m_currentColour4;
+	mi->SetVehicleColour(color1, color2, color3, color4);
+
+	if (FindPlayerVehicle() == this && !CGarages::bPlayerInModGarage) {
+		m_nTempColor1 = m_currentColour1;
+		m_nTempColor2 = m_currentColour2;
+		m_nTempColor3 = m_currentColour3;
+		m_nTempColor4 = m_currentColour4;
+	}
+#else
 	mi->SetVehicleColour(m_currentColour1, m_currentColour2);
+#endif
+
+#ifdef IMPROVED_VEHICLES_2 // change the ambient and material color
+	bool bLightsBroken = false;
+	float ambientOff = 1.0f;
+	float ambientOn = 10.0f;
+	RpAtomic* lightAtomic = nil;
+
+	// headlight
+	if (m_aBikeNodes[BIKE_HEADLIGHT_L]) {
+		RwFrameForAllObjects(m_aBikeNodes[BIKE_HEADLIGHT_L], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+
+			material->surfaceProps.ambient = bLightsOn ? ambientOn : ambientOff;
+			material = bLightsOn ? RpMaterialSetTexture(material, mi->lightsOnTexture) : RpMaterialSetTexture(material, mi->lightsOffTexture);
+		}
+	}
+
+	// taillight
+	if (m_aBikeNodes[BIKE_TAILLIGHT_L]) {
+		RwFrameForAllObjects(m_aBikeNodes[BIKE_TAILLIGHT_L], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			bool bLightOn = GetStatus() != STATUS_ABANDONED && !bRenderScorched && (m_fBrakePedal > 0.0f || bLightsOn);
+
+			material->surfaceProps.ambient = bLightOn ? ambientOn : ambientOff;
+			material = bLightOn ? RpMaterialSetTexture(material, mi->lightsOnTexture) : RpMaterialSetTexture(material, mi->lightsOffTexture);
+		}
+	}
+
+	// indicators
+	if (pDriver && !pDriver->DyingOrDead() && this != FindPlayerVehicle() && AutoPilot.m_nDrivingStyle != DRIVINGSTYLE_PLOUGH_THROUGH && !bRenderScorched) {
+		CVector2D vehicleRight = GetRight();
+		CVector2D nextPathLinkForward = AutoPilot.m_nNextDirection * ThePaths.m_carPathLinks[AutoPilot.m_nNextPathNodeInfo].GetDirection();
+		float angle = DotProduct2D(vehicleRight, nextPathLinkForward);
+
+		m_bIndicatorState[INDICATORS_LEFT] = angle < -0.2f;
+		m_bIndicatorState[INDICATORS_RIGHT] = angle > 0.2f;
+	} else if (AutoPilot.m_nDrivingStyle == DRIVINGSTYLE_PLOUGH_THROUGH || bRenderScorched) {
+		m_bIndicatorState[INDICATORS_LEFT] = false;
+		m_bIndicatorState[INDICATORS_RIGHT] = false;
+	} else if (this == FindPlayerVehicle()) {
+		CPad* pad = CPad::GetPad(0);
+
+		if (pad->LeftTurnSignalsJustDown()) {
+			m_bIndicatorState[INDICATORS_LEFT] = !m_bIndicatorState[INDICATORS_LEFT];
+			if (m_bIndicatorState[INDICATORS_LEFT]) m_bIndicatorState[INDICATORS_RIGHT] = false;
+		}
+		
+		if (pad->RightTurnSignalsJustDown()) {
+			m_bIndicatorState[INDICATORS_RIGHT] = !m_bIndicatorState[INDICATORS_RIGHT];
+			if (m_bIndicatorState[INDICATORS_RIGHT]) m_bIndicatorState[INDICATORS_LEFT] = false;
+		}
+
+		if (pad->EmergencyLightsJustDown()) {
+			if (m_bIndicatorState[INDICATORS_LEFT] == m_bIndicatorState[INDICATORS_RIGHT]) {
+				m_bIndicatorState[INDICATORS_LEFT] = !m_bIndicatorState[INDICATORS_LEFT];
+				m_bIndicatorState[INDICATORS_RIGHT] = !m_bIndicatorState[INDICATORS_RIGHT];
+			} else {
+				m_bIndicatorState[INDICATORS_LEFT] = true;
+				m_bIndicatorState[INDICATORS_RIGHT] = true;
+			}
+		}
+	}
+
+	CRGBA indicatorOffColor = CRGBA(150, 125, 0, 255);
+	CRGBA indicatorOnColor = CRGBA(255, 225, 0, 255);
+	
+	// forward indicators
+	if (m_aBikeNodes[BIKE_INDICATOR_LF]) {
+		RwFrameForAllObjects(m_aBikeNodes[BIKE_INDICATOR_LF], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			bool bindicatorOn = m_bIndicatorState[INDICATORS_LEFT] == true && CTimer::GetTimeInMilliseconds() & 512;
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			material->surfaceProps.ambient = bindicatorOn ? ambientOn : ambientOff;
+			RwRGBA color = bindicatorOn ? indicatorOnColor : indicatorOffColor;
+			material->color = color;
+		}
+	}
+	if (m_aBikeNodes[BIKE_INDICATOR_RF]) {
+		RwFrameForAllObjects(m_aBikeNodes[BIKE_INDICATOR_RF], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			bool bindicatorOn = m_bIndicatorState[INDICATORS_RIGHT] == true && CTimer::GetTimeInMilliseconds() & 512;
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			material->surfaceProps.ambient = bindicatorOn ? ambientOn : ambientOff;
+			RwRGBA color = bindicatorOn ? indicatorOnColor : indicatorOffColor;
+			material->color = color;
+		}
+	}
+
+	// rear indicators
+	if (m_aBikeNodes[BIKE_INDICATOR_LR]) {
+		RwFrameForAllObjects(m_aBikeNodes[BIKE_INDICATOR_LR], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			bool bindicatorOn = m_bIndicatorState[INDICATORS_LEFT] == true && CTimer::GetTimeInMilliseconds() & 512;
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			material->surfaceProps.ambient = bindicatorOn ? ambientOn : ambientOff;
+			RwRGBA color = bindicatorOn ? indicatorOnColor : indicatorOffColor;
+			material->color = color;
+		}
+	}
+	if (m_aBikeNodes[BIKE_INDICATOR_RR]) {
+		RwFrameForAllObjects(m_aBikeNodes[BIKE_INDICATOR_RR], GetCurrentAtomicObjectCB, &lightAtomic);
+		if (lightAtomic) {
+			bool bindicatorOn = m_bIndicatorState[INDICATORS_RIGHT] == true && CTimer::GetTimeInMilliseconds() & 512;
+			RpMaterial* material = lightAtomic->geometry->matList.materials[0];
+			material->surfaceProps.ambient = bindicatorOn ? ambientOn : ambientOff;
+			RwRGBA color = bindicatorOn ? indicatorOnColor : indicatorOffColor;
+			material->color = color;
+		}
+	}
+#endif
+
 	CEntity::Render();
 }
 
@@ -2220,6 +2381,27 @@ CBike::VehicleDamage(void)
 
 	if(impulse > 25.0f && GetStatus() != STATUS_WRECKED){
 		float damage = (impulse-25.0f)*pHandling->fCollisionDamageMultiplier;
+
+#ifdef VEHICLE_MODS // armor
+		float absorbedDamage = 1.0f;
+		switch (m_nArmorLevel)
+		{
+		case 1:
+			absorbedDamage = 1.25f;
+			break;
+		case 2:
+			absorbedDamage = 1.5f;
+			break;
+		case 3:
+			absorbedDamage = 1.75f;
+			break;
+		case 4:
+			absorbedDamage = 2.0f;
+			break;
+		}
+		damage /= absorbedDamage;
+#endif
+
 		if(damage > 0.0f){
 			if(damage > 5.0f &&
 			   pDriver &&
@@ -2240,7 +2422,32 @@ CBike::VehicleDamage(void)
 			if(m_fHealth <= 0.0f && oldHealth > 0)
 				m_fHealth = 1.0f;
 		}
-	}
+	
+	// TODO Figure out what I broke.
+		 }
+
+
+
+	#ifdef IMPROVED_VEHICLES_2 // remove lights when bike is crashed
+		if (m_vecMoveSpeed.MagnitudeSqr() > 0.0005f) {
+			switch (m_nDamagePieceType) {
+			case CAR_PIECE_BUMP_FRONT:
+				if (GetFrameLightStatus(BIKE_HEADLIGHT_L) == LIGHT_STATUS_OK) {
+					SetFrameLightStatus(BIKE_HEADLIGHT_L, LIGHT_STATUS_BROKEN);
+					SetFrameLightStatus(BIKE_INDICATOR_LF, LIGHT_STATUS_BROKEN);
+					SetFrameLightStatus(BIKE_INDICATOR_RF, LIGHT_STATUS_BROKEN);
+				}
+				break;
+			case CAR_PIECE_BUMP_REAR:
+				if (GetFrameLightStatus(BIKE_TAILLIGHT_L) == LIGHT_STATUS_OK) {
+					SetFrameLightStatus(BIKE_TAILLIGHT_L, LIGHT_STATUS_BROKEN);
+					SetFrameLightStatus(BIKE_INDICATOR_LR, LIGHT_STATUS_BROKEN);
+					SetFrameLightStatus(BIKE_INDICATOR_RR, LIGHT_STATUS_BROKEN);
+				}
+				break;
+			}
+		}
+#endif
 
 	if(m_fHealth < 250.0f){
 		// Car is on fire
@@ -2258,6 +2465,72 @@ CBike::VehicleDamage(void)
 void
 CBike::AddDamagedVehicleParticles(void)
 {
+#ifdef IMPROVED_VEHICLES_2 // change engine fire position
+	CVector overheatPos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->m_positions[CAR_POS_OVERHEAT];
+	CVector overheat2Pos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->m_positions[CAR_POS_OVERHEAT_2];
+	if (m_fHealth < 250.0f && GetStatus() != STATUS_WRECKED) {
+		// Car is on fire
+
+		if (overheatPos.IsZero() && overheat2Pos.IsZero()) {
+			CVector damagePos, fireDir;
+
+			// move fire forward if in first person
+			if(this == FindPlayerVehicle() && TheCamera.GetLookingForwardFirstPerson()){
+				damagePos = CVector(0.0f, 1.2f, -0.4f);
+				fireDir = CVector(0.0f, 0.0f, CGeneral::GetRandomNumberInRange(0.01125f, 0.09f));
+			}else{
+				damagePos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->m_positions[CAR_POS_BACKSEAT];
+				damagePos.z -= 0.3f;
+				fireDir = CGeneral::GetRandomNumberInRange(0.02025f, 0.09f) * GetRight();
+				fireDir -= CGeneral::GetRandomNumberInRange(0.02025f, 0.18f) * GetForward();
+				fireDir.z = CGeneral::GetRandomNumberInRange(0.00225f, 0.018f);
+			}
+
+			damagePos = GetMatrix()*damagePos;
+			CParticle::AddParticle(PARTICLE_CARFLAME, damagePos, fireDir,
+				nil, 0.9f);
+
+			CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2, damagePos, CVector(0.0f, 0.0f, 0.0f), nil, 0.5f);
+
+			damagePos.x += CGeneral::GetRandomNumberInRange(-0.5625f, 0.5625f),
+			damagePos.y += CGeneral::GetRandomNumberInRange(-0.5625f, 0.5625f),
+			damagePos.z += CGeneral::GetRandomNumberInRange(0.5625f, 2.25f);
+			CParticle::AddParticle(PARTICLE_CARFLAME_SMOKE, damagePos, CVector(0.0f, 0.0f, 0.0f));
+
+			// Blow up car after 5 seconds
+			m_fFireBlowUpTimer += CTimer::GetTimeStepInMilliseconds();
+			if(m_fFireBlowUpTimer > 5000.0f)
+				BlowUpCar(m_pSetOnFireEntity);
+		} else {
+			if (!overheatPos.IsZero()) {
+				CVector direction;
+				if (overheatPos.x > 0.0f)
+					direction = m_vecMoveSpeed + GetRight() * 0.02f;
+				else
+					direction = m_vecMoveSpeed - GetRight() * 0.02f;
+
+				overheatPos = GetMatrix() * overheatPos;
+				CParticle::AddParticle(PARTICLE_CARFLAME_SMALL, overheatPos, direction);
+				CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2_SMALL, overheatPos, direction);
+				CParticle::AddParticle(PARTICLE_CARFLAME_SMOKE_SMALL, overheatPos, direction);
+			}
+			
+			if (!overheat2Pos.IsZero()) {
+				CVector direction2 = m_vecMoveSpeed - GetRight() * 0.02f;
+				if (overheat2Pos.x > 0.0f)
+					direction2 = m_vecMoveSpeed + GetRight() * 0.02f;
+				else
+					direction2 = m_vecMoveSpeed - GetRight() * 0.02f;
+
+				overheat2Pos = GetMatrix() * overheat2Pos;
+				CParticle::AddParticle(PARTICLE_CARFLAME_SMALL, overheat2Pos, direction2);
+				CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2_SMALL, overheat2Pos, direction2);
+				CParticle::AddParticle(PARTICLE_CARFLAME_SMOKE_SMALL, overheat2Pos, direction2);
+			}
+		}
+	}
+#endif
+
 	if(this == FindPlayerVehicle() && TheCamera.GetLookingForwardFirstPerson())
 		return;
 	if(this != FindPlayerVehicle() && (CTimer::GetFrameCounter() + m_randomSeed) & 1)
@@ -2265,44 +2538,138 @@ CBike::AddDamagedVehicleParticles(void)
 	if(m_fHealth >= 650.0f)
 		return;
 
-	CVector direction = 0.5f*m_vecMoveSpeed;
-	CVector damagePos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->GetFrontSeatPosn();
-
-	damagePos.z -= 0.4f;
-	damagePos = GetMatrix()*damagePos;
-
-	CalculateLeanMatrix();
-
-	if(m_fHealth < 250.0f){
-		// fire, done in processControl
-	}else if(m_fHealth < 320.0f){
-		direction *= 0.2f;
-		CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2, damagePos, direction + 0.02f*m_leanMatrix.GetRight());
-	}else if(m_fHealth < 390.0f){
-		if(((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 0 ||
-		   ((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 2)
-			CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, direction + 0.05f*m_leanMatrix.GetRight());
-		direction *= 0.3f;
-		CParticle::AddParticle(PARTICLE_ENGINE_SMOKE, damagePos, direction + 0.04f*m_leanMatrix.GetRight());
-	}else if(m_fHealth < 460.0f){
-		int rnd = CTimer::GetFrameCounter() + m_randomSeed;
-		if(rnd < 10 ||
-		   rnd < 70 && rnd > 25 ||
-		   rnd < 160 && rnd > 100 ||
-		   rnd < 200 && rnd > 175 ||
-		   rnd > 235)
+	
+
+#ifdef IMPROVED_VEHICLES_2 // change engine smoke position
+		if (overheatPos.IsZero() && overheat2Pos.IsZero()) {
+			CVector direction = 0.5f*m_vecMoveSpeed;
+			CVector damagePos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->GetFrontSeatPosn();
+	
+			damagePos.z -= 0.4f;
+			damagePos = GetMatrix()*damagePos;
+	
+			CalculateLeanMatrix();
+	
+			if(m_fHealth < 250.0f){
+				// fire
+			}else if(m_fHealth < 320.0f){
+				direction *= 0.2f;
+				CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2, damagePos, direction + 0.02f*m_leanMatrix.GetRight());
+			}else if(m_fHealth < 390.0f){
+				if(((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 0 ||
+					((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 2)
+					CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, direction + 0.05f*m_leanMatrix.GetRight());
+				direction *= 0.3f;
+				CParticle::AddParticle(PARTICLE_ENGINE_SMOKE, damagePos, direction + 0.04f*m_leanMatrix.GetRight());
+			}else if(m_fHealth < 460.0f){
+				int rnd = CTimer::GetFrameCounter() + m_randomSeed;
+				if(rnd < 10 ||
+					rnd < 70 && rnd > 25 ||
+					rnd < 160 && rnd > 100 ||
+					rnd < 200 && rnd > 175 ||
+					rnd > 235)
+					return;
+				direction.z += 0.05f;
+				if(TheCamera.GetLookDirection() != LOOKING_FORWARD){
+					CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, direction + 0.08f*m_leanMatrix.GetRight(), nil, 0.1f, 0, 0, 0, 1000);
+				}else if(((CTimer::GetFrameCounter() + m_randomSeed) & 1) == 0){
+					direction = 0.8f*m_vecMoveSpeed;
+					CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, direction + 0.07f*m_leanMatrix.GetRight(), nil, 0.1f, 0, 0, 0, 1000);
+				}
+			}else if(((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 0 ||
+						((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 2){
+				CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos + 0.06f*m_leanMatrix.GetRight(), direction);
+			}
+	
 			return;
-		direction.z += 0.05f;
-		if(TheCamera.GetLookDirection() != LOOKING_FORWARD){
-			CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, direction + 0.08f*m_leanMatrix.GetRight(), nil, 0.1f, 0, 0, 0, 1000);
-		}else if(((CTimer::GetFrameCounter() + m_randomSeed) & 1) == 0){
-			direction = 0.8f*m_vecMoveSpeed;
-			CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, direction + 0.07f*m_leanMatrix.GetRight(), nil, 0.1f, 0, 0, 0, 1000);
 		}
-	}else if(((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 0 ||
-	         ((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 2){
-		CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos + 0.06f*m_leanMatrix.GetRight(), direction);
-	}
+	
+		CVector direction;
+		CVector direction2;
+	
+		if (overheatPos.x > 0.0f)
+			direction = m_vecMoveSpeed + GetRight() * 0.02f;
+		else
+			direction = m_vecMoveSpeed - GetRight() * 0.02f;
+	
+		if (overheat2Pos.x > 0.0f)
+			direction2 = m_vecMoveSpeed + GetRight() * 0.02f;
+		else
+			direction2 = m_vecMoveSpeed - GetRight() * 0.02f;
+	
+		if (!overheatPos.IsZero()) overheatPos = GetMatrix() * overheatPos;
+		if (!overheat2Pos.IsZero()) overheat2Pos = GetMatrix() * overheat2Pos;
+	
+		CalculateLeanMatrix();
+	
+		if(m_fHealth < 250.0f){
+			// fire
+		}else if(m_fHealth < 320.0f){
+			if (!overheatPos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2_SMALL, overheatPos, direction);
+			if (!overheat2Pos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2_SMALL, overheat2Pos, direction2);
+		}else if(m_fHealth < 390.0f){
+			if (((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 0 ||
+				((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 2) {
+	
+				if (!overheatPos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheatPos, direction);
+				if (!overheat2Pos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheat2Pos, direction2);
+			}
+			if (!overheatPos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_SMOKE_SMALL, overheatPos, direction);
+			if (!overheat2Pos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_SMOKE_SMALL, overheat2Pos, direction2);
+		}else if(m_fHealth < 460.0f){
+			if(TheCamera.GetLookDirection() != LOOKING_FORWARD){
+				if (!overheatPos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheatPos, direction);
+				if (!overheat2Pos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheat2Pos, direction2);
+			}else if(((CTimer::GetFrameCounter() + m_randomSeed) & 1) == 0){
+				if (!overheatPos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheatPos, direction);
+				if (!overheat2Pos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheat2Pos, direction2);
+			}
+		}else if(((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 0 ||
+				 ((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 2){
+	
+			if (!overheatPos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheatPos, direction);
+			if (!overheat2Pos.IsZero()) CParticle::AddParticle(PARTICLE_ENGINE_STEAM_SMALL, overheat2Pos, direction2);
+		}
+#else
+		CVector direction = 0.5f*m_vecMoveSpeed;
+		CVector damagePos = ((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->GetFrontSeatPosn();
+	
+		damagePos.z -= 0.4f;
+		damagePos = GetMatrix()*damagePos;
+	
+		CalculateLeanMatrix();
+	
+		if(m_fHealth < 250.0f){
+			// fire, done in processControl
+		}else if(m_fHealth < 320.0f){
+			direction *= 0.2f;
+			CParticle::AddParticle(PARTICLE_ENGINE_SMOKE2, damagePos, direction + 0.02f*m_leanMatrix.GetRight());
+		}else if(m_fHealth < 390.0f){
+			if(((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 0 ||
+			   ((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 2)
+				CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, direction + 0.05f*m_leanMatrix.GetRight());
+			direction *= 0.3f;
+			CParticle::AddParticle(PARTICLE_ENGINE_SMOKE, damagePos, direction + 0.04f*m_leanMatrix.GetRight());
+		}else if(m_fHealth < 460.0f){
+			int rnd = CTimer::GetFrameCounter() + m_randomSeed;
+			if(rnd < 10 ||
+			   rnd < 70 && rnd > 25 ||
+			   rnd < 160 && rnd > 100 ||
+			   rnd < 200 && rnd > 175 ||
+			   rnd > 235)
+				return;
+			direction.z += 0.05f;
+			if(TheCamera.GetLookDirection() != LOOKING_FORWARD){
+				CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, direction + 0.08f*m_leanMatrix.GetRight(), nil, 0.1f, 0, 0, 0, 1000);
+			}else if(((CTimer::GetFrameCounter() + m_randomSeed) & 1) == 0){
+				direction = 0.8f*m_vecMoveSpeed;
+				CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos, direction + 0.07f*m_leanMatrix.GetRight(), nil, 0.1f, 0, 0, 0, 1000);
+			}
+		}else if(((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 0 ||
+				 ((CTimer::GetFrameCounter() + m_randomSeed) & 3) == 2){
+			CParticle::AddParticle(PARTICLE_ENGINE_STEAM, damagePos + 0.06f*m_leanMatrix.GetRight(), direction);
+		}
+#endif
 }
 
 int32
@@ -3015,6 +3382,395 @@ CBike::ReduceHornCounter(void)
 		m_nCarHornTimer--;
 }
 
+#ifdef IMPROVED_VEHICLES_2
+void CBike::DoVehicleLights(void)
+{
+	CVehicleModelInfo* mi = (CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex());
+
+	// Turn lights on/off
+	bool shouldLightsBeOn = 
+		CClock::GetHours() > 20 ||
+		CClock::GetHours() > 19 && CClock::GetMinutes() > (m_randomSeed & 0x3F) ||
+		CClock::GetHours() < 7 ||
+		CClock::GetHours() < 8 && CClock::GetMinutes() < (m_randomSeed & 0x3F) ||
+		m_randomSeed/50000.0f < CWeather::Foggyness ||
+		m_randomSeed/50000.0f < CWeather::WetRoads;
+	if(shouldLightsBeOn != bLightsOn && GetStatus() != STATUS_WRECKED){
+#ifdef IMPROVED_TECH_PART // Vehicles are muted when the exit button is held down
+		if(GetStatus() == STATUS_ABANDONED || GetStatus() == STATUS_PLAYER_DISABLED) {
+#else
+		if(GetStatus() == STATUS_ABANDONED){
+#endif
+			// Turn off lights on abandoned vehicles only when we they're far away
+			if(bLightsOn &&
+				Abs(TheCamera.GetPosition().x - GetPosition().x) + Abs(TheCamera.GetPosition().y - GetPosition().y) > 100.0f)
+				bLightsOn = false;
+		}else
+			bLightsOn = shouldLightsBeOn;
+	}
+
+	// Actually render the lights
+	bool alarmOn = false;
+	bool alarmOff = false;
+	if(IsAlarmOn()){
+		if(CTimer::GetTimeInMilliseconds() & 0x100)
+			alarmOn = true;
+		else
+			alarmOff = true;
+	}
+
+	if (mi->bNewLights) {
+		if(bEngineOn && bLightsOn || alarmOn || alarmOff){
+			CalculateLeanMatrix();
+			CVector lookVector = GetPosition() - TheCamera.GetPosition();
+			float camDist = lookVector.Magnitude();
+			if(camDist != 0.0f)
+				lookVector *= 1.0f/camDist;
+			else
+				lookVector = CVector(1.0f, 0.0f, 0.0f);
+
+			// 1.0 if directly behind car, -1.0 if in front
+			float behindness = DotProduct(lookVector, GetForward());
+			// 0.0 if behind car, PI if in front
+			float angle = Abs(Acos(Abs(behindness)));
+
+			// Headlight
+
+			CMatrix mat;
+			CVector headLightPos = mi->m_positions[CAR_POS_HEADLIGHTS];
+			if(GetModelIndex() == 152){	// this is the bobcat in VC, but we don't want that effect anyway
+				mat.SetUnity();
+				mat.RotateZ(m_fWheelAngle);
+				mat = m_leanMatrix * mat;
+			}else
+				mat = m_leanMatrix;
+			CVector light = mat * headLightPos;
+			if(behindness < 0.0f && GetFrameLightStatus(BIKE_HEADLIGHT_L) == LIGHT_STATUS_OK){
+				// In front of bike
+				float intensity = -0.5f*behindness + 0.3f;
+				float size = 0.0f - behindness;
+
+				if(alarmOff){
+					CCoronas::RegisterCorona((uintptr)this, 0, 0, 0, 0,
+						light, size, 0.0f,
+						CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+				}else{
+					if(pHandling->Flags & HANDLING_HALOGEN_LIGHTS){
+						CCoronas::RegisterCorona((uintptr)this + 1, 190*intensity, 190*intensity, 255*intensity, 255,
+							light, size, 50.0f*TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+					}else{
+						CCoronas::RegisterCorona((uintptr)this + 1, 210*intensity, 210*intensity, 195*intensity, 255,
+							light, size, 50.0f*TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+					}
+				}
+			}else{
+				CCoronas::UpdateCoronaCoors((uintptr)this, light, 50.0f*TheCamera.LODDistMultiplier, angle);
+			}
+
+			// Taillight
+
+			CVector tailLightPos = mi->m_positions[CAR_POS_TAILLIGHTS];
+			light = m_leanMatrix * tailLightPos;
+
+			// Taillight corona
+			if(behindness > 0.0f && GetFrameLightStatus(BIKE_TAILLIGHT_L) == LIGHT_STATUS_OK){
+				// Behind car
+				float intensity = 0.4f*behindness + 0.4f;
+				float size = (behindness + 0.5f)/2.0f;
+
+				if(m_fBrakePedal > 0.0f){
+					intensity += 0.2f;
+					size += 0.05f;
+				}
+
+				if(alarmOff){
+					CCoronas::RegisterCorona((uintptr)this + 14, 0, 0, 0, 0,
+						light, size, 0.0f,
+						CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+				}else{
+					CCoronas::RegisterCorona((uintptr)this + 14, 128*intensity, 0, 0, 255,
+						light, size, 50.0f*TheCamera.LODDistMultiplier,
+						CCoronas::TYPE_NORMAL, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+				}
+			}else{
+				CCoronas::UpdateCoronaCoors((uintptr)this + 14, light, 50.0f*TheCamera.LODDistMultiplier, angle);
+			}
+
+			// Light shadows
+			if(!alarmOff){
+				CVector pos = GetPosition();
+				CVector2D fwd(GetForward());
+				fwd.Normalise();
+				float f = headLightPos.y + 6.0f;
+				pos += CVector(f*fwd.x, f*fwd.y, 2.0f);
+				if (GetFrameLightStatus(BIKE_HEADLIGHT_L) == LIGHT_STATUS_OK) {
+					CShadows::StoreCarLightShadow(this, (uintptr)this + 22, gpShadowExplosionTex, &pos,
+						7.0f * fwd.x, 7.0f * fwd.y, 3.5f * fwd.y, -3.5f * fwd.x, 45, 45, 45, 7.0f);
+				}
+
+				f = (tailLightPos.y - 2.5f) - (headLightPos.y + 6.0f);
+				pos += CVector(f*fwd.x, f*fwd.y, 0.0f);
+				if (GetFrameLightStatus(BIKE_TAILLIGHT_L) == LIGHT_STATUS_OK) {
+					CShadows::StoreCarLightShadow(this, (uintptr)this + 25, gpShadowExplosionTex, &pos,
+						3.0f, 0.0f, 0.0f, -3.0f, 35, 0, 0, 4.0f);
+				}
+			}
+
+			if(this == FindPlayerVehicle() && !alarmOff){
+				if (GetFrameLightStatus(BIKE_HEADLIGHT_L) == LIGHT_STATUS_OK) {
+					CPointLights::AddLight(CPointLights::LIGHT_DIRECTIONAL, GetPosition(), GetForward(),
+						20.0f, 1.0f, 1.0f, 1.0f,
+						FindPlayerVehicle()->m_vecMoveSpeed.MagnitudeSqr2D() < sq(0.45f) ? CPointLights::FOG_NORMAL : CPointLights::FOG_NONE,
+						false);
+				}
+
+				if (GetFrameLightStatus(BIKE_TAILLIGHT_L) == LIGHT_STATUS_OK) {
+					CVector pos = GetPosition() - 4.0f * GetForward();
+					if (m_fBrakePedal > 0.0f)
+						CPointLights::AddLight(CPointLights::LIGHT_POINT, pos, CVector(0.0f, 0.0f, 0.0f),
+							10.0f, 1.0f, 0.0f, 0.0f,
+							CPointLights::FOG_NONE, false);
+					else
+						CPointLights::AddLight(CPointLights::LIGHT_POINT, pos, CVector(0.0f, 0.0f, 0.0f),
+							7.0f, 0.6f, 0.0f, 0.0f,
+							CPointLights::FOG_NONE, false);
+				}
+			}
+		}else if(GetStatus() != STATUS_ABANDONED && GetStatus() != STATUS_WRECKED){
+			// Lights off
+			CalculateLeanMatrix();
+
+			CVector tailLightPos = mi->m_positions[CAR_POS_TAILLIGHTS];
+			CVector light = m_leanMatrix * tailLightPos;
+
+			if(m_fBrakePedal > 0.0f || m_fGasPedal < 0.0f){
+				CVector lookVector = GetPosition() - TheCamera.GetPosition();
+				lookVector.Normalise();
+				float behindness = DotProduct(lookVector, GetForward());
+				if(behindness > 0.0f && GetFrameLightStatus(BIKE_TAILLIGHT_L) == LIGHT_STATUS_OK){
+					if (m_fGasPedal < 0.0f) {
+						// reversing
+						// no lights in this case
+					} else {
+						// braking
+						CCoronas::RegisterCorona((uintptr)this + 14, 120, 0, 0, 255,
+							light, 1.2f, 50.0f * TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, 0.0f);
+					}
+				}else{
+					CCoronas::UpdateCoronaCoors((uintptr)this + 14, light, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
+				}
+			}else{
+				CCoronas::UpdateCoronaCoors((uintptr)this + 14, light, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
+			}
+		}
+	} else {
+		if(bEngineOn && bLightsOn || alarmOn || alarmOff){
+			CalculateLeanMatrix();
+			CVector lookVector = GetPosition() - TheCamera.GetPosition();
+			float camDist = lookVector.Magnitude();
+			if(camDist != 0.0f)
+				lookVector *= 1.0f/camDist;
+			else
+				lookVector = CVector(1.0f, 0.0f, 0.0f);
+
+			// 1.0 if directly behind car, -1.0 if in front
+			float behindness = DotProduct(lookVector, GetForward());
+			// 0.0 if behind car, PI if in front
+			float angle = Abs(Acos(Abs(behindness)));
+
+			// Headlight
+
+			CMatrix mat;
+			CVector headLightPos = mi->m_positions[CAR_POS_HEADLIGHTS];
+			if(GetModelIndex() == 152){	// this is the bobcat in VC, but we don't want that effect anyway
+				mat.SetUnity();
+				mat.RotateZ(m_fWheelAngle);
+				mat = m_leanMatrix * mat;
+			}else
+				mat = m_leanMatrix;
+			CVector light = mat * headLightPos;
+			if(behindness < 0.0f){
+				// In front of bike
+				float intensity = -0.5f*behindness + 0.3f;
+				float size = 1.0f - behindness;
+
+				if(behindness < -0.97f && camDist < 30.0f){
+					// Directly in front and not too far away
+					if(pHandling->Flags & HANDLING_HALOGEN_LIGHTS){
+						CCoronas::RegisterCorona((uintptr)this + 6, 150, 150, 195, 255,
+							light, 1.2f, 45.0f*TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_HEADLIGHT, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					}else{
+						CCoronas::RegisterCorona((uintptr)this + 6, 160, 160, 140, 255,
+							light, 1.2f, 45.0f*TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_HEADLIGHT, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_OFF, angle);
+					}
+				}
+
+				if(alarmOff){
+					CCoronas::RegisterCorona((uintptr)this, 0, 0, 0, 0,
+						light, size, 0.0f,
+						CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+						CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+				}else{
+					if(pHandling->Flags & HANDLING_HALOGEN_LIGHTS){
+						CCoronas::RegisterCorona((uintptr)this + 1, 190*intensity, 190*intensity, 255*intensity, 255,
+							light, size, 50.0f*TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+					}else{
+						CCoronas::RegisterCorona((uintptr)this + 1, 210*intensity, 210*intensity, 195*intensity, 255,
+							light, size, 50.0f*TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+					}
+				}
+			}else{
+				CCoronas::UpdateCoronaCoors((uintptr)this, light, 50.0f*TheCamera.LODDistMultiplier, angle);
+			}
+
+			// Taillight
+
+			CVector tailLightPos = mi->m_positions[CAR_POS_TAILLIGHTS];
+			light = m_leanMatrix * tailLightPos;
+
+			// Taillight corona
+			if(behindness > 0.0f){
+				// Behind car
+				float intensity = 0.4f*behindness + 0.4f;
+				float size = (behindness + 1.0f)/2.0f;
+
+				if(m_fGasPedal < 0.0f){
+					// reversing
+					// no lights in this case
+				}else{
+					if(m_fBrakePedal > 0.0f){
+						intensity += 0.4f;
+						size += 0.3f;
+					}
+
+					if(alarmOff){
+						CCoronas::RegisterCorona((uintptr)this + 14, 0, 0, 0, 0,
+							light, size, 0.0f,
+							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+					}else{
+						CCoronas::RegisterCorona((uintptr)this + 14, 128*intensity, 0, 0, 255,
+							light, size, 50.0f*TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_STREAK, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, angle);
+					}
+				}
+			}else{
+				CCoronas::UpdateCoronaCoors((uintptr)this + 14, light, 50.0f*TheCamera.LODDistMultiplier, angle);
+			}
+
+			// Light shadows
+			if(!alarmOff){
+				CVector pos = GetPosition();
+				CVector2D fwd(GetForward());
+				fwd.Normalise();
+				float f = headLightPos.y + 6.0f;
+				pos += CVector(f*fwd.x, f*fwd.y, 2.0f);
+				CShadows::StoreCarLightShadow(this, (uintptr)this + 22, gpShadowExplosionTex, &pos,
+					7.0f*fwd.x, 7.0f*fwd.y, 3.5f*fwd.y, -3.5f*fwd.x, 45, 45, 45, 7.0f);
+
+				f = (tailLightPos.y - 2.5f) - (headLightPos.y + 6.0f);
+				pos += CVector(f*fwd.x, f*fwd.y, 0.0f);
+				CShadows::StoreCarLightShadow(this, (uintptr)this + 25, gpShadowExplosionTex, &pos,
+					3.0f, 0.0f, 0.0f, -3.0f, 35, 0, 0, 4.0f);
+			}
+
+			if(this == FindPlayerVehicle() && !alarmOff){
+				CPointLights::AddLight(CPointLights::LIGHT_DIRECTIONAL, GetPosition(), GetForward(),
+					20.0f, 1.0f, 1.0f, 1.0f,
+					FindPlayerVehicle()->m_vecMoveSpeed.MagnitudeSqr2D() < sq(0.45f) ? CPointLights::FOG_NORMAL : CPointLights::FOG_NONE,
+					false);
+				CVector pos = GetPosition() - 4.0f*GetForward();
+				if(m_fBrakePedal > 0.0f)
+					CPointLights::AddLight(CPointLights::LIGHT_POINT, pos, CVector(0.0f, 0.0f, 0.0f),
+						10.0f, 1.0f, 0.0f, 0.0f,
+						CPointLights::FOG_NONE, false);
+				else
+					CPointLights::AddLight(CPointLights::LIGHT_POINT, pos, CVector(0.0f, 0.0f, 0.0f),
+						7.0f, 0.6f, 0.0f, 0.0f,
+						CPointLights::FOG_NONE, false);
+			}
+		}else if(GetStatus() != STATUS_ABANDONED && GetStatus() != STATUS_WRECKED){
+			// Lights off
+			CalculateLeanMatrix();
+
+			CVector tailLightPos = mi->m_positions[CAR_POS_TAILLIGHTS];
+			CVector light = m_leanMatrix * tailLightPos;
+
+			if(m_fBrakePedal > 0.0f || m_fGasPedal < 0.0f){
+				CVector lookVector = GetPosition() - TheCamera.GetPosition();
+				lookVector.Normalise();
+				float behindness = DotProduct(lookVector, GetForward());
+				if(behindness > 0.0f){
+					if(m_fGasPedal < 0.0f){
+						// reversing
+						// no lights in this case
+					}else{
+						// braking
+						CCoronas::RegisterCorona((uintptr)this + 14, 120, 0, 0, 255,
+							light, 1.2f, 50.0f*TheCamera.LODDistMultiplier,
+							CCoronas::TYPE_STAR, CCoronas::FLARE_NONE, CCoronas::REFLECTION_ON,
+							CCoronas::LOSCHECK_OFF, CCoronas::STREAK_ON, 0.0f);
+					}
+				}else{
+					CCoronas::UpdateCoronaCoors((uintptr)this + 14, light, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
+				}
+			}else{
+				CCoronas::UpdateCoronaCoors((uintptr)this + 14, light, 50.0f*TheCamera.LODDistMultiplier, 0.0f);
+			}
+		}
+	}
+}
+
+void CBike::SetFrameLightStatus(eBikeNodes frameNode, uint32 status)
+{
+	if (!m_aBikeNodes[frameNode])
+		return;
+
+	if (status == LIGHT_STATUS_BROKEN && GetFrameLightStatus(frameNode) == LIGHT_STATUS_BROKEN)
+		return;
+
+	CMatrix mat;
+	mat.Attach(RwFrameGetMatrix(m_aBikeNodes[frameNode]));
+	mat.rx = status == LIGHT_STATUS_OK ? 1.0f : 0.0f;
+	mat.fy = status == LIGHT_STATUS_OK ? 1.0f : 0.0f;
+	mat.uz = status == LIGHT_STATUS_OK ? 1.0f : 0.0f;
+	mat.UpdateRW();
+}
+
+uint32 CBike::GetFrameLightStatus(eBikeNodes frameNode)
+{
+	if (!m_aBikeNodes[frameNode])
+		return LIGHT_STATUS_BROKEN;
+
+	uint32 status = LIGHT_STATUS_OK;
+
+	RwMatrix mat = m_aBikeNodes[frameNode]->matrix;
+	if (mat.right.x == 0.0f && mat.at.y == 0.0f && mat.up.z == 0.0f)
+		status = LIGHT_STATUS_BROKEN;
+
+	return status;
+}
+#endif
+
+
 #ifdef COMPATIBLE_SAVES
 void
 CBike::Save(uint8*& buf)
diff --git a/src/vehicles/Bike.h b/src/vehicles/Bike.h
index 219d8872..d77c8ccb 100644
--- a/src/vehicles/Bike.h
+++ b/src/vehicles/Bike.h
@@ -13,6 +13,16 @@ enum eBikeNodes {
 	BIKE_WHEEL_REAR,
 	BIKE_MUDGUARD,
 	BIKE_HANDLEBARS,
+
+#ifdef IMPROVED_VEHICLES_2 // bike nodes
+	BIKE_HEADLIGHT_L,
+	BIKE_TAILLIGHT_L,
+	BIKE_INDICATOR_LF,
+	BIKE_INDICATOR_RF,
+	BIKE_INDICATOR_LR,
+	BIKE_INDICATOR_RR,
+#endif
+
 	BIKE_NUM_NODES
 };
 
@@ -89,6 +99,10 @@ public:
 	float m_fGasPedalAudio;
 	tWheelState m_aWheelState[2];
 
+#ifdef IMPROVED_VEHICLES_2
+	bool m_bIndicatorState[2];
+#endif
+
 	CBike(int32 id, uint8 CreatedBy);
 
 	// from CEntity
@@ -134,6 +148,12 @@ public:
 	void SetupModelNodes(void);
 	void ReduceHornCounter(void);
 
+#ifdef IMPROVED_VEHICLES_2
+	void DoVehicleLights(void);
+	void SetFrameLightStatus(eBikeNodes frameNode, uint32 status);
+	uint32 GetFrameLightStatus(eBikeNodes frameNode);
+#endif
+
 #ifdef COMPATIBLE_SAVES
 	virtual void Save(uint8*& buf);
 	virtual void Load(uint8*& buf);
diff --git a/src/vehicles/Boat.cpp b/src/vehicles/Boat.cpp
index 7c5a1e30..af0319c5 100644
--- a/src/vehicles/Boat.cpp
+++ b/src/vehicles/Boat.cpp
@@ -67,7 +67,13 @@ CBoat::CBoat(int mi, uint8 owner) : CVehicle(owner)
 	pHandling = mod_HandlingManager.GetHandlingData((tVehicleType)minfo->m_handlingId);
 	pFlyingHandling = mod_HandlingManager.GetFlyingPointer((tVehicleType)minfo->m_handlingId);
 	pBoatHandling = mod_HandlingManager.GetBoatPointer((tVehicleType)minfo->m_handlingId);
+
+
+#ifdef IMPROVED_VEHICLES // More colors
+	minfo->ChooseVehicleColour(m_currentColour1, m_currentColour2, m_currentColour3, m_currentColour4);
+#else
 	minfo->ChooseVehicleColour(m_currentColour1, m_currentColour2);
+#endif
 
 	m_fMass = pHandling->fMass;
 	m_fTurnMass = pHandling->fTurnMass / 2.0f;
@@ -1105,7 +1111,13 @@ RwImVertexIndex KeepWaterOutIndices[6];
 void
 CBoat::Render()
 {
+
+#ifdef IMPROVED_VEHICLES // More colors
+	((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->SetVehicleColour(m_currentColour1, m_currentColour2, m_currentColour3, m_currentColour4);
+#else
 	((CVehicleModelInfo*)CModelInfo::GetModelInfo(GetModelIndex()))->SetVehicleColour(m_currentColour1, m_currentColour2);
+#endif
+
 	m_nSetPieceExtendedRangeTime = CTimer::GetTimeInMilliseconds() + 3000;
 	if (!CVehicle::bWheelsOnlyCheat)
 		CEntity::Render();
diff --git a/src/vehicles/CarGen.cpp b/src/vehicles/CarGen.cpp
index bce8cdab..e41b8628 100644
--- a/src/vehicles/CarGen.cpp
+++ b/src/vehicles/CarGen.cpp
@@ -128,6 +128,12 @@ void CCarGenerator::DoInternalProcessing()
 	pVehicle->SetOrientation(0.0f, 0.0f, DEGTORAD(m_fAngle));
 	pVehicle->SetStatus(STATUS_ABANDONED);
 	pVehicle->m_nDoorLock = CARLOCK_UNLOCKED;
+
+#ifdef VEHICLE_MODS // TrySetRandomCarMod for parked vehicles
+	if (pVehicle->IsCar())
+		((CAutomobile*)pVehicle)->TrySetRandomCarMod();
+#endif
+
 	CWorld::Add(pVehicle);
 	if (CGeneral::GetRandomNumberInRange(0, 100) < m_nAlarm)
 		pVehicle->m_nAlarmState = -1;
diff --git a/src/vehicles/Transmission.cpp b/src/vehicles/Transmission.cpp
index 1aeabfe0..036f3a9e 100644
--- a/src/vehicles/Transmission.cpp
+++ b/src/vehicles/Transmission.cpp
@@ -55,8 +55,15 @@ cTransmission::CalculateGearForSimpleCar(float speed, uint8 &gear)
 	}
 }
 
+
+
+#ifdef VEHICLE_MODS // additional engine acceleration
+float
+cTransmission::CalculateDriveAcceleration(const float &gasPedal, uint8 &gear, float &time, const float &velocity, bool cheat, float additionalAccel)
+#else
 float
-cTransmission::CalculateDriveAcceleration(const float &gasPedal, uint8 &gear, float &time, const float &velocity, bool cheat)
+cTransmission::CalculateDriveAcceleration(const float& gasPedal, uint8& gear, float& time, const float& velocity, bool cheat)
+#endif
 {
 	static float fAcceleration = 0.0f;
 	static float fVelocity;
@@ -121,7 +128,14 @@ cTransmission::CalculateDriveAcceleration(const float &gasPedal, uint8 &gear, fl
 	else
 		fCheat = 1.0f;
 	float targetVelocity = Gears[gear].fMaxVelocity*speedMul*fCheat;
+
+#ifdef VEHICLE_MODS // engine acceleration
+	float accel = (targetVelocity - fVelocity) * ((fEngineAcceleration + additionalAccel) * accelMul) / Abs(targetVelocity);
+#else
 	float accel = (targetVelocity - fVelocity) * (fEngineAcceleration*accelMul) / Abs(targetVelocity);
+#endif
+
+
 	if(Abs(fVelocity) < Abs(Gears[gear].fMaxVelocity*fCheat))
 		fAcceleration = gasPedal * accel * CTimer::GetTimeStep();
 	else
diff --git a/src/vehicles/Transmission.h b/src/vehicles/Transmission.h
index a3d15513..01015c4d 100644
--- a/src/vehicles/Transmission.h
+++ b/src/vehicles/Transmission.h
@@ -24,5 +24,10 @@ public:
 
 	void InitGearRatios(void);
 	void CalculateGearForSimpleCar(float speed, uint8 &gear);
+
+#ifdef VEHICLE_MODS // additional engine acceleration
+	float CalculateDriveAcceleration(const float &gasPedal, uint8 &gear, float &time, const float &velocity, bool cheat, float additionalAccel = 0.0f);
+#else
 	float CalculateDriveAcceleration(const float &gasPedal, uint8 &gear, float &time, const float &velocity, bool cheat);
+#endif
 };
diff --git a/src/vehicles/Vehicle.cpp b/src/vehicles/Vehicle.cpp
index c68bd1a6..dca14dce 100644
--- a/src/vehicles/Vehicle.cpp
+++ b/src/vehicles/Vehicle.cpp
@@ -186,6 +186,15 @@ CVehicle::CVehicle(uint8 CreatedBy)
 	AutoPilot.m_bStayInCurrentLevel = false;
 	AutoPilot.m_bIgnorePathfinding = false;
 	AutoPilot.m_nSwitchDistance = 20;
+
+#if defined VEHICLE_MODS && defined IMPROVED_VEHICLES
+	m_nTempColor1 = 0;
+	m_nTempColor2 = 0;
+	m_nTempColor3 = 0;
+	m_nTempColor4 = 0;
+	m_nArmorLevel = 0;
+	m_fAddEngineAcceleration = 0.0f;
+#endif
 }
 
 CVehicle::~CVehicle()
@@ -1353,6 +1362,27 @@ CVehicle::InflictDamage(CEntity *damagedBy, eWeaponType weaponType, float damage
 				SetStatus(STATUS_PHYSICS);
 			}
 		}
+
+#ifdef VEHICLE_MODS // armor
+		float absorbedDamage = 1.0f;
+		switch (m_nArmorLevel)
+		{
+		case 1:
+			absorbedDamage = 1.25f;
+			break;
+		case 2:
+			absorbedDamage = 1.5f;
+			break;
+		case 3:
+			absorbedDamage = 1.75f;
+			break;
+		case 4:
+			absorbedDamage = 2.0f;
+			break;
+		}
+		damage /= absorbedDamage;
+#endif
+
 		m_nLastWeaponDamage = weaponType;
 		m_pLastDamageEntity = damagedBy;
 		float oldHealth = m_fHealth;
diff --git a/src/vehicles/Vehicle.h b/src/vehicles/Vehicle.h
index d3fd91a1..7f383db6 100644
--- a/src/vehicles/Vehicle.h
+++ b/src/vehicles/Vehicle.h
@@ -41,6 +41,53 @@ enum eCarNodes
 	CAR_BONNET,
 	CAR_BOOT,
 	CAR_WINDSCREEN,
+
+#ifdef IMPROVED_VEHICLES_2 // car nodes
+	CAR_STEERINGWHEEL,
+	CAR_HEADLIGHT_L,
+	CAR_HEADLIGHT_R,
+	CAR_TAILLIGHT_L,
+	CAR_TAILLIGHT_R,
+	CAR_REVERSINGLIGHT_L,
+	CAR_REVERSINGLIGHT_R,
+	CAR_BRAKELIGHT_L,
+	CAR_BRAKELIGHT_R,
+	CAR_INDICATOR_LF,
+	CAR_INDICATOR_RF,
+	CAR_INDICATOR_2_LF,
+	CAR_INDICATOR_2_RF,
+	CAR_INDICATOR_LR,
+	CAR_INDICATOR_RR,
+	CAR_INDICATOR_2_LR,
+	CAR_INDICATOR_2_RR,
+	CAR_WINDOW_L_MISC,
+	CAR_WINDOW_R_MISC,
+	CAR_WINDOW_REAR,
+#endif
+
+#ifdef VEHICLE_MODS // car nodes
+	CAR_SPOILER_OK,
+	CAR_SPOILER_DAM,
+	CAR_SKIRT_L,
+	CAR_SKIRT_R,
+	CAR_RF_SCOOP,
+	CAR_BNT_SCOOP_OK,
+	CAR_BNT_SCOOP_DAM,
+	CAR_VENT_L_OK,
+	CAR_VENT_L_DAM,
+	CAR_VENT_R_OK,
+	CAR_VENT_R_DAM,
+	CAR_SUPERCHARGER,
+#endif
+
+#ifdef IMPROVED_VEHICLES // Service lights for service cars and cleareance lights
+	CAR_SERVICELIGHTS_0,
+	CAR_SERVICELIGHTS_1,
+	CAR_SERVICELIGHTS_2,
+	CAR_SERVICELIGHTS_3,
+	CAR_CLEARANCE_LIGHTS,
+#endif
+
 	NUM_CAR_NODES,
 };
 
@@ -102,6 +149,14 @@ enum eLights
 	VEHLIGHT_REAR_RIGHT,
 };
 
+#ifdef IMPROVED_VEHICLES_2 // indicators
+enum eIndicators
+{
+	INDICATORS_LEFT,
+	INDICATORS_RIGHT,
+};
+#endif
+
 enum
 {
 	CAR_PIECE_BONNET = 1,
@@ -179,6 +234,12 @@ public:
 	CAutoPilot AutoPilot;
 	uint8 m_currentColour1;
 	uint8 m_currentColour2;
+
+#ifdef IMPROVED_VEHICLES // More colors
+	uint8 m_currentColour3;
+	uint8 m_currentColour4;
+#endif
+
 	int8 m_aExtras[2];
 	int16 m_nAlarmState;
 	int16 m_nRouteSeed;
@@ -280,6 +341,15 @@ public:
 	float m_fSteerInput;
 	eVehicleType m_vehType;
 
+#if defined VEHICLE_MODS && defined IMPROVED_VEHICLES
+	int m_nTempColor1;
+	int m_nTempColor2;
+	int m_nTempColor3;
+	int m_nTempColor4;
+	int m_nArmorLevel;
+	float m_fAddEngineAcceleration;
+#endif
+
 	static void *operator new(size_t) throw();
 	static void *operator new(size_t sz, int slot) throw();
 	static void operator delete(void*, size_t) throw();
diff --git a/src/weapons/BulletInfo.cpp b/src/weapons/BulletInfo.cpp
index b49db74a..c1f43849 100644
--- a/src/weapons/BulletInfo.cpp
+++ b/src/weapons/BulletInfo.cpp
@@ -182,6 +182,12 @@ void CBulletInfo::Update(void)
 						if ( pBullet->m_eWeaponType == WEAPONTYPE_FLAMETHROWER ) {
 							gFireManager.StartFire(pHitEntity, pBullet->m_pSource, 0.8f, 1);
 						} else {
+#ifdef IMPROVED_VEHICLES_2 // check for shooting vehicle lights and petrolcap
+							CWeapon::CheckForShootingVehicleLights(pHitEntity, point);
+							CWeapon::CheckForShootingVehiclePetrolCap(source, pHitEntity, point);
+#endif
+
+
 							for (int j=0; j<NUM_VEHICLE_SPARKS; j++) {
 								CParticle::AddParticle(PARTICLE_SPARK, point.point, point.normal / 20);
 							}
diff --git a/src/weapons/Weapon.cpp b/src/weapons/Weapon.cpp
index 6ebf105c..83799c36 100644
--- a/src/weapons/Weapon.cpp
+++ b/src/weapons/Weapon.cpp
@@ -1189,6 +1189,13 @@ CWeapon::FireInstantHit(CEntity *shooter, CVector *fireSource)
 		}
 	}
 
+#ifdef IMPROVED_VEHICLES_2 // check for shooting vehicle lights and petrolcap
+	if (victim) {
+		CheckForShootingVehicleLights(victim, point);
+		CheckForShootingVehiclePetrolCap(shooter, victim, point);
+	}
+#endif
+
 	if ( shooter->IsPed() && victim)
 	{
 		if (victim == ((CPed*)shooter)->m_leader)
@@ -2053,6 +2060,12 @@ CWeapon::FireShotgun(CEntity *shooter, CVector *fireSource)
 				{
 					case ENTITY_TYPE_VEHICLE:
 					{
+
+#ifdef IMPROVED_VEHICLES_2 // check for shooting vehicle lights and petrolcap
+						CheckForShootingVehicleLights(victim, point);
+						CheckForShootingVehiclePetrolCap(shooter, victim, point);
+#endif
+
 						if (point.pieceB >= CAR_PIECE_WHEEL_LF && point.pieceB <= CAR_PIECE_WHEEL_RR) {
 							((CVehicle*)victim)->BurstTyre(point.pieceB, true);
 
@@ -3554,6 +3567,96 @@ CWeapon::CheckForShootingVehicleOccupant(CEntity **victim, CColPoint *point, eWe
 	}
 }
 
+#ifdef IMPROVED_VEHICLES_2 // check for shooting vehicle lights and petrolcap
+void CWeapon::CheckForShootingVehicleLights(CEntity* victim, CColPoint point)
+{
+	if (!victim->IsVehicle())
+		return;
+
+	CVehicle* vehicle = (CVehicle*)victim;
+
+	if (!vehicle)
+		return;
+
+	if (!vehicle->IsCar() && !vehicle->IsBike())
+		return;
+
+	if (vehicle->IsCar()) {
+		CAutomobile* automobile = (CAutomobile*)vehicle;
+		for (int frameID = CAR_HEADLIGHT_L; frameID < NUM_CAR_NODES; frameID++) {
+			RwFrame* lightFrame = automobile->m_aCarNodes[frameID];
+			if (!lightFrame)
+				continue;
+
+			if (automobile->GetFrameLightStatus((eCarNodes)frameID) == LIGHT_STATUS_BROKEN)
+				continue;
+
+			float radius = 0.035f;
+			float distanceSqr = (point.point - lightFrame->getLTM()->pos).MagnitudeSqr();
+			if (distanceSqr > radius || point.normal.z > 0.9f)
+				continue;
+
+			automobile->SetFrameLightStatus((eCarNodes)frameID, LIGHT_STATUS_BROKEN);
+			DMAudio.PlayOneShot(automobile->m_audioEntityId, SOUND_CAR_LIGHT_BREAK, 1.0f);
+
+			break;
+		}
+	} else {
+		CBike* bike = (CBike*)vehicle;
+		for (int frameID = BIKE_HEADLIGHT_L; frameID < BIKE_NUM_NODES; frameID++) {
+			RwFrame* lightFrame = bike->m_aBikeNodes[frameID];
+			if (!lightFrame)
+				continue;
+
+			if (bike->GetFrameLightStatus((eBikeNodes)frameID) == LIGHT_STATUS_BROKEN)
+				continue;
+
+			float radius = 0.035f;
+			float distanceSqr = (point.point - lightFrame->getLTM()->pos).MagnitudeSqr();
+			if (distanceSqr > radius || point.normal.z > 0.9f)
+				continue;
+
+			bike->SetFrameLightStatus((eBikeNodes)frameID, LIGHT_STATUS_BROKEN);
+			DMAudio.PlayOneShot(bike->m_audioEntityId, SOUND_CAR_LIGHT_BREAK, 1.0f);
+
+			break;
+		}
+	}
+}
+void CWeapon::CheckForShootingVehiclePetrolCap(CEntity *shooter, CEntity* victim, CColPoint point)
+{
+	if (!victim->IsVehicle())
+		return;
+
+	CVehicle* vehicle = (CVehicle*)victim;
+
+	if (!vehicle)
+		return;
+
+	if (vehicle->bRenderScorched)
+		return;
+
+	if (vehicle == FindPlayerVehicle())
+		return;
+
+	if (!vehicle->IsCar() && !vehicle->IsBike())
+		return;
+
+	CVehicleModelInfo* mi = (CVehicleModelInfo*)CModelInfo::GetModelInfo(vehicle->GetModelIndex());
+
+	CAutomobile* automobile = (CAutomobile*)vehicle;
+	CVector petrolCapPos = mi->m_positions[CAR_POS_PETROLCAP];
+	petrolCapPos = vehicle->GetMatrix() * petrolCapPos;
+
+	float radius = 0.03f;
+	float distanceSqr = (point.point - petrolCapPos).MagnitudeSqr();
+	if (distanceSqr > radius)
+		return;
+
+	vehicle->BlowUpCar(shooter);
+}
+#endif
+
 #ifdef COMPATIBLE_SAVES
 #define CopyFromBuf(buf, data) memcpy(&data, buf, sizeof(data)); SkipSaveBuf(buf, sizeof(data));
 #define CopyToBuf(buf, data) memcpy(buf, &data, sizeof(data)); SkipSaveBuf(buf, sizeof(data));
diff --git a/src/weapons/Weapon.h b/src/weapons/Weapon.h
index 3347e36e..9f72b972 100644
--- a/src/weapons/Weapon.h
+++ b/src/weapons/Weapon.h
@@ -84,6 +84,11 @@ public:
 
 	static void CheckForShootingVehicleOccupant(CEntity **victim, CColPoint *point, eWeaponType weapon, CVector const& source, CVector const& target);
 
+#ifdef IMPROVED_VEHICLES_2
+	static void CheckForShootingVehicleLights(CEntity *victim, CColPoint point);
+	static void CheckForShootingVehiclePetrolCap(CEntity *shooter, CEntity *victim, CColPoint point);
+#endif
+
 #ifdef COMPATIBLE_SAVES
 	void Save(uint8*& buf);
 	void Load(uint8*& buf);
diff --git a/vendor/librw b/vendor/librw
index 5501c4fd..b7475b07 160000
--- a/vendor/librw
+++ b/vendor/librw
@@ -1 +1 @@
-Subproject commit 5501c4fdc7425ff926be59369a13593bb6c81b54
+Subproject commit b7475b075203784382bd8d3c26b869120076d480
-- 
2.45.1.windows.1

